<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Knowledge Tree Workflow System</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            overflow: hidden;
            user-select: none;
        }

        /* Top Bar */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: linear-gradient(to right, #1e3c72, #2a5298);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        #topbar h1 {
            font-size: 18px;
            font-weight: 500;
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #topbar button {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-left: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        #topbar button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        #topbar #clear-btn {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }
        
        #topbar #clear-btn:hover {
            background: rgba(220, 53, 69, 0.5);
        }

        input[type="file"] {
            display: none;
        }

        /* Canvas */
        #canvas {
            position: absolute;
            top: 48px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            background-color: #e8eaed;
            background-image: radial-gradient(circle, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: grab;
        }
        
        #canvas.panning {
            cursor: grabbing !important;
        }
        
        #canvas.linking {
            cursor: crosshair !important;
        }

        #viewport {
            position: relative;
            min-width: 100%;
            min-height: 100%;
            width: 8000px;
            height: 8000px;
            transform-origin: 0 0;
            transition: none;
        }
        
        #links-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* Base Node Styles */
        .node {
            position: absolute;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: default;
            transition: box-shadow 0.2s, transform 0.2s, border-color 0.2s, width 0.3s ease, height 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 200px;
            min-height: 100px;
        }

        .node:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
        }

        .node.selected {
            border-color: #1a73e8;
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2);
            z-index: 10;
        }
        
        .node.link-source {
            border-color: #1a73e8 !important;
            border-width: 3px !important;
        }
        
        .node.link-target {
            border-color: #4caf50 !important;
            border-width: 3px !important;
        }

        .node.dragging {
            opacity: 0.9;
            cursor: grabbing;
            z-index: 100;
            transition: none;
        }

        /* Node Header */
        .node-header {
            padding: 10px 14px;
            background: linear-gradient(to bottom, #fafafa, #f5f5f5);
            border-bottom: 1px solid #e0e0e0;
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            flex-shrink: 0;
        }
        
        .node.group:not(.expanded) .node-header { display: none; }


        .node.dragging .node-header {
            cursor: grabbing;
        }

        .node-type-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .node-title {
            font-weight: 600;
            font-size: 14px;
            color: #202124;
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .node-title[contenteditable="true"] {
            background: rgba(26, 115, 232, 0.1);
            outline: 1px solid rgba(26, 115, 232, 0.5);
            cursor: text;
            user-select: text;
        }

        .node-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .node-control {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.2s;
            color: #5f6368;
        }

        .node-control:hover {
            background: rgba(0,0,0,0.08);
        }

        .expand-icon {
            transition: transform 0.2s;
        }

        .node.expanded .expand-icon {
            transform: rotate(90deg);
        }

        /* Node Content */
        .node-content {
            padding: 12px;
            flex-grow: 1;
            overflow-y: auto;
            user-select: text;
            display: none;
        }

        .node.expanded .node-content {
            display: block;
        }
        
        .node.group:not(.expanded) .node-content { display: none; }


        /* Node Type Specific Styles */
        .node.scribble { background: #fffef0; border-color: #f9cc30; }
        .node.scribble .node-header { background: linear-gradient(to bottom, #fff9c4, #fff59d); }
        .node.group { background: #e3f2fd; border-color: #2196f3; }
        .node.group .node-header { background: linear-gradient(to bottom, #bbdefb, #90caf9); }
        .node.group.expanded { min-width: 400px; min-height: 300px; }
        .node.task { background: #f3e5f5; border-color: #9c27b0; }
        .node.task .node-header { background: linear-gradient(to bottom, #e1bee7, #ce93d8); }
        .node.estimator { background: #e8f5e9; border-color: #4caf50; }
        .node.estimator .node-header { background: linear-gradient(to bottom, #c8e6c9, #a5d6a7); }
        .node.data { background: #fff3e0; border-color: #ff9800; }
        .node.data .node-header { background: linear-gradient(to bottom, #ffe0b2, #ffcc80); }
        .node.knowledge-section { background: #e0f2f1; border-color: #009688; }
        .node.knowledge-subsection { background: #e8eaf6; border-color: #3f51b5; }
        .node.knowledge-item { background: #fce4ec; border-color: #e91e63; }
        .node.adr { background: #efebe9; border-color: #795548; }

        /* Group Content Styles */
        .group-content {
            position: relative;
            min-height: 200px;
            padding: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-content: flex-start;
        }

        .group-icon-representation {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 8px;
            cursor: pointer;
        }

        .node.group:not(.expanded) {
            padding: 0;
            min-width: 90px !important;
            min-height: 100px !important;
            justify-content: center;
        }

        .node.group:not(.expanded) .group-icon-representation {
            display: flex;
        }

        .group-icon-representation-symbol {
            font-size: 32px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .group-icon-representation-title {
            font-size: 11px;
            text-align: center;
            color: #5f6368;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
            max-width: 100%;
        }


        .group-child-icon {
            width: 80px;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .group-child-icon:hover {
            background: rgba(255,255,255,1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        .group-child-icon-symbol {
            font-size: 32px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .group-child-icon-title {
            font-size: 11px;
            text-align: center;
            color: #5f6368;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }

        /* Inline expanded nodes within groups */
        .inline-node {
            position: relative;
            width: 100%;
            margin-bottom: 16px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        .inline-node .node-header {
            cursor: default;
            position: relative;
        }

        .inline-collapse-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            background: rgba(0,0,0,0.05);
            transition: background 0.2s;
            color: #5f6368;
            font-size: 12px;
        }

        .inline-collapse-btn:hover {
            background: rgba(0,0,0,0.1);
            color: #202124;
        }

        /* Content Styles */
        .scribble-content { width: 100%; min-height: 100px; padding: 8px; resize: none; font-family: inherit; font-size: 13px; line-height: 1.6; background: transparent; border: none; outline: none; }
        .task-content label { display: flex; align-items: center; margin-bottom: 8px; font-size: 13px; }
        .task-content label span { width: 120px; color: #5f6368; font-weight: 500; }
        .task-content input, .task-content select { flex: 1; padding: 4px 8px; border: 1px solid #dadce0; border-radius: 4px; font-size: 13px; }
        .task-description { font-size: 12px; color: #5f6368; margin-bottom: 12px; padding: 8px; background: rgba(0,0,0,0.03); border-radius: 4px; line-height: 1.5; }
        .estimator-content h4 { font-size: 14px; margin-bottom: 12px; color: #202124; }
        .estimator-result { margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0; }
        .estimator-result p { margin: 4px 0; font-size: 13px; }
        .estimator-result strong { color: #1976d2; font-weight: 600; }
        .data-image { max-width: 100%; height: auto; display: block; border-radius: 4px; }
        .data-text { width: 100%; min-height: 100px; border: 1px solid #dadce0; border-radius: 4px; padding: 8px; resize: none; font-family: inherit; font-size: 13px; }
        .knowledge-content, .adr-content textarea { width: 100%; min-height: 80px; border: 1px solid #dadce0; border-radius: 4px; padding: 8px; resize: vertical; font-family: inherit; font-size: 13px; line-height: 1.5; }
        .adr-content label { display: flex; align-items: flex-start; margin-bottom: 8px; font-size: 13px; }
        .adr-content label span { width: 80px; color: #5f6368; font-weight: 500; padding-top: 4px; }
        .adr-content input, .adr-content textarea { flex: 1; padding: 4px 8px; border: 1px solid #dadce0; border-radius: 4px; font-size: 13px; }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #bdbdbd 50%);
            border-radius: 0 0 6px 0;
        }

        .node.group:not(.expanded) .resize-handle { display: none; }

        /* Links */
        .link {
            fill: none;
            stroke: currentColor;
            color: #9e9e9e;
            stroke-width: 2.5;
            opacity: 0.8;
            transition: all 0.2s;
        }
        
        .link:hover {
            color: #1a73e8;
            stroke-width: 4;
            opacity: 1;
        }
        
        .link-clickable {
            fill: none;
            stroke: transparent;
            stroke-width: 12;
            cursor: pointer;
            pointer-events: stroke;
        }

        .link-arrow {
            fill: currentColor;
        }

        /* Context Menu */
        #context-menu {
            position: fixed;
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 4px 0;
            min-width: 180px;
            z-index: 1001;
            display: none;
        }

        .menu-item { padding: 8px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .menu-item:hover { background: #f5f5f5; }
        .menu-separator { height: 1px; background: #e0e0e0; margin: 4px 0; }

        /* Loading */
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 24px 32px; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); display: none; z-index: 2000; }

        /* Info Panel */
        #info-panel { position: fixed; bottom: 16px; left: 16px; background: white; padding: 12px 16px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 12px; color: #5f6368; z-index: 500; display: flex; gap: 16px; }
        
        /* Zoom Indicator */
        #zoom-indicator { position: fixed; bottom: 16px; right: 16px; background: white; padding: 8px 12px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 12px; color: #5f6368; z-index: 500; font-weight: 500; }

        /* Selection Rectangle */
        #selection-rect {
            position: absolute;
            border: 1px dashed #1a73e8;
            background: rgba(26, 115, 232, 0.1);
            pointer-events: none;
            z-index: 999;
            display: none;
        }

        /* Modal Styles */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        #modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
            display: flex;
        }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    </style>
</head>
<body>
    <div id="topbar">
        <h1>üìä Advanced Knowledge Tree Workflow System</h1>
        <button id="save-btn">üíæ Save Workflow</button>
        <button id="load-btn">üìÅ Load Workflow</button>
        <button id="fit-btn">üîç Fit to Screen</button>
        <button id="zoom-in-btn">‚ûï Zoom In</button>
        <button id="zoom-out-btn">‚ûñ Zoom Out</button>
        <button id="auto-layout-btn">üîÄ Auto Layout</button>
        <button id="reset-btn">üè† Reset View</button>
        <button id="clear-btn">üóëÔ∏è Clear All</button>
        <input type="file" id="file-input" accept=".json">
    </div>

    <div id="canvas">
        <div id="viewport">
            <svg id="links-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9.5" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" class="link-arrow"/>
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div id="context-menu">
        <div class="menu-item" data-action="add-scribble">üìù Add Scribble Pad</div>
        <div class="menu-item" data-action="add-task">‚úì Add Task</div>
        <div class="menu-item" data-action="add-group">üìÅ Add Group</div>
        <div class="menu-item" data-action="add-estimator">üìä Add Estimator</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="add-knowledge-section">üìö Knowledge Section</div>
        <div class="menu-item" data-action="add-knowledge-subsection">üìñ Knowledge Subsection</div>
        <div class="menu-item" data-action="add-knowledge-item">üìÑ Knowledge Item</div>
        <div class="menu-item" data-action="add-adr">üèõÔ∏è Add ADR</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="paste">üìã Paste Data</div>
    </div>

    <div id="info-panel">
        <span>Right-click for menu</span>
        <span>‚Ä¢</span>
        <span>Alt+drag to link</span>
        <span>‚Ä¢</span>
        <span>Ctrl+drag to select</span>
        <span>‚Ä¢</span>
        <span>Scroll to zoom</span>
    </div>

    <div id="zoom-indicator">100%</div>
    <div id="loading">Loading workflow...</div>
    <div id="selection-rect"></div>
    <div id="modal-overlay">
        <div id="modal-content"></div>
    </div>

    <script>
        // State management
        let workflow = { items: {}, links: [], nextItemId: 1, nextLinkId: 1 };
        let selectedNode = null;
        let selectedNodes = [];
        let isDragging = false;
        let isResizing = false;
        let isLinking = false;
        let isSelecting = false;
        let isPanning = false;
        let linkSource = null;
        let tempLinkLine = null;
        let dragOffset = { x: 0, y: 0 };
        let selectStart = { x: 0, y: 0 };
        let panStart = { x: 0, y: 0 };
        let panStartTime = 0;
        let contextMenuPos = { x: 0, y: 0, groupId: null };
        let groups = {};
        let expandedInlineNodes = {};
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        const panThreshold = 5;
        const STORAGE_KEY = 'workflow-visualizer-state';
        const GROUP_COLLAPSED_WIDTH = 90;
        const GROUP_COLLAPSED_HEIGHT = 100;

        // DOM elements
        const canvas = document.getElementById('canvas');
        const viewport = document.getElementById('viewport');
        const linksSvg = document.getElementById('links-svg');
        const contextMenu = document.getElementById('context-menu');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const fileInput = document.getElementById('file-input');
        const fitBtn = document.getElementById('fit-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const autoLayoutBtn = document.getElementById('auto-layout-btn');
        const resetBtn = document.getElementById('reset-btn');
        const clearBtn = document.getElementById('clear-btn');
        const loading = document.getElementById('loading');
        const zoomIndicator = document.getElementById('zoom-indicator');
        const selectionRect = document.getElementById('selection-rect');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');

        const nodeIcons = { 'scribble': 'üìù', 'task': '‚úì', 'group': 'üìÅ', 'estimator': 'üìä', 'data': 'üìã', 'knowledge-section': 'üìö', 'knowledge-subsection': 'üìñ', 'knowledge-item': 'üìÑ', 'adr': 'üèõÔ∏è' };

        // --- Initialization ---
        function initialize() {
            // Top bar buttons
            saveBtn.addEventListener('click', saveWorkflow);
            loadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileLoad);
            fitBtn.addEventListener('click', fitToScreen);
            zoomInBtn.addEventListener('click', () => zoom(1.2));
            zoomOutBtn.addEventListener('click', () => zoom(0.8));
            autoLayoutBtn.addEventListener('click', autoLayout);
            resetBtn.addEventListener('click', resetView);
            clearBtn.addEventListener('click', clearAll);

            // Main canvas events
            canvas.addEventListener('contextmenu', handleContextMenu);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp); // End actions if mouse leaves canvas
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('scroll', autoSave);
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleDrop);

            // Other listeners
            document.addEventListener('paste', handlePaste);
            document.addEventListener('keydown', handleKeyboard);
            contextMenu.addEventListener('click', handleMenuClick);
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) closeModal();
            });

            // Load data
            if (!loadFromLocalStorage()) {
                renderWorkflow();
                updateViewportTransform();
            }
        }

        // --- Event Handlers (Mouse, Keyboard, etc.) ---

        function handleMouseDown(e) {
            const clickedNode = e.target.closest('.node');
            const clickedLink = e.target.closest('.link-clickable');

            if (!clickedNode && !clickedLink && (e.ctrlKey || e.metaKey)) {
                startSelection(e);
                return;
            }

            if ((e.button === 0 && !clickedNode && !clickedLink) || e.button === 1) {
                panStart = { x: e.clientX, y: e.clientY };
                panStartTime = Date.now();
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (isSelecting) {
                handleSelection(e);
                return;
            }

            if (panStart.x !== 0 || panStart.y !== 0) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                
                if (!isPanning && Math.sqrt(dx * dx + dy * dy) > panThreshold) {
                    isPanning = true;
                    canvas.classList.add('panning');
                }

                if (isPanning) {
                    canvas.scrollLeft -= dx;
                    canvas.scrollTop -= dy;
                    panStart = { x: e.clientX, y: e.clientY };
                }
            }
        }

        function handleMouseUp(e) {
            if (isSelecting) endSelection();
            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('panning');
                autoSave();
            }
            if ((panStart.x !== 0 || panStart.y !== 0) && !isPanning && Date.now() - panStartTime < 200) {
                handleCanvasClick(e);
            }
            panStart = { x: 0, y: 0 };
        }

        function handleCanvasClick(e) {
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
            }
            
            const clickedNode = e.target.closest('.node');
            if (!clickedNode) {
                clearSelection();
                const canvasRect = canvas.getBoundingClientRect();
                contextMenuPos = {
                    x: (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale,
                    y: (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale,
                    groupId: null
                };
            }
        }

        function handleContextMenu(e) {
            e.preventDefault();
            if (isPanning) return;
            
            const targetElement = e.target;
            const groupNode = targetElement.closest('.node.group');
            const anyNode = targetElement.closest('.node');
            
            if (!anyNode || groupNode) {
                const canvasRect = canvas.getBoundingClientRect();
                contextMenuPos = {
                    x: (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale,
                    y: (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale,
                    groupId: groupNode ? (groupNode.id.startsWith('inline-') ? groupNode.id.substring(7) : groupNode.id) : null
                };
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.style.display = 'block';
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom(delta, e.clientX, e.clientY);
        }

        function handleKeyboard(e) {
            const activeElement = document.activeElement;
            if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true') return;
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === '+' || e.key === '=') { e.preventDefault(); zoom(1.1); } 
                else if (e.key === '-') { e.preventDefault(); zoom(0.9); } 
                else if (e.key === '0') { e.preventDefault(); resetView(); } 
                else if (e.key === 'Enter') { e.preventDefault(); groupSelectedNodes(); }
            }
            
            if (e.key === 'Delete' && (selectedNode || selectedNodes.length > 0)) {
                if (confirm('Delete selected node(s)?')) {
                    if (selectedNodes.length > 0) {
                        [...selectedNodes].forEach(node => deleteNode(node.id));
                    } else if (selectedNode) {
                        deleteNode(selectedNode.id);
                    }
                    clearSelection();
                }
            }
        }

        // --- Core Functionality (Nodes, Links, Groups) ---

        function createNode(item, isInline = false, parentElement = null, isModal = false) {
            const node = document.createElement('div');
            node.className = `node ${item.type}${isInline ? ' inline-node' : ''}`;
            node.id = isInline ? `inline-${item.id}` : (isModal ? `modal-${item.id}` : item.id);
            
            if (!isInline && !isModal) {
                node.style.left = item.x + 'px';
                node.style.top = item.y + 'px';
            }
            
            if (item.type === 'group' && !item.data.isExpanded) {
                node.style.width = GROUP_COLLAPSED_WIDTH + 'px';
                node.style.height = GROUP_COLLAPSED_HEIGHT + 'px';
            } else {
                node.style.width = item.width + 'px';
                node.style.height = item.height + 'px';
            }
            
            const header = document.createElement('div');
            header.className = 'node-header';
            
            const icon = document.createElement('div');
            icon.className = 'node-type-icon';
            icon.textContent = nodeIcons[item.type] || 'üìÑ';
            
            const title = document.createElement('div');
            title.className = 'node-title';
            title.textContent = item.data.title || 'Untitled';
            
            const controls = document.createElement('div');
            controls.className = 'node-controls';
            
            if (hasExpandableContent(item) && !isInline && !isModal) {
                const expandBtn = document.createElement('div');
                expandBtn.className = 'node-control expand-icon';
                expandBtn.innerHTML = '‚ñ∂';
                expandBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleNode(node); });
                controls.appendChild(expandBtn);
            }
            
            if (!isInline && !isModal) {
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'node-control';
                deleteBtn.innerHTML = '‚úï';
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); if (confirm('Delete this node?')) deleteNode(item.id); });
                controls.appendChild(deleteBtn);
            }
            
            if (isInline || isModal) {
                const collapseBtn = document.createElement('div');
                collapseBtn.className = 'inline-collapse-btn';
                collapseBtn.innerHTML = '‚óÄ';
                collapseBtn.title = isModal ? 'Close' : 'Collapse to icon';
                collapseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isModal) closeModal();
                    else if (item.parentId) toggleInlineNode(item.id, item.parentId);
                });
                header.appendChild(collapseBtn);
            }
            
            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'node-content';
            
            switch (item.type) {
                case 'scribble': content.innerHTML = `<textarea class="scribble-content" placeholder="Scribble away...">${item.data.content || ''}</textarea>`; break;
                case 'task': content.innerHTML = createTaskContent(item.data); break;
                case 'estimator': content.innerHTML = createEstimatorContent(item.data); break;
                case 'data': content.innerHTML = createDataContent(item.data); break;
                case 'group': {
                    const groupContent = document.createElement('div');
                    groupContent.className = 'group-content';
                    populateGroupContent(groupContent, item);
                    content.appendChild(groupContent);
                    
                    const iconRepresentation = document.createElement('div');
                    iconRepresentation.className = 'group-icon-representation';
                    iconRepresentation.innerHTML = `<div class="group-icon-representation-symbol">${nodeIcons.group}</div>
                                                    <div class="group-icon-representation-title">${item.data.title || 'Untitled'}</div>`;
                    iconRepresentation.addEventListener('dblclick', (e) => { e.stopPropagation(); toggleNode(node); });
                    node.appendChild(iconRepresentation);
                    break;
                }
                case 'knowledge-section': case 'knowledge-subsection': case 'knowledge-item': content.innerHTML = `<textarea class="knowledge-content">${item.data.content || ''}</textarea>`; break;
                case 'adr': content.innerHTML = createADRContent(item.data); break;
            }
            
            node.appendChild(header);
            node.appendChild(content);

            if (!isInline && !isModal) {
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                node.appendChild(resizeHandle);
                resizeHandle.addEventListener('mousedown', (e) => startResize(node, e));
            }
            
            if (!isInline && !isModal) {
                node.addEventListener('click', (e) => selectNode(node, e));
                header.addEventListener('mousedown', (e) => startDrag(node, e));
            }
            title.addEventListener('dblclick', (e) => editTitle(title, item, e));
            
            if (hasExpandableContent(item) && !isInline && !isModal && item.type !== 'group') {
                node.addEventListener('dblclick', (e) => { if (!e.target.classList.contains('node-title')) toggleNode(node); });
            }
            
            if (item.data.isExpanded || (isInline && expandedInlineNodes[item.id]) || isModal) {
                node.classList.add('expanded');
            }
            
            setupInputListeners(node, item);
            
            if (isModal) modalContent.appendChild(node);
            else if (isInline && parentElement) parentElement.appendChild(node);
            else viewport.appendChild(node);
            
            return node;
        }

        function addNode(type, x, y) {
            const id = `item-${workflow.nextItemId++}`;
            const isGroup = type === 'group';
            const defaultData = { title: type.charAt(0).toUpperCase() + type.slice(1).replace('-', ' '), content: '', isExpanded: !isGroup };
            
            if (type === 'task') Object.assign(defaultData, { description: '', complexity: 3, risk: 0.1, priority: 3, duration: 1 });
            else if (type === 'estimator') Object.assign(defaultData, { teamMembers: 5, workingHours: 8, overhead: 0.15, productivity: 0.85, learningCurve: 1.0, hoursPerStoryPoint: 4 });
            else if (type === 'adr') Object.assign(defaultData, { code: '', category: '', topic: '' });
            else if (isGroup) { Object.assign(defaultData, { children: [], isExpanded: true }); groups[id] = []; }
            
            const item = { id, type, x, y, width: 400, height: 300, data: defaultData, parentId: contextMenuPos.groupId || null };
            workflow.items[id] = item;
            
            if (contextMenuPos.groupId) {
                addNodeToGroup(item, contextMenuPos.groupId);
            } else {
                createNode(item);
            }
            
            updateLinks();
            autoSave();
        }

        function deleteNode(nodeId) {
            const node = document.getElementById(nodeId) || document.getElementById(`inline-${nodeId}`);
            if (node) node.remove();
            
            const item = workflow.items[nodeId];
            if (item && item.type === 'group') {
                (groups[nodeId] || item.data.children || []).forEach(childId => deleteNode(childId));
            }
             if (item && item.parentId) {
                const parentItem = workflow.items[item.parentId];
                if (parentItem && parentItem.data.children) {
                    parentItem.data.children = parentItem.data.children.filter(id => id !== nodeId);
                }
                if (groups[item.parentId]) {
                    groups[item.parentId] = groups[item.parentId].filter(id => id !== nodeId);
                }
            }
            
            delete expandedInlineNodes[nodeId];
            delete workflow.items[nodeId];
            
            workflow.links = workflow.links.filter(link => link.sourceId !== nodeId && link.targetId !== nodeId);
            
            updateLinks();
            autoSave();
        }

        /** NEW: Helper to find the closest connection points between two nodes **/
        function getClosestConnectionPoints(sourceItem, targetItem) {
            const sourceNode = document.getElementById(sourceItem.id);
            const targetNode = document.getElementById(targetItem.id);
            if (!sourceNode || !targetNode) return null;

            const isSourceCollapsed = sourceNode.classList.contains('group') && !sourceNode.classList.contains('expanded');
            const isTargetCollapsed = targetNode.classList.contains('group') && !targetNode.classList.contains('expanded');

            const s = {
                x: sourceItem.x,
                y: sourceItem.y,
                w: isSourceCollapsed ? GROUP_COLLAPSED_WIDTH : sourceItem.width,
                h: isSourceCollapsed ? GROUP_COLLAPSED_HEIGHT : sourceItem.height,
            };

            const t = {
                x: targetItem.x,
                y: targetItem.y,
                w: isTargetCollapsed ? GROUP_COLLAPSED_WIDTH : targetItem.width,
                h: isTargetCollapsed ? GROUP_COLLAPSED_HEIGHT : targetItem.height,
            };

            const sourcePoints = [
                { side: 'top',    x: s.x + s.w / 2, y: s.y },
                { side: 'bottom', x: s.x + s.w / 2, y: s.y + s.h },
                { side: 'left',   x: s.x,           y: s.y + s.h / 2 },
                { side: 'right',  x: s.x + s.w,     y: s.y + s.h / 2 },
            ];

            const targetPoints = [
                { side: 'top',    x: t.x + t.w / 2, y: t.y },
                { side: 'bottom', x: t.x + t.w / 2, y: t.y + t.h },
                { side: 'left',   x: t.x,           y: t.y + t.h / 2 },
                { side: 'right',  x: t.x + t.w,     y: t.y + t.h / 2 },
            ];

            let minDistance = Infinity;
            let bestConnection = {};

            for (const sp of sourcePoints) {
                for (const tp of targetPoints) {
                    const distance = Math.hypot(sp.x - tp.x, sp.y - tp.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestConnection = {
                            startPoint: { x: sp.x, y: sp.y },
                            endPoint: { x: tp.x, y: tp.y },
                            fromSide: sp.side,
                            toSide: tp.side,
                        };
                    }
                }
            }
            return bestConnection;
        }

        /** UPGRADED: Link routing uses the closest points now **/
        function updateLinks() {
            while (linksSvg.lastChild && linksSvg.lastChild.tagName !== 'defs') {
                linksSvg.removeChild(linksSvg.lastChild);
            }

            workflow.links.forEach(link => {
                const sourceItem = workflow.items[link.sourceId];
                const targetItem = workflow.items[link.targetId];
                if (!sourceItem || !targetItem) return;

                const connection = getClosestConnectionPoints(sourceItem, targetItem);
                if (!connection) return;

                const { startPoint, endPoint, fromSide } = connection;
                
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const offset = Math.min(100, Math.hypot(dx, dy) * 0.3);

                let cp1 = { ...startPoint };
                let cp2 = { ...endPoint };

                switch(fromSide) {
                    case 'top':    cp1.y -= offset; break;
                    case 'bottom': cp1.y += offset; break;
                    case 'left':   cp1.x -= offset; break;
                    case 'right':  cp1.x += offset; break;
                }
                
                // Adjust cp2 based on where the line is *going to*
                switch(connection.toSide) {
                    case 'top':    cp2.y -= offset; break;
                    case 'bottom': cp2.y += offset; break;
                    case 'left':   cp2.x -= offset; break;
                    case 'right':  cp2.x += offset; break;
                }

                const pathString = `M ${startPoint.x} ${startPoint.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${endPoint.x} ${endPoint.y}`;
                
                const linkGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathString);
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.classList.add('link');

                const clickPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickPath.setAttribute('d', pathString);
                clickPath.classList.add('link-clickable');

                linkGroup.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (confirm('Delete this connection?')) {
                        workflow.links = workflow.links.filter(l => l.id !== link.id);
                        updateLinks();
                        autoSave();
                    }
                });
                
                linkGroup.appendChild(clickPath);
                linkGroup.appendChild(path);
                linksSvg.appendChild(linkGroup);
            });
        }


        // --- Drag, Resize, Link, Select ---

        function startDrag(node, e) {
            if (e.target.classList.contains('node-control') || e.target.classList.contains('resize-handle')) return;
            if (e.altKey) { startLinking(node, e); return; }
            
            isDragging = true;
            const nodeRect = node.getBoundingClientRect();
            dragOffset = { x: e.clientX - nodeRect.left, y: e.clientY - nodeRect.top };
            node.classList.add('dragging');
            selectNode(node, e);
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            e.preventDefault();
        }

        function handleDrag(e) {
            if (!isDragging || !selectedNode) return;
            const canvasRect = canvas.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale - dragOffset.x;
            const y = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale - dragOffset.y;
            
            selectedNode.style.left = Math.max(0, x) + 'px';
            selectedNode.style.top = Math.max(0, y) + 'px';
            
            const item = workflow.items[selectedNode.id];
            if (item) { item.x = Math.max(0, x); item.y = Math.max(0, y); }
            updateLinks();
        }

        function stopDrag() {
            if (!isDragging) return;
            isDragging = false;
            if (selectedNode) selectedNode.classList.remove('dragging');
            autoSave();
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        function startResize(node, e) {
            isResizing = true;
            selectedNode = node;
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
            e.preventDefault();
            e.stopPropagation();
        }

        function handleResize(e) {
            if (!isResizing || !selectedNode) return;
            const nodeRect = selectedNode.getBoundingClientRect();
            const width = Math.max(200, (e.clientX - nodeRect.left) / scale);
            const height = Math.max(100, (e.clientY - nodeRect.top) / scale);
            
            selectedNode.style.width = width + 'px';
            selectedNode.style.height = height + 'px';
            
            const item = workflow.items[selectedNode.id];
            if (item) { 
                item.width = width; 
                item.height = height; 
                if (item.type === 'group') {
                    item.data.expandedWidth = width;
                    item.data.expandedHeight = height;
                }
            }
            updateLinks();
        }

        function stopResize() {
            if (!isResizing) return;
            isResizing = false;
            autoSave();
            document.removeEventListener('mousemove', handleResize);
            document.removeEventListener('mouseup', stopResize);
        }

        function startLinking(node, e) {
            isLinking = true;
            linkSource = node;
            canvas.classList.add('linking');
            
            tempLinkLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLinkLine.classList.add('link');
            tempLinkLine.style.strokeDasharray = '5,5';
            tempLinkLine.style.color = '#1a73e8';
            linksSvg.appendChild(tempLinkLine);
            
            node.classList.add('link-source');
            document.addEventListener('mousemove', handleLinking);
            document.addEventListener('mouseup', stopLinking);
            e.preventDefault();
        }

        function handleLinking(e) {
            if (!isLinking || !linkSource || !tempLinkLine) return;
            const sourceItem = workflow.items[linkSource.id];
            if (!sourceItem) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale;
            const mouseY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale;
            
            const connection = getClosestConnectionPoints(sourceItem, { x: mouseX, y: mouseY, width: 1, height: 1 });
            if (!connection) return;

            const { startPoint } = connection;

            tempLinkLine.setAttribute('d', `M ${startPoint.x} ${startPoint.y} L ${mouseX} ${mouseY}`);
            
            const targetNode = e.target.closest('.node');
            document.querySelectorAll('.node.link-target').forEach(n => n.classList.remove('link-target'));
            if (targetNode && targetNode !== linkSource && !targetNode.classList.contains('inline-node')) {
                targetNode.classList.add('link-target');
            }
        }

        function stopLinking(e) {
            if (!isLinking) return;
            isLinking = false;
            canvas.classList.remove('linking');
            if (tempLinkLine) tempLinkLine.remove();
            
            const targetNode = e.target.closest('.node');
            if (targetNode && targetNode !== linkSource && !targetNode.classList.contains('inline-node')) {
                const sourceId = linkSource.id;
                const targetId = targetNode.id;
                if (!workflow.links.find(l => l.sourceId === sourceId && l.targetId === targetId)) {
                    workflow.links.push({ id: `link-${workflow.nextLinkId++}`, sourceId, targetId });
                    updateLinks();
                    autoSave();
                }
            }
            
            document.querySelectorAll('.link-source, .link-target').forEach(n => n.classList.remove('link-source', 'link-target'));
            linkSource = null;
            document.removeEventListener('mousemove', handleLinking);
            document.removeEventListener('mouseup', stopLinking);
        }

        function startSelection(e) {
            isSelecting = true;
            selectStart = {
                x: e.clientX - canvas.getBoundingClientRect().left + canvas.scrollLeft,
                y: e.clientY - canvas.getBoundingClientRect().top + canvas.scrollTop
            };
            selectionRect.style.left = selectStart.x + 'px';
            selectionRect.style.top = selectStart.y + 'px';
            selectionRect.style.width = '0px';
            selectionRect.style.height = '0px';
            selectionRect.style.display = 'block';
            e.preventDefault();
        }

        function handleSelection(e) {
            if (!isSelecting) return;
            const currentX = e.clientX - canvas.getBoundingClientRect().left + canvas.scrollLeft;
            const currentY = e.clientY - canvas.getBoundingClientRect().top + canvas.scrollTop;

            const x = Math.min(selectStart.x, currentX);
            const y = Math.min(selectStart.y, currentY);
            const width = Math.abs(currentX - selectStart.x);
            const height = Math.abs(currentY - selectStart.y);

            selectionRect.style.left = x + 'px';
            selectionRect.style.top = y + 'px';
            selectionRect.style.width = width + 'px';
            selectionRect.style.height = height + 'px';

            const rectX = (x - translateX) / scale;
            const rectY = (y - translateY) / scale;
            const rectWidth = width / scale;
            const rectHeight = height / scale;

            clearSelection();
            
            Object.values(workflow.items).forEach(item => {
                if (!item.parentId) {
                    const node = document.getElementById(item.id);
                    if (node) {
                        const itemRight = item.x + item.width;
                        const itemBottom = item.y + item.height;
                        if (item.x < rectX + rectWidth && itemRight > rectX && item.y < rectY + rectHeight && itemBottom > rectY) {
                            node.classList.add('selected');
                            selectedNodes.push(node);
                        }
                    }
                }
            });
        }

        function endSelection() {
            isSelecting = false;
            selectionRect.style.display = 'none';
        }

        // --- New Feature Implementations ---

        function groupSelectedNodes() {
            if (selectedNodes.length < 1) return;

            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            selectedNodes.forEach(node => {
                const item = workflow.items[node.id];
                minX = Math.min(minX, item.x);
                minY = Math.min(minY, item.y);
                maxX = Math.max(maxX, item.x + item.width);
                maxY = Math.max(maxY, item.y + item.height);
            });

            const groupId = `item-${workflow.nextItemId++}`;
            const groupWidth = (maxX - minX) + 80;
            const groupHeight = (maxY - minY) + 120;
            const groupItem = {
                id: groupId, type: 'group',
                x: minX - 40, y: minY - 60,
                width: groupWidth, height: groupHeight,
                data: { 
                    title: 'New Group', 
                    isExpanded: true, 
                    children: [],
                    expandedWidth: groupWidth,
                    expandedHeight: groupHeight
                },
                parentId: null
            };
            workflow.items[groupId] = groupItem;
            groups[groupId] = [];

            selectedNodes.forEach(node => {
                const item = workflow.items[node.id];
                item.parentId = groupId;
                groups[groupId].push(item.id);
                node.remove();
            });
            groupItem.data.children = groups[groupId];

            createNode(groupItem);
            clearSelection();
            autoSave();
        }

        function openNodeInModal(itemId) {
            const item = workflow.items[itemId];
            if (!item) return;
            modalContent.innerHTML = '';
            createNode(item, false, null, true);
            modalOverlay.style.display = 'flex';
        }

        function closeModal() {
            modalOverlay.style.display = 'none';
            modalContent.innerHTML = '';
        }
        
        function toggleInlineNode(childId, parentId) {
            const parentNode = document.getElementById(parentId) || document.getElementById(`inline-${parentId}`);
            const parentItem = workflow.items[parentId];
            
            if (!parentNode || !parentItem) {
                console.error("Could not find parent node or item for toggling inline node.", { parentId });
                return;
            }
            
            if (expandedInlineNodes[childId]) {
                delete expandedInlineNodes[childId];
            } else {
                expandedInlineNodes[childId] = true;
            }
            
            const groupContent = parentNode.querySelector('.group-content');
            if (groupContent) {
                populateGroupContent(groupContent, parentItem);
                setupInputListeners(parentNode, parentItem);
                autoSave();
            } else {
                console.error("Could not find content area in parent node.", { parentId });
            }
        }


        // --- Utility & Helper Functions ---

        function clearAll() {
            if (confirm('Clear all nodes and data? This cannot be undone.')) {
                localStorage.removeItem(STORAGE_KEY);
                workflow = { items: {}, links: [], nextItemId: 1, nextLinkId: 1 };
                groups = {};
                expandedInlineNodes = {};
                renderWorkflow();
                resetView();
            }
        }

        function zoom(factor, clientX, clientY) {
            const newScale = Math.min(Math.max(0.2, scale * factor), 3);
            if (newScale === scale) return;

            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = (clientX || canvasRect.left + canvasRect.width / 2) - canvasRect.left;
            const mouseY = (clientY || canvasRect.top + canvasRect.height / 2) - canvasRect.top;
            
            const viewportX = (mouseX - translateX) / scale;
            const viewportY = (mouseY - translateY) / scale;
            
            translateX -= viewportX * (newScale - scale);
            translateY -= viewportY * (newScale - scale);
            scale = newScale;
            
            updateViewportTransform();
        }

        function updateViewportTransform() {
            viewport.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
            zoomIndicator.textContent = Math.round(scale * 100) + '%';
            updateLinks();
            autoSave();
        }

        function clearSelection() {
            if (selectedNode) selectedNode.classList.remove('selected');
            selectedNodes.forEach(n => n.classList.remove('selected'));
            selectedNode = null;
            selectedNodes = [];
        }

        function selectNode(node, e) {
            e.stopPropagation();
            clearSelection();
            selectedNode = node;
            node.classList.add('selected');
        }

        function toggleNode(node) {
            const item = workflow.items[node.id];
            if (!item) return;

            const isCurrentlyExpanded = node.classList.contains('expanded');
            item.data.isExpanded = !isCurrentlyExpanded;
            node.classList.toggle('expanded');

            if (item.type === 'group') {
                if (item.data.isExpanded) {
                    const expandedWidth = item.data.expandedWidth || item.width;
                    const expandedHeight = item.data.expandedHeight || item.height;
                    node.style.width = expandedWidth + 'px';
                    node.style.height = expandedHeight + 'px';
                    item.width = expandedWidth;
                    item.height = expandedHeight;
                } else {
                    if (!item.data.expandedWidth || !item.data.expandedHeight) {
                        item.data.expandedWidth = item.width;
                        item.data.expandedHeight = item.height;
                    }
                    node.style.width = GROUP_COLLAPSED_WIDTH + 'px';
                    node.style.height = GROUP_COLLAPSED_HEIGHT + 'px';
                }
            }

            updateLinks();
            autoSave();
        }
        
        // --- Remaining helper functions ---
        
        function saveToLocalStorage() { try { Object.keys(groups).forEach(gid => { if (workflow.items[gid]) workflow.items[gid].data.children = groups[gid]; }); const state = { workflow, groups, expandedInlineNodes, scale, translateX, translateY, scrollLeft: canvas.scrollLeft, scrollTop: canvas.scrollTop }; localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (error) { console.error('Error saving to localStorage:', error); } }
        function loadFromLocalStorage() { try { const savedState = localStorage.getItem(STORAGE_KEY); if (!savedState) return false; const state = JSON.parse(savedState); workflow = state.workflow || { items: {}, links: [], nextItemId: 1, nextLinkId: 1 }; groups = state.groups || {}; expandedInlineNodes = state.expandedInlineNodes || {}; scale = state.scale || 1; translateX = state.translateX || 0; translateY = state.translateY || 0; renderWorkflow(); updateViewportTransform(); setTimeout(() => { if (state.scrollLeft) canvas.scrollLeft = state.scrollLeft; if (state.scrollTop) canvas.scrollTop = state.scrollTop; }, 50); return true; } catch (error) { console.error('Error loading from localStorage:', error); return false; } }
        let saveTimeout; function autoSave() { clearTimeout(saveTimeout); saveTimeout = setTimeout(saveToLocalStorage, 100); }
        function saveWorkflow() { Object.keys(groups).forEach(gid => { if (workflow.items[gid]) workflow.items[gid].data.children = groups[gid]; }); const state = { items: workflow.items, links: workflow.links, nextItemId: workflow.nextItemId, nextLinkId: workflow.nextLinkId }; const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'workflow.json'; a.click(); URL.revokeObjectURL(url); }
        function handleFileLoad(e) { const file = e.target.files[0]; if (!file) return; loading.style.display = 'block'; const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); workflow = { items: data.items || {}, links: data.links || [], nextItemId: data.nextItemId || 1, nextLinkId: data.nextLinkId || 1 }; groups = {}; expandedInlineNodes = {}; Object.values(workflow.items).forEach(item => { if (item.type === 'group' && item.data.children) groups[item.id] = item.data.children; }); renderWorkflow(); loading.style.display = 'none'; updateViewportTransform(); fitToScreen(); autoSave(); } catch (error) { alert('Error loading workflow: ' + error.message); loading.style.display = 'none'; } }; reader.readAsText(file); }
        function renderWorkflow() { viewport.querySelectorAll('.node').forEach(node => node.remove()); Object.values(workflow.items).forEach(item => { if (!item.parentId) createNode(item); }); updateLinks(); }
        function createTaskContent(data) { return `${data.description ? `<div class="task-description">${data.description}</div>` : ''}<div class="task-content"><label><span>Complexity (SP):</span><select class="complexity">${[1,2,3,5,8,13,21,34,55,89].map(n => `<option value="${n}" ${data.complexity == n ? 'selected' : ''}>${n}</option>`).join('')}</select></label><label><span>Risk Factor:</span><input type="number" class="risk" value="${data.risk || 0.1}" min="0" max="1" step="0.05"></label><label><span>Priority:</span><input type="number" class="priority" value="${data.priority || 3}" min="1" max="5"></label><label><span>Duration (days):</span><input type="number" class="duration" value="${data.duration || 1}" min="0.5" step="0.5"></label></div>`; }
        function createEstimatorContent(data) { return `<div class="estimator-content"><h4>Team & Project Factors</h4><label><span>Team Members:</span><input type="number" class="team-members" value="${data.teamMembers || 5}" min="1"></label><label><span>Hours/Day/Member:</span><input type="number" class="working-hours" value="${data.workingHours || 8}" min="1" step="0.5"></label><label><span>Overhead Factor:</span><input type="number" class="overhead" value="${data.overhead || 0.15}" min="0" max="0.99" step="0.01"></label><label><span>Productivity:</span><input type="number" class="productivity" value="${data.productivity || 0.85}" min="0.1" max="1.5" step="0.01"></label><label><span>Maturity/Learn:</span><input type="number" class="learning-curve" value="${data.learningCurve || 1.0}" min="0.5" step="0.05"></label><label><span>Hours per SP:</span><input type="number" class="hours-per-sp" value="${data.hoursPerStoryPoint || 4}" min="0.5" step="0.1"></label><div class="estimator-result"><p>Total Base SP: <strong class="base-sp">0</strong></p><p>Total Adjusted SP: <strong class="adj-sp">0</strong></p><p>Team Velocity: <strong class="velocity">0</strong></p><p>Est. Duration: <strong class="duration">N/A</strong></p></div></div>`; }
        function createDataContent(data) { return data.dataType === 'image' ? `<img class="data-image" src="${data.content}" alt="Pasted image">` : `<textarea class="data-text">${data.content || ''}</textarea>`; }
        function populateGroupContent(groupContentElement, groupItem) { groupContentElement.innerHTML = ''; const children = groups[groupItem.id] || groupItem.data.children || []; children.forEach(childId => { const childItem = workflow.items[childId]; if (!childItem) return; if (expandedInlineNodes[childId]) { createNode(childItem, true, groupContentElement); } else { const childIcon = document.createElement('div'); childIcon.className = 'group-child-icon'; childIcon.dataset.childId = childId; childIcon.innerHTML = `<div class="group-child-icon-symbol">${nodeIcons[childItem.type] || 'üìÑ'}</div><div class="group-child-icon-title">${childItem.data.title || 'Untitled'}</div>`; childIcon.addEventListener('click', (e) => { if (e.ctrlKey || e.metaKey) { e.stopPropagation(); openNodeInModal(childId); } }); childIcon.addEventListener('dblclick', (e) => { e.stopPropagation(); toggleInlineNode(childId, groupItem.id); }); groupContentElement.appendChild(childIcon); } }); }
        function createADRContent(data) { return `<div class="adr-content"><label><span>Code:</span><input type="text" class="adr-code" value="${data.code || ''}"></label><label><span>Category:</span><input type="text" class="adr-category" value="${data.category || ''}"></label><label><span>Topic:</span><textarea class="adr-topic">${data.topic || ''}</textarea></label></div>`; }
        function autoLayout() { const rootNodes = Object.values(workflow.items).filter(item => !item.parentId); if (rootNodes.length === 0) return; const hierarchy = buildHierarchy(rootNodes); const nodeSpacingX = 350, nodeSpacingY = 250, startX = 100, startY = 100; layoutHierarchy(hierarchy, startX, startY, nodeSpacingX, nodeSpacingY); Object.values(workflow.items).forEach(item => { const node = document.getElementById(item.id); if (node && !node.classList.contains('inline-node')) { node.style.left = item.x + 'px'; node.style.top = item.y + 'px'; } }); updateLinks(); autoSave(); }
        function buildHierarchy(nodes) { const hierarchy = []; nodes.forEach(node => { const hierNode = { item: node, children: [] }; const childLinks = workflow.links.filter(link => link.sourceId === node.id); childLinks.forEach(link => { const childItem = workflow.items[link.targetId]; if (childItem) hierNode.children.push(...buildHierarchy([childItem])); }); hierarchy.push(hierNode); }); return hierarchy; }
        function layoutHierarchy(hierarchy, startX, startY, spacingX, spacingY) { let currentX = startX; hierarchy.forEach((node, index) => { const subtreeWidth = calculateSubtreeWidth(node, spacingX); const centerX = currentX + subtreeWidth / 2; node.item.x = centerX - node.item.width / 2; node.item.y = startY; if (node.children.length > 0) layoutHierarchy(node.children, currentX, startY + spacingY, spacingX, spacingY); currentX += subtreeWidth + spacingX; }); }
        function calculateSubtreeWidth(node, spacing) { if (node.children.length === 0) return node.item.width; let totalWidth = 0; node.children.forEach((child, index) => { totalWidth += calculateSubtreeWidth(child, spacing); if (index < node.children.length - 1) totalWidth += spacing; }); return Math.max(node.item.width, totalWidth); }
        function editTitle(titleEl, item, e) { e.stopPropagation(); const oldTitle = titleEl.textContent; titleEl.contentEditable = true; titleEl.focus(); const range = document.createRange(); range.selectNodeContents(titleEl); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); const save = () => { titleEl.contentEditable = false; const newTitle = titleEl.textContent.trim(); if (newTitle) { item.data.title = newTitle; autoSave(); const node = document.getElementById(item.id); if (node && item.type === 'group') { const iconTitle = node.querySelector('.group-icon-representation-title'); if (iconTitle) iconTitle.textContent = newTitle; } } else { titleEl.textContent = oldTitle; } }; titleEl.addEventListener('blur', save, { once: true }); titleEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); save(); } else if (e.key === 'Escape') { titleEl.textContent = oldTitle; save(); } }); }
        function handleMenuClick(e) { const menuItem = e.target.closest('.menu-item'); if (!menuItem) return; const action = menuItem.dataset.action; contextMenu.style.display = 'none'; if (action === 'paste') { navigator.clipboard.readText().then(text => { if (text) { const id = `item-${workflow.nextItemId++}`; const pasteItem = { id, type: 'data', x: contextMenuPos.x, y: contextMenuPos.y, width: 300, height: 200, data: { title: 'Pasted Text', dataType: 'text', content: text }, parentId: contextMenuPos.groupId || null }; workflow.items[id] = pasteItem; if(contextMenuPos.groupId) { addNodeToGroup(pasteItem, contextMenuPos.groupId); } else { createNode(pasteItem); } autoSave(); } }).catch(err => console.log('Paste from context menu requires clipboard permissions')); contextMenuPos.groupId = null; return; } let type = null; switch (action) { case 'add-scribble': type = 'scribble'; break; case 'add-task': type = 'task'; break; case 'add-group': type = 'group'; break; case 'add-estimator': type = 'estimator'; break; case 'add-knowledge-section': type = 'knowledge-section'; break; case 'add-knowledge-subsection': type = 'knowledge-subsection'; break; case 'add-knowledge-item': type = 'knowledge-item'; break; case 'add-adr': type = 'adr'; break; } if (type) addNode(type, contextMenuPos.x, contextMenuPos.y); contextMenuPos.groupId = null; }
        function setupInputListeners(node, item) { const inputs = node.querySelectorAll('input, select, textarea'); inputs.forEach(input => { input.addEventListener('change', () => { updateItemData(item); if (item.type === 'estimator') calculateEstimates(); autoSave(); }); input.addEventListener('mousedown', e => e.stopPropagation()); }); }
        function updateItemData(item) { const node = document.getElementById(item.id) || document.getElementById(`inline-${item.id}`) || document.getElementById(`modal-${item.id}`); if (!node) return; switch (item.type) { case 'scribble': item.data.content = node.querySelector('.scribble-content')?.value; break; case 'task': item.data.complexity = node.querySelector('.complexity')?.value; item.data.risk = node.querySelector('.risk')?.value; item.data.priority = node.querySelector('.priority')?.value; item.data.duration = node.querySelector('.duration')?.value; break; case 'estimator': item.data.teamMembers = node.querySelector('.team-members')?.value; item.data.workingHours = node.querySelector('.working-hours')?.value; item.data.overhead = node.querySelector('.overhead')?.value; item.data.productivity = node.querySelector('.productivity')?.value; item.data.learningCurve = node.querySelector('.learning-curve')?.value; item.data.hoursPerStoryPoint = node.querySelector('.hours-per-sp')?.value; break; case 'data': if (node.querySelector('.data-text')) item.data.content = node.querySelector('.data-text').value; break; case 'knowledge-section': case 'knowledge-subsection': case 'knowledge-item': item.data.content = node.querySelector('.knowledge-content')?.value; break; case 'adr': item.data.code = node.querySelector('.adr-code')?.value; item.data.category = node.querySelector('.adr-category')?.value; item.data.topic = node.querySelector('.adr-topic')?.value; break; } }
        function calculateEstimates() { const estimator = Object.values(workflow.items).find(item => item.type === 'estimator'); if (!estimator) return; const estimatorNode = document.getElementById(estimator.id); if (!estimatorNode) return; let totalBaseSP = 0, totalAdjustedSP = 0; Object.values(workflow.items).filter(item => item.type === 'task' && (document.getElementById(item.id) || item.parentId)).forEach(task => { const complexity = parseFloat(task.data.complexity) || 0; const risk = parseFloat(task.data.risk) || 0; const duration = parseFloat(task.data.duration) || 0; totalBaseSP += complexity; const adjustedSP = complexity * (1 + risk) * (1 + 0.1 * Math.log(1 + Math.max(0, duration))); totalAdjustedSP += adjustedSP + (adjustedSP * (0.15 + 0.20 * risk)); }); const R = parseInt(estimator.data.teamMembers) || 0, D = parseFloat(estimator.data.workingHours) || 0, O = parseFloat(estimator.data.overhead) || 0, P = parseFloat(estimator.data.productivity) || 0, L = parseFloat(estimator.data.learningCurve) || 0, H = parseFloat(estimator.data.hoursPerStoryPoint) || 0; const effectiveHoursPerDay = R * D * (1 - O) * P * L; let teamVelocity = 0, estDuration = 'N/A'; if (H > 0 && effectiveHoursPerDay > 0) { teamVelocity = effectiveHoursPerDay / H; if (totalAdjustedSP > 0 && teamVelocity > 0) estDuration = (totalAdjustedSP / teamVelocity).toFixed(1); } estimatorNode.querySelector('.base-sp').textContent = totalBaseSP.toFixed(2); estimatorNode.querySelector('.adj-sp').textContent = totalAdjustedSP.toFixed(2); estimatorNode.querySelector('.velocity').textContent = teamVelocity.toFixed(2); estimatorNode.querySelector('.duration').textContent = estDuration; }
        function addNodeToGroup(item, groupId) { if (!groups[groupId]) groups[groupId] = []; groups[groupId].push(item.id); const parentItem = workflow.items[groupId]; if (parentItem) parentItem.data.children = groups[groupId]; const groupNode = document.getElementById(groupId) || document.getElementById(`inline-${groupId}`); if (groupNode) { const groupContent = groupNode.querySelector('.group-content'); if (groupContent) { populateGroupContent(groupContent, parentItem); setupInputListeners(groupNode, parentItem); } } }
        function handlePaste(e) { const activeElement = document.activeElement; if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') return; const items = e.clipboardData.items; for (let item of items) { if (item.type.indexOf('image') !== -1) { e.preventDefault(); const blob = item.getAsFile(); const reader = new FileReader(); reader.onload = (event) => { const id = `item-${workflow.nextItemId++}`; const canvasRect = canvas.getBoundingClientRect(); const defaultX = (canvasRect.width / 2 + canvas.scrollLeft - translateX) / scale; const defaultY = (canvasRect.height / 2 + canvas.scrollTop - translateY) / scale; const pasteItem = { id, type: 'data', x: contextMenuPos.x || defaultX, y: contextMenuPos.y || defaultY, width: 300, height: 200, data: { title: 'Pasted Image', dataType: 'image', content: event.target.result }, parentId: contextMenuPos.groupId || null }; workflow.items[id] = pasteItem; if (contextMenuPos.groupId) { addNodeToGroup(pasteItem, contextMenuPos.groupId); } else { createNode(pasteItem); } autoSave(); }; reader.readAsDataURL(blob); return; } } }
        function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; }
        function handleDrop(e) { e.preventDefault(); const files = e.dataTransfer.files; const canvasRect = canvas.getBoundingClientRect(); const dropX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale; const dropY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale; Array.from(files).forEach((file, index) => { if (file.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (event) => { const id = `item-${workflow.nextItemId++}`; const item = { id, type: 'data', x: dropX + (index * 20), y: dropY + (index * 20), width: 300, height: 200, data: { title: file.name, dataType: 'image', content: event.target.result }, parentId: null }; workflow.items[id] = item; createNode(item); autoSave(); }; reader.readAsDataURL(file); } else if (file.type.startsWith('text/') || file.name.endsWith('.txt') || file.name.endsWith('.md')) { const reader = new FileReader(); reader.onload = (event) => { const id = `item-${workflow.nextItemId++}`; const item = { id, type: 'scribble', x: dropX + (index * 20), y: dropY + (index * 20), width: 400, height: 300, data: { title: file.name, content: event.target.result, isExpanded: true }, parentId: null }; workflow.items[id] = item; createNode(item); autoSave(); }; reader.readAsText(file); } }); }
        function fitToScreen() { if (Object.keys(workflow.items).length === 0) return; let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0; let hasVisibleNodes = false; Object.values(workflow.items).forEach(item => { if (!item.parentId) { hasVisibleNodes = true; minX = Math.min(minX, item.x); minY = Math.min(minY, item.y); maxX = Math.max(maxX, item.x + item.width); maxY = Math.max(maxY, item.y + item.height); } }); if (!hasVisibleNodes) { resetView(); return; }; const padding = 50; const contentWidth = maxX - minX; const contentHeight = maxY - minY; const canvasWidth = canvas.clientWidth; const canvasHeight = canvas.clientHeight; const scaleX = canvasWidth / (contentWidth + padding * 2); const scaleY = canvasHeight / (contentHeight + padding * 2); scale = Math.min(scaleX, scaleY, 1); translateX = -minX * scale + (canvasWidth - contentWidth * scale) / 2; translateY = -minY * scale + (canvasHeight - contentHeight * scale) / 2; updateViewportTransform(); }
        function resetView() { scale = 1; translateX = 0; translateY = 0; updateViewportTransform(); fitToScreen(); }
        function hasExpandableContent(item) { return item.type === 'scribble' || item.type === 'group' || item.type === 'task' || item.type === 'estimator' || item.type === 'adr' || item.type.startsWith('knowledge-') || item.type === 'data'; }

        // Start the application
        initialize();
    </script>
</body>
</html>
