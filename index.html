<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Node-Based Dashboard</title>
    <script src="[https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js](https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js)"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
            background-color: #f0f0f0;
        }

        /* --- Topbar --- */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #333;
            color: white;
            padding: 10px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #topbar h1 {
            margin: 0;
            font-size: 1.4em;
            font-weight: 400;
        }
        #topbar .topbar-buttons button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 10px;
            transition: background-color 0.2s;
        }
        #topbar .topbar-buttons button:hover {
            background-color: #0056b3;
        }
        #file-loader {
            display: none;
        }

        #canvas {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #e8e8e8;
            background-image: linear-gradient(rgba(0, 0, 0, 0.04) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 0, 0, 0.04) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            cursor: default;
            padding-top: 55px; /* Adjust for topbar height */
            box-sizing: border-box;
        }

        /* --- Tiles --- */
        .tile {
            position: absolute;
            background-color: #ffffe0; /* Light yellow sticky note */
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            border-radius: 3px;
            min-width: 250px;
            min-height: 150px;
            z-index: 10;
            transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tile.selected {
            box-shadow: 0 0 10px 4px #007bff;
            z-index: 11;
            border-color: #007bff;
        }

        .tile.dragging {
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
            opacity: 0.9;
        }

        .tile .tile-header {
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: grab;
            flex-shrink: 0;
            position: relative;
            padding-left: 10px;
            padding-right: 10px;
            padding-top: 5px;
            margin: -15px -15px 10px -15px;
        }

        .tile .tile-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(211, 211, 211, 0.3);
            z-index: -1;
            border-radius: 3px 3px 0 0;
            border-bottom: 1px solid #eee;
        }

        .tile .tile-header h3 {
            margin: 0;
            font-size: 1.1em;
            color: #333;
            flex-grow: 1;
            margin-right: 10px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: default;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .tile .tile-header h3[contenteditable="true"] {
            background-color: rgba(0, 123, 255, 0.1);
            outline: 1px solid rgba(0, 123, 255, 0.5);
            cursor: text;
            user-select: text;
        }

        .tile .tile-header .change-type-btn {
            font-size: 1.1em; cursor: pointer; color: #bbb; padding: 0 3px;
            margin-right: 5px; line-height: 1; z-index: 1; font-family: sans-serif;
            display: inline-block; vertical-align: middle;
        }
        .tile .tile-header .change-type-btn:hover { color: #555; }
        .tile.estimator .change-type-btn, .tile.group .change-type-btn {
            opacity: 0.4; cursor: not-allowed;
        }

        .tile .tile-header .delete-btn {
            font-size: 1.2em; cursor: pointer; color: #aaa; padding: 0 5px;
            line-height: 1; z-index: 1;
        }
        .tile .tile-header .delete-btn:hover { color: #dc3545; }

        .tile .tile-content {
            flex-grow: 1; overflow-y: auto; overflow-x: hidden;
            user-select: text; -webkit-user-select: text;
            cursor: default;
        }

        .tile label {
            display: flex; align-items: center; margin-top: 8px;
            font-size: 0.9em; cursor: default;
        }

        .tile label span {
            width: 110px; margin-right: 5px; color: #555;
            white-space: nowrap; flex-shrink: 0;
        }

        .tile input[type="number"], .tile select, .tile input[type="text"], .tile textarea {
            flex: 1; padding: 5px; border: 1px solid #ddd; border-radius: 3px;
            font-size: 0.9em; user-select: text; cursor: auto;
            width: auto; box-sizing: border-box;
        }
        .tile textarea { resize: none; min-height: 50px; font-family: inherit; flex-grow: 1; }

        .tile.scribble .scribble-text {
            width: 100%; height: 100%; box-sizing: border-box; border: none; outline: none; resize: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 0.95em;
            line-height: 1.4; background-color: transparent; padding: 5px; user-select: text; cursor: auto;
        }

        /* --- Group Tile Specifics --- */
        .tile.group {
            background-color: #e0e8ff; /* Light blue */
            border-color: #a0b0e0;
            transition: all 0.3s ease-in-out;
        }
        .tile.group .tile-header::before {
            background-color: rgba(160, 176, 224, 0.4);
        }
        .tile.group .group-content {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #445a8a;
        }
        .tile.group.expanded {
            background-color: rgba(200, 210, 240, 0.5);
            border: 2px dashed #a0b0e0;
            padding: 0;
            z-index: 8; /* Below normal tiles */
        }
        .tile.group.expanded .tile-header {
            background-color: rgba(160, 176, 224, 0.6);
            cursor: pointer;
            margin: 0;
            padding: 10px;
            border-bottom: 2px dashed #a0b0e0;
            border-radius: 3px 3px 0 0;
        }
        .tile.group.expanded .tile-header::before { display: none; }
        .tile.group.expanded .tile-content { display: none; }
        .tile.group.expanded .resizer, .tile.group.expanded .delete-btn {
            display: none;
        }
        .tile.hidden-child {
            display: none !important;
        }


        .resizer {
            position: absolute; width: 15px; height: 15px;
            background: rgba(0, 123, 255, 0.3); border: 1px solid rgba(0, 123, 255, 0.6);
            bottom: -1px; right: -1px; cursor: nwse-resize;
            z-index: 12; border-radius: 0 0 3px 0;
        }

        /* --- Context Menu --- */
        #context-menu {
            position: absolute; background-color: #fff; border: 1px solid #ccc;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15); padding: 5px 0; min-width: 150px;
            z-index: 100; display: none; border-radius: 4px;
        }
        #context-menu ul { list-style: none; margin: 0; padding: 0; }
        #context-menu ul li { padding: 8px 15px; cursor: pointer; font-size: 0.95em; position: relative; white-space: nowrap; }
        #context-menu ul li:hover { background-color: #f0f0f0; }
        #context-menu ul li.disabled { color: #aaa; cursor: not-allowed; background-color: #fff; }
        #context-menu .separator { height: 1px; background-color: #eee; margin: 5px 0; }

        /* SVG Arrows */
        #arrow-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; overflow: visible; }
        .arrow { stroke: #5a5a5a; stroke-width: 1.5; fill: none; marker-end: url(#arrowhead); }
    </style>
</head>
<body>

<div id="topbar">
    <h1>Node-Based Dashboard</h1>
    <div class="topbar-buttons">
        <button id="save-btn">Save Workflow</button>
        <button id="load-btn">Load Workflow</button>
        <input type="file" id="file-loader" accept=".json, .txt">
    </div>
</div>

<div id="canvas">
    <svg id="arrow-layer">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L10,3.5 L0,7 Z" fill="#5a5a5a" />
            </marker>
        </defs>
    </svg>
</div>

<div id="context-menu">
    <ul>
        <li id="add-scribble-pad">Add Scribble Note</li>
        <li class="separator"></li>
        <li id="group-selection">Group Selection</li>
    </ul>
</div>

<template id="scribble-template">
    <div class="tile scribble" id="">
        <div class="tile-header">
            <h3 class="tile-title" contenteditable="false">Scribble Pad</h3>
            <span class="delete-btn" title="Delete">×</span>
        </div>
        <div class="tile-content">
            <textarea class="scribble-text" placeholder="Start typing..."></textarea>
        </div>
        <div class="resizer"></div>
    </div>
</template>

<template id="group-template">
    <div class="tile group" id="">
        <div class="tile-header">
            <h3 class="tile-title" contenteditable="false">New Group</h3>
            <span class="delete-btn" title="Delete Group">×</span>
        </div>
        <div class="tile-content group-content">
            <p>This is a group. Double-click to expand.</p>
        </div>
        <div class="resizer"></div>
    </div>
</template>


<script>
    // --- Element Cache ---
    const canvas = document.getElementById('canvas');
    const contextMenu = document.getElementById('context-menu');
    const scribbleTemplate = document.getElementById('scribble-template');
    const groupTemplate = document.getElementById('group-template');
    const svgLayer = document.getElementById('arrow-layer');
    const fileLoader = document.getElementById('file-loader');

    // --- State Variables ---
    let items = {};
    let links = [];
    let selectedItemIds = [];
    let nextItemId = 1;
    let nextLinkId = 1;
    let currentPasteCoords = { x: 100, y: 100 };
    
    // --- Constants ---
    const DEFAULT_TILE_WIDTH = 300;
    const DEFAULT_TILE_HEIGHT = 200;

    // --- Initialization ---
    function initialize() {
        setupCanvasListeners();
        setupGlobalListeners();
        setupContextMenuListeners();
        setupTopbarListeners();
        loadState();
    }

    // --- UI & Event Listeners ---
    function setupCanvasListeners() {
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const groupOption = document.getElementById('group-selection');
            groupOption.classList.toggle('disabled', selectedItemIds.length <= 1);
            showContextMenu(e);
            if (!e.target.closest('.tile')) {
                deselectAllItems();
            }
        });
        canvas.addEventListener('click', (e) => {
            if (!e.target.closest('.tile') && !e.target.closest('#context-menu')) {
                 if (!e.shiftKey) deselectAllItems();
                 hideContextMenu();
            }
        });
    }

    function setupGlobalListeners() {
        document.addEventListener('keydown', (e) => {
            const isEditing = document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable;
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItemIds.length > 0 && !isEditing) {
                e.preventDefault();
                if (confirm(`Delete ${selectedItemIds.length} selected item(s)?`)) {
                    [...selectedItemIds].forEach(id => deleteItem(id));
                }
            }
        });
        document.addEventListener('click', (e) => {
             if (!contextMenu.contains(e.target)) hideContextMenu();
        }, true);
    }

    function setupContextMenuListeners() {
        document.getElementById('add-scribble-pad').addEventListener('click', (e) => {
            e.stopPropagation();
            const coords = { pageX: contextMenu.dataset.pageX, pageY: contextMenu.dataset.pageY };
            createAndAddItem('scribble', coords);
            hideContextMenu();
        });
        document.getElementById('group-selection').addEventListener('click', (e) => {
            e.stopPropagation();
            if (selectedItemIds.length > 1) createGroupFromSelection();
            hideContextMenu();
        });
    }

    function setupTopbarListeners() {
        document.getElementById('save-btn').addEventListener('click', handleSave);
        document.getElementById('load-btn').addEventListener('click', () => fileLoader.click());
        fileLoader.addEventListener('change', handleLoad);
    }

    function showContextMenu(e) {
        const { clientX, clientY, pageX, pageY } = e;
        contextMenu.style.left = `${clientX}px`;
        contextMenu.style.top = `${clientY}px`;
        contextMenu.style.display = 'block';
        contextMenu.dataset.pageX = pageX;
        contextMenu.dataset.pageY = pageY;
    }

    function hideContextMenu() { contextMenu.style.display = 'none'; }

    // --- Item Management ---
    function createAndAddItem(type, coords, presetData = null) {
        const newItemId = `item-${nextItemId++}`;
        const template = type === 'group' ? groupTemplate : scribbleTemplate;
        const node = template.content.cloneNode(true);
        const element = node.querySelector('.tile');
        element.id = newItemId;

        const spawnX = parseInt(coords?.pageX || coords?.x || currentPasteCoords.x, 10);
        const spawnY = parseInt(coords?.pageY || coords?.y || currentPasteCoords.y, 10);
        element.style.left = `${spawnX}px`;
        element.style.top = `${spawnY}px`;
        
        const itemData = { title: presetData?.title || (type === 'group' ? 'New Group' : 'Scribble Pad') };
        if (type === 'scribble') itemData.content = presetData?.content || '';
        if (type === 'group') {
            itemData.children = presetData?.children || [];
            itemData.isExpanded = false;
        }

        element.querySelector('.tile-title').textContent = itemData.title;

        element.style.width = `${presetData?.width || DEFAULT_TILE_WIDTH}px`;
        element.style.height = `${presetData?.height || DEFAULT_TILE_HEIGHT}px`;

        canvas.appendChild(element);
        items[newItemId] = {
            id: newItemId, type, x: spawnX, y: spawnY,
            width: parseInt(element.style.width),
            height: parseInt(element.style.height),
            data: itemData, element,
            parentId: presetData?.parentId || null
        };

        setupTileInteraction(element);
        if (!presetData) {
            deselectAllItems();
            selectItem(newItemId);
            saveState();
        }
        return newItemId;
    }

    function deleteItem(itemId) {
        if (!items[itemId]) return;
        const itemToDelete = items[itemId];

        if (itemToDelete.type === 'group') {
            itemToDelete.data.children.forEach(childId => {
                if(items[childId]) {
                    items[childId].parentId = null;
                    items[childId].element.classList.remove('hidden-child');
                }
            });
        }
        
        links = links.filter(link => {
            if (link.sourceId === itemId || link.targetId === itemId) return false;
            return true;
        });

        itemToDelete.element.remove();
        delete items[itemId];
        
        selectedItemIds = selectedItemIds.filter(id => id !== itemId);
        
        updateArrows();
        saveState();
    }
    
    function setupTileInteraction(tileElement) {
        const itemId = tileElement.id;
        const headerElement = tileElement.querySelector('.tile-header');
        
        interact(tileElement).draggable({
            allowFrom: headerElement,
            listeners: {
                start(event) {
                    if (!selectedItemIds.includes(itemId)) {
                        selectItem(itemId, event.shiftKey);
                    }
                    bringToFront(itemId);
                },
                move(event) {
                    const movedItems = new Set();
                    selectedItemIds.forEach(selectedId => {
                        if (movedItems.has(selectedId)) return;
                        const targetItem = items[selectedId];
                        if (!targetItem) return;

                        const dx = event.dx;
                        const dy = event.dy;
                        
                        targetItem.x += dx;
                        targetItem.y += dy;
                        targetItem.element.style.left = `${targetItem.x}px`;
                        targetItem.element.style.top = `${targetItem.y}px`;
                        movedItems.add(selectedId);

                        if (targetItem.type === 'group') {
                            targetItem.data.children.forEach(childId => {
                                const childItem = items[childId];
                                if(childItem && !selectedItemIds.includes(childId)) {
                                    childItem.x += dx;
                                    childItem.y += dy;
                                    childItem.element.style.left = `${childItem.x}px`;
                                    childItem.element.style.top = `${childItem.y}px`;
                                    movedItems.add(childId);
                                }
                            });
                        }
                    });
                    updateArrows();
                },
                end: () => saveState()
            }
        });

        interact(tileElement).resizable({
             edges: { right: true, bottom: true }, allowFrom: '.resizer',
             listeners: {
                 move: (event) => {
                     const item = items[itemId];
                     if (!item) return;
                     item.width = event.rect.width;
                     item.height = event.rect.height;
                     event.target.style.width = `${item.width}px`;
                     event.target.style.height = `${item.height}px`;
                     updateArrows();
                 },
                 end: () => saveState()
             },
             modifiers: [interact.modifiers.restrictSize({ min: { width: 200, height: 100 } })]
        });

        tileElement.addEventListener('click', (e) => {
            if (e.target.closest('.resizer') || e.target.closest('.delete-btn') || e.target.tagName === 'TEXTAREA') return;
            selectItem(itemId, e.shiftKey);
            e.stopPropagation();
        });

        tileElement.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            if (items[itemId]?.type === 'group') toggleGroupExpansion(itemId);
            else if (e.target.classList.contains('tile-title')) makeTitleEditable(e.target, itemId);
        });

        tileElement.querySelector('.delete-btn')?.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm(`Delete this item?`)) deleteItem(itemId);
        });

        tileElement.querySelector('.scribble-text')?.addEventListener('change', (e) => {
            items[itemId].data.content = e.target.value;
            saveState();
        });
    }

    function makeTitleEditable(titleElement, itemId) {
        titleElement.setAttribute('contenteditable', 'true');
        titleElement.focus();
        document.execCommand('selectAll', false, null);
        const onBlur = () => {
            titleElement.setAttribute('contenteditable', 'false');
            items[itemId].data.title = titleElement.textContent;
            saveState();
            titleElement.removeEventListener('blur', onBlur);
            titleElement.removeEventListener('keydown', onKeydown);
        };
        const onKeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                titleElement.blur();
            }
        };
        titleElement.addEventListener('blur', onBlur);
        titleElement.addEventListener('keydown', onKeydown);
    }
    
    function bringToFront(itemId) {
        const element = items[itemId]?.element;
        if (!element) return;
        const maxZ = Math.max(10, ...Object.values(items).map(i => parseInt(i.element.style.zIndex || '10', 10)));
        element.style.zIndex = maxZ + 1;
    }

    function selectItem(itemId, isMultiSelect = false) {
        if (!isMultiSelect) deselectAllItems();

        const index = selectedItemIds.indexOf(itemId);
        const element = items[itemId]?.element;
        if (!element) return;

        if (index > -1) {
            if (isMultiSelect) {
                element.classList.remove('selected');
                selectedItemIds.splice(index, 1);
            }
        } else {
            element.classList.add('selected');
            selectedItemIds.push(itemId);
            bringToFront(itemId);
        }
    }

    function deselectAllItems() {
        selectedItemIds.forEach(id => items[id]?.element.classList.remove('selected'));
        selectedItemIds = [];
    }
    
    function createGroupFromSelection() {
        const groupPreset = {
            title: "New Group",
            children: [...selectedItemIds],
        };

        const groupId = createAndAddItem('group', { pageX: items[selectedItemIds[0]].x - 50, pageY: items[selectedItemIds[0]].y - 50 }, groupPreset);

        selectedItemIds.forEach(childId => {
            if (items[childId]) {
                items[childId].parentId = groupId;
                items[childId].element.classList.add('hidden-child');
            }
        });
        
        deselectAllItems();
        selectItem(groupId);
        updateArrows();
        saveState();
    }

    function toggleGroupExpansion(groupId) {
        const group = items[groupId];
        if (!group) return;

        group.data.isExpanded = !group.data.isExpanded;
        const groupElement = group.element;
        groupElement.classList.toggle('expanded', group.data.isExpanded);

        if (group.data.isExpanded) {
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            let hasChildren = false;
            group.data.children.forEach(childId => {
                const child = items[childId];
                if (child) {
                    hasChildren = true;
                    child.element.classList.remove('hidden-child');
                    minX = Math.min(minX, child.x);
                    minY = Math.min(minY, child.y);
                    maxX = Math.max(maxX, child.x + child.width);
                    maxY = Math.max(maxY, child.y + child.height);
                }
            });
            
            if (hasChildren) {
                group.width = maxX - minX + 80;
                group.height = maxY - minY + 80;
                group.x = minX - 40;
                group.y = minY - 40;
            }
            groupElement.style.width = `${group.width}px`;
            groupElement.style.height = `${group.height}px`;
            groupElement.style.left = `${group.x}px`;
            groupElement.style.top = `${group.y}px`;
        } else {
            group.data.children.forEach(childId => items[childId]?.element.classList.add('hidden-child'));
            group.width = DEFAULT_TILE_WIDTH;
            group.height = DEFAULT_TILE_HEIGHT;
            groupElement.style.width = `${group.width}px`;
            groupElement.style.height = `${group.height}px`;
        }
        
        updateArrows();
        saveState();
    }

    function updateArrows() {
        svgLayer.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L10,3.5 L0,7 Z" fill="#5a5a5a" /></marker></defs>`;
        const canvasRect = canvas.getBoundingClientRect();
        links.forEach(link => {
            let sourceItem = items[link.sourceId];
            let targetItem = items[link.targetId];
            if (!sourceItem || !targetItem) return;

            if (sourceItem.parentId && !items[sourceItem.parentId]?.data.isExpanded) sourceItem = items[sourceItem.parentId];
            if (targetItem.parentId && !items[targetItem.parentId]?.data.isExpanded) targetItem = items[targetItem.parentId];
            if (sourceItem === targetItem) return;

            const sourceCenter = getElementCenter(sourceItem.element, canvasRect);
            const targetCenter = getElementCenter(targetItem.element, canvasRect);
            const dx = targetCenter.x - sourceCenter.x, dy = targetCenter.y - sourceCenter.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 1) return;

            const startPoint = getEdgePoint(sourceItem.element.getBoundingClientRect(), dx, dy, canvasRect);
            const endPoint = getEdgePoint(targetItem.element.getBoundingClientRect(), -dx, -dy, canvasRect);
            
            const nx = dx / len, ny = dy / len;
            const lineEndX = endPoint.x - nx * 15, lineEndY = endPoint.y - ny * 15;

            const path = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'path');
            path.setAttribute('d', `M ${startPoint.x},${startPoint.y} L ${lineEndX},${lineEndY}`);
            path.setAttribute('class', 'arrow');
            svgLayer.appendChild(path);
        });
    }

    function getElementCenter(element, canvasRect) {
        const rect = element.getBoundingClientRect();
        return { x: rect.left - canvasRect.left + rect.width / 2, y: rect.top - canvasRect.top + rect.height / 2 };
    }

    function getEdgePoint(rect, dx, dy, canvasRect) {
        const cx = rect.left - canvasRect.left + rect.width / 2, cy = rect.top - canvasRect.top + rect.height / 2;
        const w = rect.width / 2, h = rect.height / 2;
        if (dx === 0 && dy === 0) return {x: cx, y: cy};
        const slope = dy / dx;
        if (Math.abs(slope) * w < h) return { x: cx + (dx > 0 ? w : -w), y: cy + slope * (dx > 0 ? w : -w) };
        return { x: cx + (dy > 0 ? h / slope : -h / slope), y: cy + (dy > 0 ? h : -h) };
    }

    // --- Persistence ---
    function saveState() {
        localStorage.setItem('canvasAppState_v5', JSON.stringify(getSerializableState()));
    }

    function getSerializableState() {
        return {
            items: Object.fromEntries(Object.entries(items).map(([id, item]) => [id, {
                id, type: item.type, x: item.x, y: item.y, width: item.width, height: item.height,
                data: item.data, parentId: item.parentId
            }])),
            links, nextItemId, nextLinkId
        };
    }

    function handleSave() {
        const stateString = JSON.stringify(getSerializableState(), null, 2);
        const blob = new Blob([stateString], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'dashboard-workflow.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function handleLoad(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            let content = e.target.result;
            
            // **FIX**: Clean the file content before parsing
            const cleanedContent = content
                .replace(/\\r?\n?/g, '') // Removes tags and potential newlines
                .replace(/^```json\s*/, '')             // Removes opening ```json tag
                .replace(/\s*```$/, '');                // Removes closing ``` tag

            try {
                const state = JSON.parse(cleanedContent);
                loadStateFromObject(state);
            } catch (error) {
                console.error("Error parsing cleaned workflow file:", error);
                alert("Invalid workflow file. Could not load.");
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }
    
    function loadState() {
        const savedState = localStorage.getItem('canvasAppState_v5');
        if (savedState) loadStateFromObject(JSON.parse(savedState));
    }

    function loadStateFromObject(state) {
        canvas.querySelectorAll('.tile').forEach(tile => tile.remove());
        items = {};
        links = [];
        selectedItemIds = [];

        if (!state.items) return;
        nextItemId = state.nextItemId || 1;
        nextLinkId = state.nextLinkId || 1;
        
        Object.values(state.items).forEach(savedItem => createAndAddItem(savedItem.type, savedItem, savedItem));

        Object.values(items).forEach(item => {
             if (item.type === 'group' && item.data.isExpanded) toggleGroupExpansion(item.id);
        });

        links = state.links || [];
        updateArrows();
        saveState();
    }

    initialize();
</script>

</body>
</html>
