<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Node-Based Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
            background-color: #f0f0f0;
        }

        /* --- NEW: Topbar --- */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #333;
            color: white;
            padding: 10px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #topbar h1 {
            margin: 0;
            font-size: 1.4em;
            font-weight: 400;
        }
        #topbar .topbar-buttons button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 10px;
            transition: background-color 0.2s;
        }
        #topbar .topbar-buttons button:hover {
            background-color: #0056b3;
        }
        #file-loader {
            display: none;
        }

        #canvas {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #e8e8e8;
            background-image: linear-gradient(rgba(0, 0, 0, 0.04) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 0, 0, 0.04) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            cursor: default;
            padding-top: 55px; /* Adjust for topbar height */
            box-sizing: border-box;
        }

        /* --- Tiles --- */
        .tile {
            position: absolute;
            background-color: #ffffe0; /* Light yellow sticky note */
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            border-radius: 3px;
            min-width: 250px;
            min-height: 150px;
            z-index: 10;
            transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tile.selected {
            box-shadow: 0 0 10px 4px #007bff;
            z-index: 11;
            border-color: #007bff;
        }

        .tile.dragging {
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
            opacity: 0.9;
        }

        .tile .tile-header {
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: grab;
            flex-shrink: 0;
            position: relative;
            padding-left: 10px;
            padding-right: 10px;
            padding-top: 5px;
            margin: -15px -15px 10px -15px;
        }

        .tile .tile-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(211, 211, 211, 0.3);
            z-index: -1;
            border-radius: 3px 3px 0 0;
            border-bottom: 1px solid #eee;
        }

        .tile .tile-header h3 {
            margin: 0;
            font-size: 1.1em;
            color: #333;
            flex-grow: 1;
            margin-right: 10px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: default;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .tile .tile-header h3[contenteditable="true"] {
            background-color: rgba(0, 123, 255, 0.1);
            outline: 1px solid rgba(0, 123, 255, 0.5);
            cursor: text;
            user-select: text;
        }

        /* --- Type Change Dropdown --- */
        .tile .tile-header .change-type-btn {
            font-size: 1.1em; cursor: pointer; color: #bbb; padding: 0 3px;
            margin-right: 5px; line-height: 1; z-index: 1; font-family: sans-serif;
            display: inline-block; vertical-align: middle;
        }
        .tile .tile-header .change-type-btn:hover { color: #555; }
        .tile.estimator .change-type-btn, .tile.group .change-type-btn {
            opacity: 0.4; cursor: not-allowed;
        }

        .tile .tile-header .delete-btn {
            font-size: 1.2em; cursor: pointer; color: #aaa; padding: 0 5px;
            line-height: 1; z-index: 1;
        }
        .tile .tile-header .delete-btn:hover { color: #dc3545; }

        .tile .tile-content {
            flex-grow: 1; overflow-y: auto; overflow-x: hidden;
            user-select: text; -webkit-user-select: text;
            cursor: default;
        }

        .tile label {
            display: flex; align-items: center; margin-top: 8px;
            font-size: 0.9em; cursor: default;
        }

        .tile label span {
            width: 110px; margin-right: 5px; color: #555;
            white-space: nowrap; flex-shrink: 0;
        }

        .tile input[type="number"], .tile select, .tile input[type="text"], .tile textarea {
            flex: 1; padding: 5px; border: 1px solid #ddd; border-radius: 3px;
            font-size: 0.9em; user-select: text; cursor: auto;
            width: auto; box-sizing: border-box;
        }
        .tile textarea { resize: none; min-height: 50px; font-family: inherit; flex-grow: 1; }

        /* Data Tile Specifics */
        .tile.data .data-image { max-width: 100%; height: auto; display: block; margin-top: 5px; }
        .tile.data .data-text { width: 100%; height: 100%; box-sizing: border-box; white-space: pre-wrap; word-wrap: break-word; }

        /* Estimator Tile Specifics */
        .tile.estimator h4 { font-size: 1em; margin-bottom: 8px; border-bottom: none; }
        .tile.estimator p { margin: 4px 0; font-size: 0.95em; cursor: default; }
        .tile.estimator strong { font-weight: bold; color: #0056b3; }
        .tile.estimator .result { margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee; font-size: 1.1em; font-weight: bold; color: #004085; cursor: default; }

        /* Scribble Pad Tile Specifics */
        .tile.scribble .tile-content { padding: 5px; }
        .tile.scribble .scribble-text {
            width: 100%; height: 100%; box-sizing: border-box; border: none; outline: none; resize: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 0.95em;
            line-height: 1.4; background-color: transparent; padding: 5px; user-select: text; cursor: auto;
        }

        /* --- NEW: Group Tile Specifics --- */
        .tile.group {
            background-color: #e0e8ff; /* Light blue */
            border-color: #a0b0e0;
            transition: all 0.3s ease-in-out;
        }
        .tile.group .tile-header::before {
            background-color: rgba(160, 176, 224, 0.4);
        }
        .tile.group .group-content {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #445a8a;
        }
        .tile.group.expanded {
            background-color: rgba(200, 210, 240, 0.5);
            border: 2px dashed #a0b0e0;
            padding: 0;
            z-index: 8; /* Below normal tiles */
        }
        .tile.group.expanded .tile-header {
            background-color: rgba(160, 176, 224, 0.6);
            cursor: pointer;
            margin: 0;
            padding: 10px;
            border-bottom: 2px dashed #a0b0e0;
            border-radius: 3px 3px 0 0;
        }
        .tile.group.expanded .tile-header::before { display: none; }
        .tile.group.expanded .tile-content { display: none; }
        .tile.group.expanded .resizer, .tile.group.expanded .delete-btn {
            display: none;
        }
        .tile.hidden-child {
            display: none !important;
        }


        .resizer {
            position: absolute; width: 15px; height: 15px;
            background: rgba(0, 123, 255, 0.3); border: 1px solid rgba(0, 123, 255, 0.6);
            bottom: -1px; right: -1px; cursor: nwse-resize;
            z-index: 12; border-radius: 0 0 3px 0;
        }

        /* --- Context Menu --- */
        #context-menu {
            position: absolute; background-color: #fff; border: 1px solid #ccc;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15); padding: 5px 0; min-width: 150px;
            z-index: 100; display: none; border-radius: 4px;
        }
        #context-menu ul { list-style: none; margin: 0; padding: 0; }
        #context-menu ul li { padding: 8px 15px; cursor: pointer; font-size: 0.95em; position: relative; white-space: nowrap; }
        #context-menu ul li:hover { background-color: #f0f0f0; }
        #context-menu ul li.disabled { color: #aaa; cursor: not-allowed; background-color: #fff; }
        #context-menu ul li.has-submenu::after { content: 'â–¶'; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 0.8em; color: #888; }
        #context-menu ul ul {
            position: absolute; left: 100%; top: -5px; display: none; background-color: #fff;
            border: 1px solid #ccc; box-shadow: 3px 3px 8px rgba(0,0,0,0.15); padding: 5px 0;
            min-width: 250px; max-height: 400px; overflow-y: auto; border-radius: 4px;
        }
        #context-menu ul li:hover > ul { display: block; }
        #context-menu .separator { height: 1px; background-color: #eee; margin: 5px 0; }

        /* Type Change Menu */
        #type-change-menu {
            position: absolute; background-color: #fff; border: 1px solid #ccc;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.15); padding: 4px 0; min-width: 120px;
            z-index: 101; display: none; border-radius: 3px;
        }
        #type-change-menu ul { list-style: none; margin: 0; padding: 0; }
        #type-change-menu ul li { padding: 6px 12px; cursor: pointer; font-size: 0.9em; white-space: nowrap; }
        #type-change-menu ul li:hover { background-color: #f0f0f0; }
        #type-change-menu ul li.disabled { color: #aaa; cursor: not-allowed; background-color: #fff; }

        .tile.task .description.editing {
            background-color: rgba(255, 255, 0, 0.2); outline: 1px dashed #ccc; padding: 3px;
            margin: -3px; cursor: text; user-select: text; white-space: pre-wrap; min-height: 1.5em;
        }

        /* SVG Arrows */
        #arrow-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; overflow: visible; }
        .arrow { stroke: #5a5a5a; stroke-width: 1.5; fill: none; marker-end: url(#arrowhead); }
    </style>
</head>
<body>

<div id="topbar">
    <h1>Node-Based Dashboard</h1>
    <div class="topbar-buttons">
        <button id="save-btn">Save Workflow</button>
        <button id="load-btn">Load Workflow</button>
        <input type="file" id="file-loader" accept=".json">
    </div>
</div>

<div id="canvas">
    <svg id="arrow-layer">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L10,3.5 L0,7 Z" fill="#5a5a5a" />
            </marker>
        </defs>
    </svg>
</div>

<div id="context-menu">
    <ul>
        <li id="add-general-task">General Task</li>
        <li id="add-preset-task" class="has-submenu">
            Presets
            <ul id="preset-submenu"><li>Loading...</li></ul>
        </li>
        <li id="add-estimator">Estimator</li>
        <li id="add-scribble-pad">Scribble Pad</li>
        <li class="separator"></li>
        <li id="group-selection">Group Selection</li>
    </ul>
</div>

<div id="type-change-menu"><ul></ul></div>

<template id="task-template">
    <div class="tile task" id="">
        <div class="tile-header">
            <h3 class="tile-title">New Task</h3>
            <span class="change-type-btn" title="Change Type">â–¾</span>
            <span class="delete-btn" title="Delete Task">Ã—</span>
        </div>
        <div class="tile-content">
            <p class="description" style="font-size: 0.85em; color: #666; margin-bottom: 10px; display: none;"></p>
            <label><span>Complexity (SP):</span> <select class="complexity"></select> </label>
            <label><span>Risk Factor (0-1):</span> <input type="number" step="0.05" min="0" max="1" class="risk" value="0.1"> </label>
            <label><span>Priority (1-5):</span> <input type="number" class="priority" value="3" min="1" max="5" step="1"> </label>
            <label><span>Base Duration (days):</span> <input type="number" step="0.5" min="0.5" class="duration" value="1"> </label>
        </div>
        <div class="resizer"></div>
    </div>
</template>

<template id="estimator-template">
    <div class="tile estimator" id="">
        <div class="tile-header">
            <h3 class="tile-title">Project Estimator</h3>
            <span class="change-type-btn" title="Change Type">â–¾</span>
            <span class="delete-btn" title="Delete Estimator">Ã—</span>
        </div>
        <div class="tile-content">
            <h4>Team & Project Factors</h4>
            <label><span>Team Members (R):</span> <input type="number" id="team-members" value="5" min="1"> </label>
            <label><span>Hours/Day/Member (D):</span> <input type="number" id="working-hours" value="8" min="1" step="0.5"> </label>
            <label><span>Overhead Factor (O):</span> <input type="number" step="0.01" id="overhead" value="0.15" min="0" max="0.99"> </label>
            <label><span>Productivity (P):</span> <input type="number" step="0.01" id="productivity" value="0.85" min="0.1" max="1.5"> </label>
            <label><span>Maturity/Learn (L):</span> <input type="number" step="0.05" id="learning-curve" value="1.0" min="0.5"> </label>
            <label><span>Hours per SP (H):</span> <input type="number" step="0.1" id="hours-per-story-point" value="4" min="0.5"> </label>
            <div class="result">
                <p>Total Base SP: <strong id="result-base-sp">0</strong></p>
                <p>Total Adjusted SP: <strong id="result-adj-sp">0</strong></p>
                <p>Team Velocity (SP/day): <strong id="result-velocity">0</strong></p>
                <p>Est. Duration (days): <strong id="result-duration">N/A</strong></p>
            </div>
        </div>
        <div class="resizer"></div>
    </div>
</template>

<template id="data-template">
    <div class="tile data" id="">
        <div class="tile-header">
            <h3 class="tile-title">Data</h3>
            <span class="change-type-btn" title="Change Type">â–¾</span>
            <span class="delete-btn" title="Delete Data">Ã—</span>
        </div>
        <div class="tile-content">
            <img class="data-image" src="" alt="Pasted image" style="display: none;">
            <textarea class="data-text" placeholder="Pasted text..." style="display: none;"></textarea>
        </div>
        <div class="resizer"></div>
    </div>
</template>

<template id="scribble-template">
    <div class="tile scribble" id="">
        <div class="tile-header">
            <h3 class="tile-title">Scribble Pad</h3>
            <span class="change-type-btn" title="Change Type">â–¾</span>
            <span class="delete-btn" title="Delete Scribble Pad">Ã—</span>
        </div>
        <div class="tile-content">
            <textarea class="scribble-text" placeholder="Start typing..."></textarea>
        </div>
        <div class="resizer"></div>
    </div>
</template>

<template id="group-template">
    <div class="tile group" id="">
        <div class="tile-header">
            <h3 class="tile-title">New Group</h3>
            <span class="change-type-btn" title="Change Type">â–¾</span>
            <span class="delete-btn" title="Delete Group">Ã—</span>
        </div>
        <div class="tile-content group-content">
            <p>This is a group. Double-click to expand.</p>
        </div>
        <div class="resizer"></div>
    </div>
</template>


<script>
    // --- Element Cache ---
    const canvas = document.getElementById('canvas');
    const contextMenu = document.getElementById('context-menu');
    const taskTemplate = document.getElementById('task-template');
    const estimatorTemplate = document.getElementById('estimator-template');
    const dataTemplate = document.getElementById('data-template');
    const scribbleTemplate = document.getElementById('scribble-template');
    const groupTemplate = document.getElementById('group-template');
    const svgLayer = document.getElementById('arrow-layer');
    const presetSubmenu = document.getElementById('preset-submenu');
    const typeChangeMenu = document.getElementById('type-change-menu');
    const fileLoader = document.getElementById('file-loader');


    const LOCAL_STORAGE_KEY = 'canvasAppState_v4'; // Incremented version

    // --- State Variables ---
    let items = {};
    let links = [];
    let selectedItemIds = []; // MODIFIED: For multi-select
    let nextItemId = 1;
    let nextLinkId = 1;
    let currentPasteCoords = { x: 100, y: 100 };
    let activeTypeChangeMenuTarget = null;

    // --- Constants ---
    const MARKER_WIDTH = 10;
    const DEFAULT_TILE_WIDTH = 300;
    const DEFAULT_TILE_HEIGHT = 200;
    const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
    const commonTasks = [ /* (Task list remains the same) */ ]; // Truncated for brevity

    // --- Initialization ---
    function initialize() {
        populatePresets();
        setupCanvasListeners();
        setupGlobalListeners();
        setupPasteListener();
        setupContextMenuListeners();
        setupTopbarListeners(); // NEW
        loadState(); // Load from localStorage on startup
    }

    // --- UI Setup ---
    function populatePresets() {
        /* ... (This function remains unchanged) ... */
    }

    function setupCanvasListeners() {
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // If right-clicking the canvas itself, show the menu
            if (e.target === canvas || e.target.closest('#arrow-layer')) {
                showContextMenu(e);
                // If not clicking on an already selected item, clear previous selections
                if (!selectedItemIds.some(id => items[id]?.element?.contains(e.target))) {
                    deselectAllItems();
                }
            } else {
                // If right-clicking a tile, the tile's own listener will handle selection.
                // We still show the context menu.
                showContextMenu(e);
            }
        });
        canvas.addEventListener('click', (e) => {
            // Click on canvas background
            const clickedOnTile = e.target.closest('.tile');
            if (!clickedOnTile && !contextMenu.contains(e.target) && !typeChangeMenu.contains(e.target)) {
                 currentPasteCoords = { x: e.pageX, y: e.pageY };
                 hideContextMenu();
                 hideTypeChangeMenu();
                 if (!e.shiftKey) { // MODIFIED: Deselect only if shift is not pressed
                     deselectAllItems();
                 }
            }
        });
        canvas.addEventListener('mousemove', (e) => { if (e.target === canvas) { currentPasteCoords = { x: e.pageX, y: e.pageY }; } });
    }

    function setupGlobalListeners() {
        document.addEventListener('keydown', (e) => {
            const activeElement = document.activeElement;
            const isEditingText = activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable;
            
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItemIds.length > 0 && !isEditingText) {
                e.preventDefault();
                const itemType = items[selectedItemIds[0]]?.type || 'item';
                const deleteMessage = `Delete ${selectedItemIds.length} selected ${itemType}(s)?`;
                if (confirm(deleteMessage)) {
                    // Create a copy of the array to iterate over, as deleteItem modifies the original
                    [...selectedItemIds].forEach(id => deleteItem(id));
                }
            }
        });
        document.addEventListener('click', (e) => {
             if (!contextMenu.contains(e.target)) { hideContextMenu(); }
        }, true);
    }

    function setupPasteListener() { /* ... (This function remains unchanged) ... */ }

    function setupContextMenuListeners() {
        document.getElementById('add-general-task').addEventListener('click', (e) => {
            e.stopPropagation(); const coords = { pageX: contextMenu.dataset.pageX, pageY: contextMenu.dataset.pageY }; createAndAddItem('task', coords); hideContextMenu();
        });
        document.getElementById('add-estimator').addEventListener('click', (e) => {
            e.stopPropagation(); const coords = { pageX: contextMenu.dataset.pageX, pageY: contextMenu.dataset.pageY }; createAndAddItem('estimator', coords); hideContextMenu();
        });
        document.getElementById('add-scribble-pad').addEventListener('click', (e) => {
            e.stopPropagation(); const coords = { pageX: contextMenu.dataset.pageX, pageY: contextMenu.dataset.pageY }; createAndAddItem('scribble', coords); hideContextMenu();
        });
        // NEW: Group selection listener
        document.getElementById('group-selection').addEventListener('click', (e) => {
            e.stopPropagation();
            if (selectedItemIds.length > 1) {
                createGroupFromSelection();
            }
            hideContextMenu();
        });
    }

    // --- NEW: Topbar Listeners for Save/Load ---
    function setupTopbarListeners() {
        document.getElementById('save-btn').addEventListener('click', handleSave);
        document.getElementById('load-btn').addEventListener('click', () => fileLoader.click());
        fileLoader.addEventListener('change', handleLoad);
    }

    // --- Context Menu Logic ---
    function showContextMenu(e) {
        // NEW: Logic to enable/disable "Group Selection" option
        const groupOption = document.getElementById('group-selection');
        if (selectedItemIds.length > 1) {
            groupOption.classList.remove('disabled');
        } else {
            groupOption.classList.add('disabled');
        }

        const { clientX, clientY, pageX, pageY } = e;
        const menuWidth = contextMenu.offsetWidth || 150; const menuHeight = contextMenu.offsetHeight || 100;
        const bodyWidth = document.documentElement.clientWidth; const bodyHeight = document.documentElement.clientHeight;
        const adjustedX = (clientX + menuWidth > bodyWidth) ? (bodyWidth - menuWidth - 5) : clientX;
        const adjustedY = (clientY + menuHeight > bodyHeight) ? (bodyHeight - menuHeight - 5) : clientY;
        contextMenu.style.left = `${adjustedX}px`; contextMenu.style.top = `${adjustedY}px`;
        contextMenu.style.display = 'block'; contextMenu.dataset.pageX = pageX; contextMenu.dataset.pageY = pageY;
        hideTypeChangeMenu();
    }
    function hideContextMenu() { contextMenu.style.display = 'none'; }

    // --- Item Management ---
    function createAndAddItem(type, coords, presetData = null) {
        const newItemId = `item-${nextItemId++}`;
        let element, itemData = {}, template;

        const templates = {
            task: taskTemplate,
            estimator: estimatorTemplate,
            data: dataTemplate,
            scribble: scribbleTemplate,
            group: groupTemplate // NEW
        };
        template = templates[type];
        if (!template) return null;

        if (type === 'estimator') {
            const existingEstimator = Object.values(items).find(item => item.type === 'estimator');
            if (existingEstimator) { alert(`Only one Estimator tile allowed.`); selectItem(existingEstimator.id); bringToFront(existingEstimator.id); return null; }
        }

        const node = template.content.cloneNode(true);
        element = node.querySelector('.tile');
        element.id = newItemId;

        const spawnX = parseInt(coords?.pageX || coords?.x || currentPasteCoords.x);
        const spawnY = parseInt(coords?.pageY || coords?.y || currentPasteCoords.y);
        element.style.left = `${spawnX}px`;
        element.style.top = `${spawnY}px`;
        
        const titleH3 = element.querySelector('.tile-title');

        if (type === 'task') {
             /* ... (Task creation logic remains the same) ... */
             itemData = { title: titleH3.textContent, description: '', complexity: 3, risk: 0.1, priority: 3, duration: 1 };
        } else if (type === 'estimator') {
             /* ... (Estimator creation logic remains the same) ... */
             itemData = { title: titleH3.textContent, teamMembers: 5, workingHours: 8, overhead: 0.15, productivity: 0.85, learningCurve: 1.0, hoursPerStoryPoint: 4 };
        } else if (type === 'data') {
             /* ... (Data creation logic remains the same) ... */
             itemData = { title: "Data", dataType: 'text', content: '' };
        } else if (type === 'scribble') {
             /* ... (Scribble creation logic remains the same) ... */
             itemData = { title: "Scribble Pad", content: '' };
        } else if (type === 'group') {
             // NEW: Group creation logic
             titleH3.textContent = presetData?.title || 'New Group';
             itemData = {
                 title: titleH3.textContent,
                 children: presetData?.children || [], // Store child IDs
                 isExpanded: false
             };
        }

        element.style.width = `${presetData?.width || DEFAULT_TILE_WIDTH}px`;
        element.style.height = `${presetData?.height || DEFAULT_TILE_HEIGHT}px`;

        canvas.appendChild(element);
        items[newItemId] = {
            id: newItemId,
            type: type,
            x: spawnX, y: spawnY,
            width: parseInt(element.style.width),
            height: parseInt(element.style.height),
            data: itemData,
            element: element,
            parentId: presetData?.parentId || null // NEW: For grouping
        };

        setupTileInteraction(element);
        calculate();
        selectItem(newItemId, false); // Select the new item, don't clear others yet
        saveState();
        return newItemId;
    }

    function deleteItem(itemId) {
        if (!items[itemId]) return;
        const itemToDelete = items[itemId];

        // NEW: If deleting a group, ungroup children first
        if (itemToDelete.type === 'group' && itemToDelete.data.children.length > 0) {
            // Move children out of the group before deleting the group
            itemToDelete.data.children.forEach(childId => {
                if(items[childId]) items[childId].parentId = null;
            });
        }
        
        const itemElement = itemToDelete.element;
        links = links.filter(link => {
            if (link.sourceId === itemId || link.targetId === itemId) {
                const arrowElement = document.getElementById(`link-${link.id}`);
                if (arrowElement) arrowElement.remove();
                return false;
            }
            return true;
        });

        if (itemElement) itemElement.remove();
        delete items[itemId];
        
        // Remove from selection
        const selectionIndex = selectedItemIds.indexOf(itemId);
        if (selectionIndex > -1) {
            selectedItemIds.splice(selectionIndex, 1);
        }
        
        updateArrows();
        calculate();
        saveState();
    }
    
    // --- Tile Interaction (MODIFIED FOR MULTI-SELECT AND GROUPS) ---
    function setupTileInteraction(tileElement) {
        const itemId = tileElement.id;
        const headerElement = tileElement.querySelector('.tile-header');
        
        // --- Dragging ---
        interact(tileElement).draggable({
            allowFrom: headerElement,
            listeners: {
                start(event) {
                    if (!selectedItemIds.includes(itemId)) {
                        selectItem(itemId, event.shiftKey);
                    }
                    bringToFront(itemId);
                    event.target.classList.add('dragging');
                    if (headerElement) headerElement.style.cursor = 'grabbing';
                },
                move(event) {
                    const groupMovements = {}; // To store movement for each group

                    selectedItemIds.forEach(selectedId => {
                        const targetItem = items[selectedId];
                        if (!targetItem) return;

                        let dx = event.dx;
                        let dy = event.dy;
                        
                        // If part of a group, calculate movement relative to the group
                        if(targetItem.parentId && items[targetItem.parentId]?.data.isExpanded) {
                            if(!groupMovements[targetItem.parentId]) {
                                groupMovements[targetItem.parentId] = { dx: 0, dy: 0, members: [] };
                            }
                            groupMovements[targetItem.parentId].members.push(targetItem);
                            // We will process group moves after single node moves.
                            return;
                        }

                        targetItem.x += dx;
                        targetItem.y += dy;
                        targetItem.element.style.left = `${targetItem.x}px`;
                        targetItem.element.style.top = `${targetItem.y}px`;

                        // If dragging a group, move its children too
                        if (targetItem.type === 'group' && targetItem.data.isExpanded) {
                            targetItem.data.children.forEach(childId => {
                                const childItem = items[childId];
                                if(childItem) {
                                    childItem.x += dx;
                                    childItem.y += dy;
                                    childItem.element.style.left = `${childItem.x}px`;
                                    childItem.element.style.top = `${childItem.y}px`;
                                }
                            });
                        }
                    });
                    updateArrows();
                },
                end(event) {
                    event.target.classList.remove('dragging');
                    if (headerElement) headerElement.style.cursor = 'grab';
                    saveState();
                }
            }
        });

        // --- Resizing ---
        interact(tileElement).resizable({ /* ... (Unchanged) ... */ });

        // --- Tile Click (Selection) ---
        tileElement.addEventListener('click', (e) => {
            if (e.target.closest('.tile-header') || e.target.closest('.resizer') || e.target.matches('input, select, textarea, label, button, .delete-btn, .change-type-btn')) {
                 if (!e.target.classList.contains('delete-btn') && !e.target.classList.contains('change-type-btn')) return;
            }
            selectItem(itemId, e.shiftKey);
            hideContextMenu(); hideTypeChangeMenu(); e.stopPropagation();
        });

        // --- Double Click to Expand/Collapse Group ---
        if (items[itemId]?.type === 'group') {
            tileElement.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                toggleGroupExpansion(itemId);
            });
        }
        
        // Other listeners (delete, rename, etc.)
        /* ... (These listeners remain largely the same, but now act on the specific tile) ... */
    }

    function bringToFront(itemId) { /* ... (Unchanged) ... */ }
    function updateItemData(itemId) { /* ... (Unchanged) ... */ }

    // MODIFIED: Selection Logic for Multi-Select
    function selectItem(itemId, isMultiSelect = false) {
        if (!isMultiSelect) {
            deselectAllItems();
        }

        const index = selectedItemIds.indexOf(itemId);
        if (index > -1) {
            // Already selected. If multi-selecting, deselect it.
            if (isMultiSelect) {
                items[itemId]?.element.classList.remove('selected');
                selectedItemIds.splice(index, 1);
            }
        } else {
            // Not selected. Add to selection.
            if (items[itemId]?.element) {
                items[itemId].element.classList.add('selected');
                selectedItemIds.push(itemId);
                bringToFront(itemId);
            }
        }
    }

    function deselectAllItems() {
        selectedItemIds.forEach(id => {
            items[id]?.element?.classList.remove('selected');
        });
        selectedItemIds = [];
    }
    
    // --- NEW: Grouping Logic ---
    function createGroupFromSelection() {
        if (selectedItemIds.length <= 1) return;

        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
        
        // Find bounding box of selected items
        selectedItemIds.forEach(id => {
            const item = items[id];
            if (item) {
                minX = Math.min(minX, item.x);
                minY = Math.min(minY, item.y);
                maxX = Math.max(maxX, item.x + item.width);
                maxY = Math.max(maxY, item.y + item.height);
            }
        });

        const groupWidth = maxX - minX + 80; // Add padding
        const groupHeight = maxY - minY + 80;
        const groupX = minX - 40;
        const groupY = minY - 40;

        const groupPreset = {
            title: "New Group",
            children: [...selectedItemIds],
            width: DEFAULT_TILE_WIDTH, // Start collapsed
            height: DEFAULT_TILE_HEIGHT,
        };

        const groupId = createAndAddItem('group', { pageX: groupX, pageY: groupY }, groupPreset);

        // Assign parentId to children and hide them
        selectedItemIds.forEach(childId => {
            if (items[childId]) {
                items[childId].parentId = groupId;
                items[childId].element.classList.add('hidden-child');
            }
        });
        
        deselectAllItems();
        selectItem(groupId);
        updateArrows();
        saveState();
    }

    function toggleGroupExpansion(groupId) {
        const group = items[groupId];
        if (!group || group.type !== 'group') return;

        group.data.isExpanded = !group.data.isExpanded;
        const groupElement = group.element;

        if (group.data.isExpanded) {
            // EXPAND
            groupElement.classList.add('expanded');
            
            // Calculate bounding box of children to resize group container
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            group.data.children.forEach(childId => {
                const child = items[childId];
                if (child) {
                    child.element.classList.remove('hidden-child');
                    minX = Math.min(minX, child.x);
                    minY = Math.min(minY, child.y);
                    maxX = Math.max(maxX, child.x + child.width);
                    maxY = Math.max(maxY, child.y + child.height);
                }
            });
            
            group.width = maxX - minX + 80;
            group.height = maxY - minY + 80;
            group.x = minX - 40;
            group.y = minY - 40;

            groupElement.style.width = `${group.width}px`;
            groupElement.style.height = `${group.height}px`;
            groupElement.style.left = `${group.x}px`;
            groupElement.style.top = `${group.y}px`;

        } else {
            // COLLAPSE
            groupElement.classList.remove('expanded');
            group.data.children.forEach(childId => {
                items[childId]?.element.classList.add('hidden-child');
            });
            // Restore to a default size
            group.width = DEFAULT_TILE_WIDTH;
            group.height = DEFAULT_TILE_HEIGHT;
            groupElement.style.width = `${group.width}px`;
            groupElement.style.height = `${group.height}px`;
        }
        
        updateArrows();
        saveState();
    }


    // --- Type Change Logic ---
    /* ... (This section remains largely the same) ... */

    // --- Arrow Drawing (MODIFIED FOR GROUPS) ---
    function updateArrows() {
        svgLayer.querySelectorAll('.arrow').forEach(arrow => arrow.remove());
        const canvasRect = canvas.getBoundingClientRect();

        links.forEach(link => {
            let sourceItem = items[link.sourceId];
            let targetItem = items[link.targetId];
            if (!sourceItem || !targetItem) return;

            // NEW: Remap to parent group if child is in a collapsed group
            if (sourceItem.parentId && !items[sourceItem.parentId]?.data.isExpanded) {
                sourceItem = items[sourceItem.parentId];
            }
            if (targetItem.parentId && !items[targetItem.parentId]?.data.isExpanded) {
                targetItem = items[targetItem.parentId];
            }

            // If a link is purely internal to a collapsed group, don't draw it
            if (sourceItem === targetItem) return;

            if (!sourceItem || !targetItem || !sourceItem.element || !targetItem.element) return;
            
            const sourceRect = sourceItem.element.getBoundingClientRect();
            const targetRect = targetItem.element.getBoundingClientRect();
            
            // ... the rest of getEdgePoint logic remains the same
            const sourceCenter = getElementCenter(sourceItem.element, canvasRect);
            const targetCenter = getElementCenter(targetItem.element, canvasRect);
            const dx = targetCenter.x - sourceCenter.x;
            const dy = targetCenter.y - sourceCenter.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 1) return;
            const startPoint = getEdgePoint(sourceRect, dx, dy, canvasRect);
            const endPoint = getEdgePoint(targetRect, -dx, -dy, canvasRect);
            // ... path drawing logic remains the same
            const pathData = `M ${startPoint.x},${startPoint.y} L ${endPoint.x},${endPoint.y}`;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'arrow');
            path.setAttribute('id', `link-${link.id}`);
            svgLayer.appendChild(path);
        });
    }

    function getElementCenter(element, canvasRect) { /* ... (Unchanged) ... */ }
    function getEdgePoint(rect, dx, dy, canvasRect) { /* ... (Unchanged) ... */ }

    // --- Calculation ---
    function calculate() { /* ... (Unchanged) ... */ }
    function updateEstimatorDisplay(results, estimatorElement = null) { /* ... (Unchanged) ... */ }

    // --- Persistence (MODIFIED for Save/Load files) ---
    function saveState() {
        // This still saves to localStorage for auto-saving sessions
        try {
            const state = getSerializableState();
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
        } catch (error) {
            console.error("Error saving state to localStorage:", error);
        }
    }

    function getSerializableState() {
        const serializableItems = {};
        for (const id in items) {
            const item = items[id];
            serializableItems[id] = {
                id: item.id, type: item.type,
                x: item.x, y: item.y, width: item.width, height: item.height,
                data: item.data,
                parentId: item.parentId // NEW: Save parent relationship
            };
        }
        return { items: serializableItems, links: links, nextItemId: nextItemId, nextLinkId: nextLinkId };
    }

    function handleSave() {
        try {
            const state = getSerializableState();
            const stateString = JSON.stringify(state, null, 2); // Pretty print JSON
            const blob = new Blob([stateString], { type: 'application/json' });
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'dashboard-workflow.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        } catch (error) {
            console.error("Error saving workflow to file:", error);
            alert("Could not save workflow to file.");
        }
    }

    function handleLoad(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            try {
                const state = JSON.parse(content);
                loadStateFromObject(state);
            } catch (error) {
                console.error("Error parsing or loading workflow file:", error);
                alert("Invalid workflow file. Could not load.");
            }
        };
        reader.onerror = () => {
             console.error("Error reading file:", reader.error);
             alert("Error reading file.");
        };
        reader.readAsText(file);

        // Reset the file input so the 'change' event fires again for the same file
        event.target.value = '';
    }
    
    function loadState() {
        // Loads from localStorage
        const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedState) {
            try {
                const state = JSON.parse(savedState);
                loadStateFromObject(state);
            } catch (error) {
                console.error("Error loading state from localStorage:", error);
            }
        }
    }

    function loadStateFromObject(state) {
        // --- Clear current canvas ---
        canvas.querySelectorAll('.tile').forEach(tile => tile.remove());
        svgLayer.querySelectorAll('.arrow').forEach(arrow => arrow.remove());
        items = {};
        links = [];
        selectedItemIds = [];

        // --- Load from state object ---
        if (!state.items || typeof state.items !== 'object' || !state.links) {
            console.error("Invalid state object structure.");
            return;
        }

        nextItemId = state.nextItemId || 1;
        nextLinkId = state.nextLinkId || 1;
        
        // Load items
        for (const id in state.items) {
            const savedItem = state.items[id];
            // Recreate DOM element and add to items object
            const element = recreateElementFromSave(savedItem);
            if (element) {
                canvas.appendChild(element);
                items[id] = { ...savedItem, element: element };
                setupTileInteraction(element);

                // Handle group expansion state
                if (savedItem.type === 'group' && savedItem.data.isExpanded) {
                    element.classList.add('expanded');
                }
            }
        }

        // Second pass to handle group child visibility
         for (const id in items) {
             const item = items[id];
             if (item.parentId) {
                 const parent = items[item.parentId];
                 if(parent && !parent.data.isExpanded) {
                     item.element.classList.add('hidden-child');
                 }
             }
         }

        links = state.links || [];
        
        console.log(`State loaded. Next Item ID: ${nextItemId}, Next Link ID: ${nextLinkId}`);
        updateArrows();
        calculate();
        saveState(); // Save the newly loaded state to localStorage
    }

    function recreateElementFromSave(savedItem) { /* ... (This function is MODIFIED slightly) ... */
        let template;
        // ... (template selection logic remains the same) ...
        if (savedItem.type === 'group') template = groupTemplate;
        
        try {
            // ... (element creation logic remains the same) ...
            const node = template.content.cloneNode(true);
            const element = node.querySelector('.tile');
            // ... (restore position, size, title) ...
            
            if (savedItem.type === 'group') {
                const p = element.querySelector('.group-content p');
                if (p) p.textContent = `Contains ${savedItem.data.children.length} items.`;
            }

            // ... (all other type-specific restore logic remains the same) ...

            return element;
        } catch (error) { console.error(`Error recreating element for ${savedItem.id}:`, error, savedItem); return null; }
    }

    // --- Start the application ---
    initialize();

</script>

</body>
</html>
