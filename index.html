<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Knowledge Tree Workflow System</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            overflow: hidden;
            user-select: none;
        }

        /* Top Bar */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: linear-gradient(to right, #1e3c72, #2a5298);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        #topbar h1 {
            font-size: 18px;
            font-weight: 500;
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #topbar button {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-left: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        #topbar button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        #topbar #clear-btn {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }
        
        #topbar #clear-btn:hover {
            background: rgba(220, 53, 69, 0.5);
        }

        input[type="file"] {
            display: none;
        }

        /* Canvas */
        #canvas {
            position: absolute;
            top: 48px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            background-color: #e8eaed;
            background-image: radial-gradient(circle, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: grab;
        }
        
        #canvas.panning,
        #viewport.panning {
            cursor: grabbing !important;
        }
        
        #canvas.linking {
            cursor: crosshair !important;
        }

        #viewport {
            position: relative;
            min-width: 100%;
            min-height: 100%;
            width: 8000px;
            height: 8000px;
            transform-origin: 0 0;
            transition: none;
            cursor: grab;
        }
        
        #links-svg {
            cursor: grab;
        }

        /* Base Node Styles */
        .node {
            position: absolute;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: default;
            transition: box-shadow 0.2s, transform 0.2s;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 200px;
            min-height: 100px;
        }

        .node:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
        }

        .node.selected {
            border-color: #1a73e8;
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2);
            z-index: 10;
        }
        
        .node.link-source {
            border-color: #1a73e8 !important;
            border-width: 3px !important;
        }
        
        .node.link-target {
            border-color: #4caf50 !important;
            border-width: 3px !important;
        }

        .node.dragging {
            opacity: 0.9;
            cursor: grabbing;
            z-index: 100;
        }

        /* Node Header */
        .node-header {
            padding: 10px 14px;
            background: linear-gradient(to bottom, #fafafa, #f5f5f5);
            border-bottom: 1px solid #e0e0e0;
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .node.dragging .node-header {
            cursor: grabbing;
        }

        .node-type-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .node-title {
            font-weight: 600;
            font-size: 14px;
            color: #202124;
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .node-title[contenteditable="true"] {
            background: rgba(26, 115, 232, 0.1);
            outline: 1px solid rgba(26, 115, 232, 0.5);
            cursor: text;
            user-select: text;
        }

        .node-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .node-control {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.2s;
            color: #5f6368;
        }

        .node-control:hover {
            background: rgba(0,0,0,0.08);
        }

        .expand-icon {
            transition: transform 0.2s;
        }

        .node.expanded .expand-icon {
            transform: rotate(90deg);
        }

        /* Node Content */
        .node-content {
            padding: 12px;
            flex-grow: 1;
            overflow-y: auto;
            user-select: text;
            display: none;
        }

        .node.expanded .node-content {
            display: block;
        }

        /* Node Type Specific Styles */
        .node.scribble {
            background: #fffef0;
            border-color: #f9cc30;
        }

        .node.scribble .node-header {
            background: linear-gradient(to bottom, #fff9c4, #fff59d);
        }

        .node.group {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .node.group .node-header {
            background: linear-gradient(to bottom, #bbdefb, #90caf9);
        }

        .node.group.expanded {
            min-width: 400px;
            min-height: 300px;
        }

        .node.task {
            background: #f3e5f5;
            border-color: #9c27b0;
        }

        .node.task .node-header {
            background: linear-gradient(to bottom, #e1bee7, #ce93d8);
        }

        .node.estimator {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .node.estimator .node-header {
            background: linear-gradient(to bottom, #c8e6c9, #a5d6a7);
        }

        .node.data {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .node.data .node-header {
            background: linear-gradient(to bottom, #ffe0b2, #ffcc80);
        }

        .node.knowledge-section {
            background: #e0f2f1;
            border-color: #009688;
        }

        .node.knowledge-subsection {
            background: #e8eaf6;
            border-color: #3f51b5;
        }

        .node.knowledge-item {
            background: #fce4ec;
            border-color: #e91e63;
        }

        .node.adr {
            background: #efebe9;
            border-color: #795548;
        }

        /* Group Content Styles */
        .group-content {
            position: relative;
            min-height: 200px;
            padding: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-content: flex-start;
        }

        .group-child-icon {
            width: 80px;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .group-child-icon:hover {
            background: rgba(255,255,255,1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        .group-child-icon-symbol {
            font-size: 32px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .group-child-icon-title {
            font-size: 11px;
            text-align: center;
            color: #5f6368;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }

        /* Inline expanded nodes within groups */
        .inline-node {
            position: relative;
            width: 100%;
            margin-bottom: 16px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        .inline-node .node-header {
            cursor: default;
            position: relative;
        }

        .inline-collapse-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            background: rgba(0,0,0,0.05);
            transition: background 0.2s;
            color: #5f6368;
            font-size: 12px;
        }

        .inline-collapse-btn:hover {
            background: rgba(0,0,0,0.1);
            color: #202124;
        }

        /* Content Styles */
        .scribble-content {
            width: 100%;
            min-height: 100px;
            padding: 8px;
            resize: none;
            font-family: inherit;
            font-size: 13px;
            line-height: 1.6;
            background: transparent;
            border: none;
            outline: none;
        }

        .task-content label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .task-content label span {
            width: 120px;
            color: #5f6368;
            font-weight: 500;
        }

        .task-content input,
        .task-content select {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 13px;
        }

        .task-description {
            font-size: 12px;
            color: #5f6368;
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(0,0,0,0.03);
            border-radius: 4px;
            line-height: 1.5;
        }

        .estimator-content h4 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #202124;
        }

        .estimator-result {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #e0e0e0;
        }

        .estimator-result p {
            margin: 4px 0;
            font-size: 13px;
        }

        .estimator-result strong {
            color: #1976d2;
            font-weight: 600;
        }

        .data-image {
            max-width: 100%;
            height: auto;
            display: block;
            border-radius: 4px;
        }

        .data-text {
            width: 100%;
            min-height: 100px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            resize: none;
            font-family: inherit;
            font-size: 13px;
        }

        .knowledge-content,
        .adr-content textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            resize: vertical;
            font-family: inherit;
            font-size: 13px;
            line-height: 1.5;
        }

        .adr-content label {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .adr-content label span {
            width: 80px;
            color: #5f6368;
            font-weight: 500;
            padding-top: 4px;
        }

        .adr-content input,
        .adr-content textarea {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 13px;
        }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #bdbdbd 50%);
            border-radius: 0 0 6px 0;
        }

        /* Links */
        #links-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        .link {
            fill: none;
            stroke: #9e9e9e;
            stroke-width: 3;
            opacity: 0.7;
            cursor: pointer;
            pointer-events: stroke;
        }
        
        .link:hover {
            stroke: #616161;
            stroke-width: 4;
            opacity: 1;
        }
        
        .link-clickable {
            stroke: transparent;
            stroke-width: 12;
            cursor: pointer;
            pointer-events: stroke;
        }

        .link-arrow {
            fill: #9e9e9e;
            opacity: 0.7;
        }

        /* Context Menu */
        #context-menu {
            position: fixed;
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 4px 0;
            min-width: 180px;
            z-index: 1001;
            display: none;
        }

        .menu-item {
            padding: 8px 16px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .menu-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 4px 0;
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 24px 32px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            display: none;
            z-index: 2000;
        }

        /* Info Panel */
        #info-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            color: #5f6368;
            z-index: 500;
            display: flex;
            gap: 16px;
        }
        
        /* Zoom Indicator */
        #zoom-indicator {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            color: #5f6368;
            z-index: 500;
            font-weight: 500;
        }

        /* Markdown Styles */
        .markdown-content h1, .markdown-content h2, .markdown-content h3, .markdown-content h4 {
            margin: 16px 0 8px 0;
            color: #202124;
        }

        .markdown-content h1 { font-size: 20px; }
        .markdown-content h2 { font-size: 18px; }
        .markdown-content h3 { font-size: 16px; }
        .markdown-content h4 { font-size: 14px; font-weight: 600; }

        .markdown-content ul, .markdown-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .markdown-content li {
            margin: 4px 0;
            line-height: 1.5;
        }

        .markdown-content strong {
            font-weight: 600;
            color: #202124;
        }

        .markdown-content code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
        }

        .markdown-content p {
            margin: 8px 0;
            line-height: 1.6;
        }

        .markdown-content table {
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 13px;
        }

        .markdown-content th,
        .markdown-content td {
            border: 1px solid #dadce0;
            padding: 8px 12px;
            text-align: left;
        }

        .markdown-content th {
            background: #f5f5f5;
            font-weight: 600;
        }

        /* Auto Layout Button */
        .auto-layout-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
    </style>
</head>
<body>
    <div id="topbar">
        <h1>📊 Advanced Knowledge Tree Workflow System</h1>
        <button id="save-btn">💾 Save Workflow</button>
        <button id="load-btn">📁 Load Workflow</button>
        <button id="fit-btn">🔍 Fit to Screen</button>
        <button id="zoom-in-btn">➕ Zoom In</button>
        <button id="zoom-out-btn">➖ Zoom Out</button>
        <button id="auto-layout-btn" class="auto-layout-btn">🔀 Auto Layout</button>
        <button id="reset-btn">🏠 Reset View</button>
        <button id="clear-btn">🗑️ Clear All</button>
        <input type="file" id="file-input" accept=".json">
    </div>

    <div id="canvas">
        <div id="viewport">
            <svg id="links-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="12" markerHeight="12" 
                            refX="11" refY="4" orient="auto">
                        <polygon points="0 0, 12 4, 0 8" class="link-arrow"/>
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div id="context-menu">
        <div class="menu-item" data-action="add-scribble">📝 Add Scribble Pad</div>
        <div class="menu-item" data-action="add-task">✓ Add Task</div>
        <div class="menu-item" data-action="add-group">📁 Add Group</div>
        <div class="menu-item" data-action="add-estimator">📊 Add Estimator</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="add-knowledge-section">📚 Knowledge Section</div>
        <div class="menu-item" data-action="add-knowledge-subsection">📖 Knowledge Subsection</div>
        <div class="menu-item" data-action="add-knowledge-item">📄 Knowledge Item</div>
        <div class="menu-item" data-action="add-adr">🏛️ Add ADR</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="paste">📋 Paste Data</div>
    </div>

    <div id="info-panel">
        <span>Right-click for menu</span>
        <span>•</span>
        <span>Alt+drag to link nodes</span>
        <span>•</span>
        <span>Drag background to pan</span>
        <span>•</span>
        <span>Scroll to zoom</span>
        <span>•</span>
        <span>Auto-saves to browser</span>
    </div>

    <div id="zoom-indicator">100%</div>

    <div id="loading">Loading workflow...</div>

    <script>
        // State management
        let workflow = { items: {}, links: [], nextItemId: 1, nextLinkId: 1 };
        let selectedNode = null;
        let isDragging = false;
        let isResizing = false;
        let isLinking = false;
        let linkSource = null;
        let tempLinkLine = null;
        let dragOffset = { x: 0, y: 0 };
        let contextMenuPos = { x: 0, y: 0, groupId: null };
        let groups = {};
        let expandedInlineNodes = {}; // Track which nodes are expanded inline
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let panStartTime = 0;
        let panThreshold = 5; // pixels
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        // Storage key
        const STORAGE_KEY = 'workflow-visualizer-state';

        // DOM elements
        const canvas = document.getElementById('canvas');
        const viewport = document.getElementById('viewport');
        const linksSvg = document.getElementById('links-svg');
        const contextMenu = document.getElementById('context-menu');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const fileInput = document.getElementById('file-input');
        const fitBtn = document.getElementById('fit-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const autoLayoutBtn = document.getElementById('auto-layout-btn');
        const resetBtn = document.getElementById('reset-btn');
        const clearBtn = document.getElementById('clear-btn');
        const loading = document.getElementById('loading');
        const zoomIndicator = document.getElementById('zoom-indicator');

        // Node templates
        const nodeIcons = {
            'scribble': '📝',
            'task': '✓',
            'group': '📁',
            'estimator': '📊',
            'data': '📋',
            'knowledge-section': '📚',
            'knowledge-subsection': '📖',
            'knowledge-item': '📄',
            'adr': '🏛️'
        };

        // Initialize
        saveBtn.addEventListener('click', saveWorkflow);
        loadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileLoad);
        fitBtn.addEventListener('click', fitToScreen);
        zoomInBtn.addEventListener('click', () => {
            scale = Math.min(3, scale * 1.2);
            updateViewportTransform();
        });
        zoomOutBtn.addEventListener('click', () => {
            scale = Math.max(0.2, scale * 0.8);
            updateViewportTransform();
        });
        autoLayoutBtn.addEventListener('click', autoLayout);
        resetBtn.addEventListener('click', resetView);
        clearBtn.addEventListener('click', () => {
            if (confirm('Clear all nodes and data? This cannot be undone.')) {
                localStorage.removeItem(STORAGE_KEY);
                workflow = { items: {}, links: [], nextItemId: 1, nextLinkId: 1 };
                groups = {};
                expandedInlineNodes = {};
                scale = 1;
                translateX = 0;
                translateY = 0;
                renderWorkflow();
                updateViewportTransform();
                resetView();
            }
        });

        // Canvas event listeners - events bubble up from viewport
        canvas.addEventListener('contextmenu', handleContextMenu);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('wheel', handleWheel);
        canvas.addEventListener('mousedown', handlePanStart);
        canvas.addEventListener('mousemove', handlePan);
        canvas.addEventListener('mouseup', handlePanEnd);
        canvas.addEventListener('mouseleave', handlePanEnd);
        canvas.addEventListener('scroll', () => autoSave()); // Save scroll position
        canvas.addEventListener('dragover', handleDragOver);
        canvas.addEventListener('drop', handleDrop);
        document.addEventListener('paste', handlePaste);

        // Context menu listeners
        contextMenu.addEventListener('click', handleMenuClick);
        
        // Drag and drop handling
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            
            const files = e.dataTransfer.files;
            const canvasRect = canvas.getBoundingClientRect();
            const dropX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale;
            const dropY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale;
            
            Array.from(files).forEach((file, index) => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const id = `item-${workflow.nextItemId++}`;
                        const item = {
                            id: id,
                            type: 'data',
                            x: dropX + (index * 20),
                            y: dropY + (index * 20),
                            width: 300,
                            height: 200,
                            data: {
                                title: file.name,
                                dataType: 'image',
                                content: event.target.result
                            },
                            parentId: null
                        };
                        
                        workflow.items[id] = item;
                        createNode(item);
                        autoSave();
                    };
                    reader.readAsDataURL(file);
                } else if (file.type.startsWith('text/') || file.name.endsWith('.txt') || file.name.endsWith('.md')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const id = `item-${workflow.nextItemId++}`;
                        const item = {
                            id: id,
                            type: 'scribble',
                            x: dropX + (index * 20),
                            y: dropY + (index * 20),
                            width: 400,
                            height: 300,
                            data: {
                                title: file.name,
                                content: event.target.result,
                                isExpanded: true
                            },
                            parentId: null
                        };
                        
                        workflow.items[id] = item;
                        createNode(item);
                        autoSave();
                    };
                    reader.readAsText(file);
                }
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', handleKeyboard);

        // Storage functions
        function saveToLocalStorage() {
            try {
                // Update children arrays in group data before saving
                Object.keys(groups).forEach(groupId => {
                    if (workflow.items[groupId]) {
                        workflow.items[groupId].data.children = groups[groupId];
                    }
                });
                
                const state = {
                    workflow: workflow,
                    groups: groups,
                    expandedInlineNodes: expandedInlineNodes,
                    scale: scale,
                    translateX: translateX,
                    translateY: translateY,
                    scrollLeft: canvas.scrollLeft,
                    scrollTop: canvas.scrollTop
                };
                
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const savedState = localStorage.getItem(STORAGE_KEY);
                if (!savedState) return false;
                
                const state = JSON.parse(savedState);
                
                // Load workflow data
                workflow = state.workflow || { items: {}, links: [], nextItemId: 1, nextLinkId: 1 };
                groups = state.groups || {};
                expandedInlineNodes = state.expandedInlineNodes || {};
                
                // Load view state
                scale = state.scale || 1;
                translateX = state.translateX || 0;
                translateY = state.translateY || 0;
                
                // Render workflow
                renderWorkflow();
                updateViewportTransform();
                
                // Restore scroll position after a small delay to ensure DOM is ready
                setTimeout(() => {
                    if (state.scrollLeft) canvas.scrollLeft = state.scrollLeft;
                    if (state.scrollTop) canvas.scrollTop = state.scrollTop;
                }, 50);
                
                return true;
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                return false;
            }
        }
        
        // Auto-save on changes
        let saveTimeout;
        function autoSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveToLocalStorage();
            }, 100); // Debounce saves by 100ms
        }

        // File handling
        function saveWorkflow() {
            // Update children arrays in group data before saving
            Object.keys(groups).forEach(groupId => {
                if (workflow.items[groupId]) {
                    workflow.items[groupId].data.children = groups[groupId];
                }
            });
            
            const state = {
                items: workflow.items,
                links: workflow.links,
                nextItemId: workflow.nextItemId,
                nextLinkId: workflow.nextLinkId
            };
            
            const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workflow.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function handleFileLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            loading.style.display = 'block';
            const reader = new FileReader();
            
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    workflow = {
                        items: data.items || {},
                        links: data.links || [],
                        nextItemId: data.nextItemId || 1,
                        nextLinkId: data.nextLinkId || 1
                    };
                    
                    // Build groups from children arrays and parentId
                    groups = {};
                    expandedInlineNodes = {};
                    Object.values(workflow.items).forEach(item => {
                        if (item.type === 'group' && item.data.children) {
                            groups[item.id] = item.data.children;
                        }
                    });
                    
                    renderWorkflow();
                    loading.style.display = 'none';
                    updateViewportTransform();
                    fitToScreen();
                    
                    // Save the loaded workflow
                    autoSave();
                } catch (error) {
                    alert('Error loading workflow: ' + error.message);
                    loading.style.display = 'none';
                }
            };
            
            reader.readAsText(file);
        }

        // Render workflow
        function renderWorkflow() {
            // Clear existing content
            viewport.querySelectorAll('.node').forEach(node => node.remove());
            
            // Create top-level nodes only (not children of groups)
            Object.values(workflow.items).forEach(item => {
                if (!item.parentId) {
                    createNode(item);
                }
            });
            
            // Update links
            updateLinks();
        }

        // Create node
        function createNode(item, isInline = false, parentElement = null) {
            const node = document.createElement('div');
            node.className = `node ${item.type}${isInline ? ' inline-node' : ''}`;
            node.id = isInline ? `inline-${item.id}` : item.id;
            
            if (!isInline) {
                node.style.left = item.x + 'px';
                node.style.top = item.y + 'px';
            }
            node.style.width = item.width + 'px';
            node.style.height = item.height + 'px';
            
            // Header
            const header = document.createElement('div');
            header.className = 'node-header';
            
            const icon = document.createElement('div');
            icon.className = 'node-type-icon';
            icon.textContent = nodeIcons[item.type] || '📄';
            
            const title = document.createElement('div');
            title.className = 'node-title';
            title.textContent = item.data.title || 'Untitled';
            
            const controls = document.createElement('div');
            controls.className = 'node-controls';
            
            // Add expand control for expandable types (only for non-inline)
            if (hasExpandableContent(item) && !isInline) {
                const expandBtn = document.createElement('div');
                expandBtn.className = 'node-control expand-icon';
                expandBtn.innerHTML = '▶';
                expandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNode(node);
                });
                controls.appendChild(expandBtn);
            }
            
            // Delete Button (only for non-inline)
            if (!isInline) {
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'node-control';
                deleteBtn.innerHTML = '✕';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('Delete this node?')) {
                        deleteNode(item.id);
                    }
                });
                controls.appendChild(deleteBtn);
            }
            
            // Add collapse button for inline nodes
            if (isInline) {
                const collapseBtn = document.createElement('div');
                collapseBtn.className = 'inline-collapse-btn';
                collapseBtn.innerHTML = '◀';
                collapseBtn.title = 'Collapse to icon';
                collapseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const parentId = item.parentId;
                    if (parentId) {
                        toggleInlineNode(item.id, parentId);
                    }
                });
                header.appendChild(collapseBtn);
            }
            
            header.appendChild(icon);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'node-content';
            
            // Create content based on type
            switch (item.type) {
                case 'scribble':
                    content.innerHTML = `<textarea class="scribble-content">${item.data.content || ''}</textarea>`;
                    break;
                    
                case 'task':
                    content.innerHTML = createTaskContent(item.data);
                    break;
                    
                case 'estimator':
                    content.innerHTML = createEstimatorContent(item.data);
                    break;
                    
                case 'data':
                    content.innerHTML = createDataContent(item.data);
                    break;
                    
                case 'group':
                    content.innerHTML = createGroupContent(item);
                    break;
                    
                case 'knowledge-section':
                case 'knowledge-subsection':
                case 'knowledge-item':
                    content.innerHTML = `<textarea class="knowledge-content">${item.data.content || ''}</textarea>`;
                    break;
                    
                case 'adr':
                    content.innerHTML = createADRContent(item.data);
                    break;
            }
            
            // Resize handle (only for non-inline nodes)
            if (!isInline) {
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                node.appendChild(resizeHandle);
                resizeHandle.addEventListener('mousedown', (e) => startResize(node, e));
            }
            
            node.appendChild(header);
            node.appendChild(content);
            
            // Event listeners
            if (!isInline) {
                node.addEventListener('click', (e) => selectNode(node, e));
                header.addEventListener('mousedown', (e) => startDrag(node, e));
            }
            title.addEventListener('dblclick', (e) => editTitle(title, item, e));
            
            // Double-click to expand (only for non-inline nodes)
            if (hasExpandableContent(item) && !isInline) {
                node.addEventListener('dblclick', (e) => {
                    if (!e.target.classList.contains('node-title')) {
                        toggleNode(node);
                    }
                });
            }
            
            // Restore expanded state
            if (item.data.isExpanded || (isInline && expandedInlineNodes[item.id])) {
                node.classList.add('expanded');
            }
            
            // Setup change listeners for inputs
            setupInputListeners(node, item);
            
            // Add to appropriate parent
            if (isInline && parentElement) {
                parentElement.appendChild(node);
            } else {
                viewport.appendChild(node);
            }
            
            return node;
        }

        // Content creators
        function createTaskContent(data) {
            return `
                ${data.description ? `<div class="task-description">${data.description}</div>` : ''}
                <div class="task-content">
                    <label><span>Complexity (SP):</span>
                        <select class="complexity">
                            ${[1,2,3,5,8,13,21,34,55,89].map(n => 
                                `<option value="${n}" ${data.complexity == n ? 'selected' : ''}>${n}</option>`
                            ).join('')}
                        </select>
                    </label>
                    <label><span>Risk Factor:</span>
                        <input type="number" class="risk" value="${data.risk || 0.1}" min="0" max="1" step="0.05">
                    </label>
                    <label><span>Priority:</span>
                        <input type="number" class="priority" value="${data.priority || 3}" min="1" max="5">
                    </label>
                    <label><span>Duration (days):</span>
                        <input type="number" class="duration" value="${data.duration || 1}" min="0.5" step="0.5">
                    </label>
                </div>
            `;
        }

        function createEstimatorContent(data) {
            return `
                <div class="estimator-content">
                    <h4>Team & Project Factors</h4>
                    <label><span>Team Members:</span>
                        <input type="number" class="team-members" value="${data.teamMembers || 5}" min="1">
                    </label>
                    <label><span>Hours/Day/Member:</span>
                        <input type="number" class="working-hours" value="${data.workingHours || 8}" min="1" step="0.5">
                    </label>
                    <label><span>Overhead Factor:</span>
                        <input type="number" class="overhead" value="${data.overhead || 0.15}" min="0" max="0.99" step="0.01">
                    </label>
                    <label><span>Productivity:</span>
                        <input type="number" class="productivity" value="${data.productivity || 0.85}" min="0.1" max="1.5" step="0.01">
                    </label>
                    <label><span>Maturity/Learn:</span>
                        <input type="number" class="learning-curve" value="${data.learningCurve || 1.0}" min="0.5" step="0.05">
                    </label>
                    <label><span>Hours per SP:</span>
                        <input type="number" class="hours-per-sp" value="${data.hoursPerStoryPoint || 4}" min="0.5" step="0.1">
                    </label>
                    <div class="estimator-result">
                        <p>Total Base SP: <strong class="base-sp">0</strong></p>
                        <p>Total Adjusted SP: <strong class="adj-sp">0</strong></p>
                        <p>Team Velocity: <strong class="velocity">0</strong></p>
                        <p>Est. Duration: <strong class="duration">N/A</strong></p>
                    </div>
                </div>
            `;
        }

        function createDataContent(data) {
            if (data.dataType === 'image') {
                return `<img class="data-image" src="${data.content}" alt="Pasted image">`;
            } else {
                return `<textarea class="data-text">${data.content || ''}</textarea>`;
            }
        }

        function createGroupContent(item) {
            const children = groups[item.id] || item.data.children || [];
            const groupContent = document.createElement('div');
            groupContent.className = 'group-content';
            
            // Create child icons
            children.forEach(childId => {
                const childItem = workflow.items[childId];
                if (!childItem) return;
                
                // Check if this child is already expanded inline
                if (expandedInlineNodes[childId]) {
                    // Create inline expanded node
                    const inlineNode = createNode(childItem, true, groupContent);
                } else {
                    // Create icon
                    const childIcon = document.createElement('div');
                    childIcon.className = 'group-child-icon';
                    childIcon.dataset.childId = childId;
                    
                    const iconSymbol = document.createElement('div');
                    iconSymbol.className = 'group-child-icon-symbol';
                    iconSymbol.textContent = nodeIcons[childItem.type] || '📄';
                    
                    const iconTitle = document.createElement('div');
                    iconTitle.className = 'group-child-icon-title';
                    iconTitle.textContent = childItem.data.title || 'Untitled';
                    
                    childIcon.appendChild(iconSymbol);
                    childIcon.appendChild(iconTitle);
                    
                    // Double-click to expand inline
                    childIcon.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        toggleInlineNode(childId, item.id);
                    });
                    
                    groupContent.appendChild(childIcon);
                }
            });
            
            return groupContent.outerHTML;
        }

        function createADRContent(data) {
            return `
                <div class="adr-content">
                    <label><span>Code:</span>
                        <input type="text" class="adr-code" value="${data.code || ''}">
                    </label>
                    <label><span>Category:</span>
                        <input type="text" class="adr-category" value="${data.category || ''}">
                    </label>
                    <label><span>Topic:</span>
                        <textarea class="adr-topic">${data.topic || ''}</textarea>
                    </label>
                </div>
            `;
        }

        // Toggle inline node expansion
        function toggleInlineNode(childId, parentId) {
            const parentNode = document.getElementById(parentId);
            if (!parentNode) return;
            
            const parentItem = workflow.items[parentId];
            if (!parentItem) return;
            
            if (expandedInlineNodes[childId]) {
                // Collapse
                delete expandedInlineNodes[childId];
            } else {
                // Expand
                expandedInlineNodes[childId] = true;
            }
            
            // Recreate group content
            const content = parentNode.querySelector('.node-content');
            content.innerHTML = createGroupContent(parentItem);
            
            // Re-setup input listeners for any inputs in the recreated content
            setupInputListeners(parentNode, parentItem);
            
            autoSave();
        }

        // Auto Layout Algorithm
        function autoLayout() {
            const rootNodes = Object.values(workflow.items).filter(item => !item.parentId);
            if (rootNodes.length === 0) return;
            
            // Build hierarchy
            const hierarchy = buildHierarchy(rootNodes);
            
            // Calculate positions using tree layout
            const nodeSpacingX = 350;
            const nodeSpacingY = 250;
            const startX = 100;
            const startY = 100;
            
            layoutHierarchy(hierarchy, startX, startY, nodeSpacingX, nodeSpacingY);
            
            // Update node positions in DOM
            Object.values(workflow.items).forEach(item => {
                const node = document.getElementById(item.id);
                if (node && !node.classList.contains('inline-node')) {
                    node.style.left = item.x + 'px';
                    node.style.top = item.y + 'px';
                }
            });
            
            updateLinks();
            autoSave();
        }

        function buildHierarchy(nodes) {
            const hierarchy = [];
            
            nodes.forEach(node => {
                const hierNode = {
                    item: node,
                    children: []
                };
                
                // Find all nodes that link from this node
                const childLinks = workflow.links.filter(link => link.sourceId === node.id);
                childLinks.forEach(link => {
                    const childItem = workflow.items[link.targetId];
                    if (childItem) {
                        hierNode.children.push(...buildHierarchy([childItem]));
                    }
                });
                
                hierarchy.push(hierNode);
            });
            
            return hierarchy;
        }

        function layoutHierarchy(hierarchy, startX, startY, spacingX, spacingY) {
            let currentX = startX;
            
            hierarchy.forEach((node, index) => {
                const subtreeWidth = calculateSubtreeWidth(node, spacingX);
                const centerX = currentX + subtreeWidth / 2;
                
                // Position this node
                node.item.x = centerX - node.item.width / 2;
                node.item.y = startY;
                
                // Layout children
                if (node.children.length > 0) {
                    layoutHierarchy(node.children, currentX, startY + spacingY, spacingX, spacingY);
                }
                
                currentX += subtreeWidth + spacingX;
            });
        }

        function calculateSubtreeWidth(node, spacing) {
            if (node.children.length === 0) {
                return node.item.width;
            }
            
            let totalWidth = 0;
            node.children.forEach((child, index) => {
                totalWidth += calculateSubtreeWidth(child, spacing);
                if (index < node.children.length - 1) {
                    totalWidth += spacing;
                }
            });
            
            return Math.max(node.item.width, totalWidth);
        }

        // Advanced Pathfinding for arrows
        function findPath(startPoint, endPoint, obstacles) {
            // Calculate the path using orthogonal routing (Manhattan routing)
            const path = [];
            path.push(startPoint);
            
            // Check if we need to route around obstacles
            let directPathClear = true;
            for (let obstacle of obstacles) {
                if (lineIntersectsRect(startPoint, endPoint, obstacle)) {
                    directPathClear = false;
                    break;
                }
            }
            
            if (!directPathClear) {
                // Use orthogonal routing with smart waypoint selection
                const points = calculateOrthogonalPath(startPoint, endPoint, obstacles);
                path.push(...points.slice(1)); // Skip start point as it's already added
            } else {
                path.push(endPoint);
            }
            
            return path;
        }

        function calculateOrthogonalPath(start, end, obstacles) {
            // Create a routing grid with channels between obstacles
            const margin = 20; // Space to keep from obstacles
            const points = [start];
            
            // Determine primary routing direction
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            // Try different routing strategies
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal first, then vertical
                const midX = start.x + dx * 0.7;
                const waypoint1 = { x: midX, y: start.y };
                const waypoint2 = { x: midX, y: end.y };
                
                // Check if this path is clear
                let pathClear = true;
                const testPath = [start, waypoint1, waypoint2, end];
                for (let i = 0; i < testPath.length - 1; i++) {
                    for (let obstacle of obstacles) {
                        if (lineIntersectsRect(testPath[i], testPath[i + 1], obstacle)) {
                            pathClear = false;
                            break;
                        }
                    }
                    if (!pathClear) break;
                }
                
                if (pathClear) {
                    points.push(waypoint1, waypoint2);
                } else {
                    // Find alternative path around obstacles
                    const altPath = findAlternativeRoute(start, end, obstacles, margin);
                    points.push(...altPath.slice(1));
                }
            } else {
                // Vertical first, then horizontal
                const midY = start.y + dy * 0.7;
                const waypoint1 = { x: start.x, y: midY };
                const waypoint2 = { x: end.x, y: midY };
                
                // Check if this path is clear
                let pathClear = true;
                const testPath = [start, waypoint1, waypoint2, end];
                for (let i = 0; i < testPath.length - 1; i++) {
                    for (let obstacle of obstacles) {
                        if (lineIntersectsRect(testPath[i], testPath[i + 1], obstacle)) {
                            pathClear = false;
                            break;
                        }
                    }
                    if (!pathClear) break;
                }
                
                if (pathClear) {
                    points.push(waypoint1, waypoint2);
                } else {
                    // Find alternative path around obstacles
                    const altPath = findAlternativeRoute(start, end, obstacles, margin);
                    points.push(...altPath.slice(1));
                }
            }
            
            points.push(end);
            return points;
        }

        function findAlternativeRoute(start, end, obstacles, margin) {
            // Find the best route around obstacles
            const routes = [];
            
            // Try going around each obstacle
            obstacles.forEach(obstacle => {
                // Check if this obstacle is between start and end
                if (!isObstacleBetween(start, end, obstacle)) return;
                
                // Calculate routes around the obstacle
                const topRoute = {
                    points: [
                        start,
                        { x: obstacle.left - margin, y: start.y },
                        { x: obstacle.left - margin, y: obstacle.top - margin },
                        { x: end.x, y: obstacle.top - margin },
                        end
                    ],
                    distance: 0
                };
                
                const bottomRoute = {
                    points: [
                        start,
                        { x: obstacle.left - margin, y: start.y },
                        { x: obstacle.left - margin, y: obstacle.bottom + margin },
                        { x: end.x, y: obstacle.bottom + margin },
                        end
                    ],
                    distance: 0
                };
                
                const leftRoute = {
                    points: [
                        start,
                        { x: start.x, y: obstacle.top - margin },
                        { x: obstacle.left - margin, y: obstacle.top - margin },
                        { x: obstacle.left - margin, y: end.y },
                        end
                    ],
                    distance: 0
                };
                
                const rightRoute = {
                    points: [
                        start,
                        { x: start.x, y: obstacle.top - margin },
                        { x: obstacle.right + margin, y: obstacle.top - margin },
                        { x: obstacle.right + margin, y: end.y },
                        end
                    ],
                    distance: 0
                };
                
                // Calculate distances
                [topRoute, bottomRoute, leftRoute, rightRoute].forEach(route => {
                    route.distance = calculatePathDistance(route.points);
                });
                
                routes.push(topRoute, bottomRoute, leftRoute, rightRoute);
            });
            
            // If no specific obstacle routing needed, use simple orthogonal path
            if (routes.length === 0) {
                return [
                    start,
                    { x: start.x, y: end.y },
                    end
                ];
            }
            
            // Return the shortest valid route
            routes.sort((a, b) => a.distance - b.distance);
            for (let route of routes) {
                if (isPathClear(route.points, obstacles)) {
                    return route.points;
                }
            }
            
            // Fallback to simple path
            return [start, { x: start.x, y: end.y }, end];
        }

        function isObstacleBetween(start, end, obstacle) {
            // Check if obstacle is roughly between start and end points
            const minX = Math.min(start.x, end.x);
            const maxX = Math.max(start.x, end.x);
            const minY = Math.min(start.y, end.y);
            const maxY = Math.max(start.y, end.y);
            
            return obstacle.left < maxX && obstacle.right > minX &&
                   obstacle.top < maxY && obstacle.bottom > minY;
        }

        function calculatePathDistance(points) {
            let distance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i + 1].x - points[i].x;
                const dy = points[i + 1].y - points[i].y;
                distance += Math.sqrt(dx * dx + dy * dy);
            }
            return distance;
        }

        function isPathClear(points, obstacles) {
            for (let i = 0; i < points.length - 1; i++) {
                for (let obstacle of obstacles) {
                    if (lineIntersectsRect(points[i], points[i + 1], obstacle)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function lineIntersectsRect(p1, p2, rect) {
            // Check if a line segment intersects with a rectangle
            // Using line-rectangle intersection algorithm
            
            // Check if line is completely outside rectangle bounds
            if ((p1.x < rect.left && p2.x < rect.left) ||
                (p1.x > rect.right && p2.x > rect.right) ||
                (p1.y < rect.top && p2.y < rect.top) ||
                (p1.y > rect.bottom && p2.y > rect.bottom)) {
                return false;
            }
            
            // Check if either endpoint is inside the rectangle
            if ((p1.x >= rect.left && p1.x <= rect.right && 
                 p1.y >= rect.top && p1.y <= rect.bottom) ||
                (p2.x >= rect.left && p2.x <= rect.right && 
                 p2.y >= rect.top && p2.y <= rect.bottom)) {
                return true;
            }
            
            // Check line intersection with rectangle edges
            const lines = [
                { start: { x: rect.left, y: rect.top }, end: { x: rect.right, y: rect.top } },
                { start: { x: rect.right, y: rect.top }, end: { x: rect.right, y: rect.bottom } },
                { start: { x: rect.right, y: rect.bottom }, end: { x: rect.left, y: rect.bottom } },
                { start: { x: rect.left, y: rect.bottom }, end: { x: rect.left, y: rect.top } }
            ];
            
            for (let line of lines) {
                if (linesIntersect(p1, p2, line.start, line.end)) {
                    return true;
                }
            }
            
            return false;
        }

        function linesIntersect(p1, p2, p3, p4) {
            // Check if two line segments intersect
            const d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (d === 0) return false; // Parallel lines
            
            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;
            
            return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
        }

        // Markdown parser
        function parseMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML
            text = text.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;');
            
            // Headers
            text = text.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
            text = text.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            text = text.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            text = text.replace(/^# (.+)$/gm, '<h1>$1</h1>');
            
            // Bold
            text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            
            // Lists
            text = text.replace(/^\* (.+)$/gm, '<li>$1</li>');
            text = text.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');
            
            // Code
            text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Tables - improved support
            const lines = text.split('\n');
            let inTable = false;
            let tableHtml = '';
            let processedLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.includes('|') && line.trim().startsWith('|') && line.trim().endsWith('|')) {
                    if (!inTable) {
                        inTable = true;
                        tableHtml = '<table>';
                    }
                    
                    // Check if this is a separator line
                    if (line.match(/^\|\s*:?-+:?\s*\|/)) {
                        continue; // Skip separator lines
                    }
                    
                    // Process table row
                    const cells = line.split('|').filter((cell, index) => index > 0 && index < line.split('|').length - 1);
                    const isHeader = i > 0 && lines[i - 1].includes('|') && lines[i + 1] && lines[i + 1].match(/^\|\s*:?-+:?\s*\|/);
                    
                    tableHtml += '<tr>';
                    cells.forEach(cell => {
                        const tag = isHeader ? 'th' : 'td';
                        tableHtml += `<${tag}>${cell.trim()}</${tag}>`;
                    });
                    tableHtml += '</tr>';
                } else {
                    if (inTable) {
                        inTable = false;
                        tableHtml += '</table>';
                        processedLines.push(tableHtml);
                        tableHtml = '';
                    }
                    processedLines.push(line);
                }
            }
            
            if (inTable) {
                tableHtml += '</table>';
                processedLines.push(tableHtml);
            }
            
            text = processedLines.join('\n');
            
            // Paragraphs
            text = text.split('\n\n').map(para => {
                if (!para.startsWith('<')) {
                    return `<p>${para}</p>`;
                }
                return para;
            }).join('\n');
            
            return text;
        }

        // Node interactions
        function selectNode(node, e) {
            e.stopPropagation();
            
            if (selectedNode) {
                selectedNode.classList.remove('selected');
            }
            
            selectedNode = node;
            node.classList.add('selected');
        }

        function toggleNode(node) {
            const item = workflow.items[node.id];
            if (!item) return;
            
            node.classList.toggle('expanded');
            item.data.isExpanded = node.classList.contains('expanded');
            
            updateLinks();
            autoSave();
        }

        function editTitle(titleEl, item, e) {
            e.stopPropagation();
            
            const oldTitle = titleEl.textContent;
            titleEl.contentEditable = true;
            titleEl.focus();
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(titleEl);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            
            const save = () => {
                titleEl.contentEditable = false;
                const newTitle = titleEl.textContent.trim();
                if (newTitle) {
                    item.data.title = newTitle;
                    autoSave();
                } else {
                    titleEl.textContent = oldTitle;
                }
            };
            
            titleEl.addEventListener('blur', save, { once: true });
            titleEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    save();
                } else if (e.key === 'Escape') {
                    titleEl.textContent = oldTitle;
                    save();
                }
            });
        }

        // Dragging
        function startDrag(node, e) {
            if (e.target.classList.contains('node-control')) return;
            
            // Check if Alt key is held for linking
            if (e.altKey) {
                startLinking(node, e);
                return;
            }
            
            isDragging = true;
            const nodeRect = node.getBoundingClientRect();
            
            // Calculate the offset within the node where the mouse was clicked
            dragOffset = {
                x: e.clientX - nodeRect.left,
                y: e.clientY - nodeRect.top
            };
            
            node.classList.add('dragging');
            selectNode(node, e);
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            e.preventDefault();
        }

        function handleDrag(e) {
            if (!isDragging || !selectedNode) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate position accounting for scroll and scale
            const x = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale - dragOffset.x;
            const y = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale - dragOffset.y;
            
            selectedNode.style.left = Math.max(0, x) + 'px';
            selectedNode.style.top = Math.max(0, y) + 'px';
            
            const item = workflow.items[selectedNode.id];
            if (item) {
                item.x = Math.max(0, x);
                item.y = Math.max(0, y);
            }
            
            updateLinks();
        }

        function stopDrag() {
            isDragging = false;
            if (selectedNode) {
                selectedNode.classList.remove('dragging');
                autoSave();
            }
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // Linking nodes
        function startLinking(node, e) {
            isLinking = true;
            linkSource = node;
            
            // Add linking class to canvas
            canvas.classList.add('linking');
            
            // Create temporary link line
            tempLinkLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLinkLine.classList.add('link');
            tempLinkLine.style.strokeDasharray = '5,5';
            tempLinkLine.style.stroke = '#1a73e8';
            tempLinkLine.style.opacity = '0.5';
            linksSvg.appendChild(tempLinkLine);
            
            node.style.border = '3px solid #1a73e8';
            node.classList.add('link-source');
            
            document.addEventListener('mousemove', handleLinking);
            document.addEventListener('mouseup', stopLinking);
            e.preventDefault();
        }
        
        function handleLinking(e) {
            if (!isLinking || !linkSource || !tempLinkLine) return;
            
            const sourceItem = workflow.items[linkSource.id];
            if (!sourceItem) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale;
            const mouseY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale;
            
            const startX = sourceItem.x + sourceItem.width / 2;
            const startY = sourceItem.y + sourceItem.height;
            
            const pathString = `M ${startX} ${startY} L ${mouseX} ${mouseY}`;
            tempLinkLine.setAttribute('d', pathString);
            
            // Highlight potential target
            const element = document.elementFromPoint(e.clientX, e.clientY);
            const targetNode = element?.closest('.node');
            
            // Remove previous highlights
            document.querySelectorAll('.node').forEach(n => {
                if (n !== linkSource && !n.classList.contains('link-target')) {
                    n.style.border = '';
                }
            });
            
            if (targetNode && targetNode !== linkSource && !targetNode.classList.contains('inline-node')) {
                targetNode.style.border = '3px solid #4caf50';
                targetNode.classList.add('link-target');
            } else {
                document.querySelectorAll('.link-target').forEach(n => {
                    n.classList.remove('link-target');
                    if (n !== linkSource) n.style.border = '';
                });
            }
        }
        
        function stopLinking(e) {
            if (!isLinking) return;
            
            isLinking = false;
            canvas.classList.remove('linking');
            
            // Remove temporary line
            if (tempLinkLine) {
                tempLinkLine.remove();
                tempLinkLine = null;
            }
            
            // Check if we're over a valid target
            const element = document.elementFromPoint(e.clientX, e.clientY);
            const targetNode = element?.closest('.node');
            
            if (targetNode && targetNode !== linkSource && !targetNode.classList.contains('inline-node')) {
                // Create the link
                const sourceId = linkSource.id;
                const targetId = targetNode.id;
                
                // Check if link already exists
                const existingLink = workflow.links.find(link => 
                    link.sourceId === sourceId && link.targetId === targetId
                );
                
                if (!existingLink) {
                    workflow.links.push({
                        id: `link-${workflow.nextLinkId++}`,
                        sourceId: sourceId,
                        targetId: targetId
                    });
                    
                    updateLinks();
                    autoSave();
                }
            }
            
            // Clear all highlights
            document.querySelectorAll('.node').forEach(n => {
                n.style.border = '';
                n.classList.remove('link-target', 'link-source');
            });
            
            linkSource = null;
            
            document.removeEventListener('mousemove', handleLinking);
            document.removeEventListener('mouseup', stopLinking);
        }

        // Resizing
        function startResize(node, e) {
            isResizing = true;
            selectedNode = node;
            
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
            e.preventDefault();
        }

        function handleResize(e) {
            if (!isResizing || !selectedNode) return;
            
            const nodeRect = selectedNode.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate new dimensions accounting for scale
            const width = Math.max(200, (e.clientX - nodeRect.left) / scale);
            const height = Math.max(100, (e.clientY - nodeRect.top) / scale);
            
            selectedNode.style.width = width + 'px';
            selectedNode.style.height = height + 'px';
            
            const item = workflow.items[selectedNode.id];
            if (item) {
                item.width = width;
                item.height = height;
            }
            
            updateLinks();
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', handleResize);
            document.removeEventListener('mouseup', stopResize);
            autoSave();
        }

        // Context menu
        function handleContextMenu(e) {
            e.preventDefault();
            
            // Don't show context menu while panning or just after panning
            if (isPanning || (panStart.x !== 0 || panStart.y !== 0)) return;
            
            const targetElement = e.target;
            const groupNode = targetElement.closest('.node.group');
            const anyNode = targetElement.closest('.node');
            
            // Show context menu if we're not clicking on a node (except groups which allow right-click inside)
            if (!anyNode || groupNode) {
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate position in viewport coordinates accounting for zoom/pan
                contextMenuPos = {
                    x: (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale,
                    y: (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale
                };
                
                // Store the group ID if we're right-clicking inside a group
                contextMenuPos.groupId = groupNode ? groupNode.id : null;
                
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.style.display = 'block';
            }
        }

        // Pan and Zoom
        function handleWheel(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.min(Math.max(0.2, scale * delta), 3);
            
            if (newScale !== scale) {
                const canvasRect = canvas.getBoundingClientRect();
                
                // Get mouse position relative to canvas
                const mouseX = e.clientX - canvasRect.left;
                const mouseY = e.clientY - canvasRect.top;
                
                // Calculate the point in the viewport that the mouse is over
                const viewportX = (mouseX + canvas.scrollLeft - translateX) / scale;
                const viewportY = (mouseY + canvas.scrollTop - translateY) / scale;
                
                // Update scale
                const oldScale = scale;
                scale = newScale;
                
                // Calculate new translate values to keep the point under the mouse stationary
                translateX = mouseX + canvas.scrollLeft - viewportX * scale;
                translateY = mouseY + canvas.scrollTop - viewportY * scale;
                
                updateViewportTransform();
            }
        }

        function handlePanStart(e) {
            // Check if we clicked on a node or its children
            const clickedNode = e.target.closest('.node');
            const clickedLink = e.target.closest('.link, .link-clickable');
            
            // Allow panning with left click on canvas/viewport (not on nodes or links), middle button, or shift+left
            if ((e.button === 0 && !clickedNode && !clickedLink) || 
                e.button === 1 || 
                (e.button === 0 && e.shiftKey)) {
                e.preventDefault();
                panStart = { x: e.clientX, y: e.clientY };
                panStartTime = Date.now();
                // Don't set isPanning immediately - wait for actual movement
            }
        }

        function handlePan(e) {
            if (!panStart.x && !panStart.y) return;
            
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Only start panning if moved beyond threshold
            if (!isPanning && distance > panThreshold) {
                isPanning = true;
                canvas.style.cursor = 'grabbing';
                viewport.style.cursor = 'grabbing';
                canvas.classList.add('panning');
                viewport.classList.add('panning');
            }
            
            if (isPanning) {
                canvas.scrollLeft -= dx;
                canvas.scrollTop -= dy;
                panStart = { x: e.clientX, y: e.clientY };
            }
        }

        function handlePanEnd(e) {
            const wasPanning = isPanning;
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
                viewport.style.cursor = 'grab';
                canvas.classList.remove('panning');
                viewport.classList.remove('panning');
                autoSave(); // Save scroll position after panning
            }
            panStart = { x: 0, y: 0 };
            
            // If it was a quick click without much movement, treat it as a click
            if (!wasPanning && Date.now() - panStartTime < 200) {
                handleCanvasClick(e);
            }
        }

        function updateViewportTransform() {
            viewport.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
            zoomIndicator.textContent = Math.round(scale * 100) + '%';
            
            // Don't transform the SVG - it's already inside the transformed viewport
            updateLinks();
            autoSave();
        }

        function handleCanvasClick(e) {
            // Skip if this was called from a pan operation
            if (panStart.x !== 0 || panStart.y !== 0) return;
            
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
            }
            
            const clickedNode = e.target.closest('.node');
            
            if (!clickedNode) {
                if (selectedNode) {
                    selectedNode.classList.remove('selected');
                    selectedNode = null;
                }
                
                // Update context position for pasting
                const canvasRect = canvas.getBoundingClientRect();
                contextMenuPos = {
                    x: (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale,
                    y: (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale,
                    groupId: null
                };
            }
        }

        function handleMenuClick(e) {
            const menuItem = e.target.closest('.menu-item');
            if (!menuItem) return;
            
            const action = menuItem.dataset.action;
            contextMenu.style.display = 'none';
            
            if (action === 'paste') {
                // Trigger paste at the context menu position
                navigator.clipboard.readText().then(text => {
                    if (text) {
                        const id = `item-${workflow.nextItemId++}`;
                        const pasteItem = {
                            id: id,
                            type: 'data',
                            x: contextMenuPos.x,
                            y: contextMenuPos.y,
                            width: 300,
                            height: 200,
                            data: {
                                title: 'Pasted Text',
                                dataType: 'text',
                                content: text
                            },
                            parentId: null
                        };
                        
                        workflow.items[id] = pasteItem;
                        createNode(pasteItem);
                        autoSave();
                    }
                }).catch(err => {
                    console.log('Paste from context menu requires clipboard permissions');
                });
                
                // Clear group context
                contextMenuPos.groupId = null;
                return;
            }
            
            let type = null;
            switch (action) {
                case 'add-scribble': type = 'scribble'; break;
                case 'add-task': type = 'task'; break;
                case 'add-group': type = 'group'; break;
                case 'add-estimator': type = 'estimator'; break;
                case 'add-knowledge-section': type = 'knowledge-section'; break;
                case 'add-knowledge-subsection': type = 'knowledge-subsection'; break;
                case 'add-knowledge-item': type = 'knowledge-item'; break;
                case 'add-adr': type = 'adr'; break;
            }
            
            if (type) {
                addNode(type, contextMenuPos.x, contextMenuPos.y);
            }
            
            // Clear group context after use
            contextMenuPos.groupId = null;
        }

        // Add new node
        function addNode(type, x, y) {
            const id = `item-${workflow.nextItemId++}`;
            const defaultData = {
                title: type.charAt(0).toUpperCase() + type.slice(1).replace('-', ' '),
                content: '',
                isExpanded: false
            };
            
            // Type-specific defaults
            if (type === 'task') {
                Object.assign(defaultData, {
                    description: '',
                    complexity: 3,
                    risk: 0.1,
                    priority: 3,
                    duration: 1
                });
            } else if (type === 'estimator') {
                Object.assign(defaultData, {
                    teamMembers: 5,
                    workingHours: 8,
                    overhead: 0.15,
                    productivity: 0.85,
                    learningCurve: 1.0,
                    hoursPerStoryPoint: 4
                });
            } else if (type === 'adr') {
                Object.assign(defaultData, {
                    code: '',
                    category: '',
                    topic: ''
                });
            } else if (type === 'group') {
                defaultData.children = [];
                groups[id] = [];
            }
            
            const item = {
                id: id,
                type: type,
                x: x,
                y: y,
                width: 300,
                height: 200,
                data: defaultData,
                parentId: contextMenuPos.groupId || null
            };
            
            workflow.items[id] = item;
            
            // If adding to a group, update the group's children
            if (contextMenuPos.groupId) {
                if (!groups[contextMenuPos.groupId]) {
                    groups[contextMenuPos.groupId] = [];
                }
                groups[contextMenuPos.groupId].push(id);
                
                // Update the group's data
                if (workflow.items[contextMenuPos.groupId]) {
                    workflow.items[contextMenuPos.groupId].data.children = groups[contextMenuPos.groupId];
                }
                
                // Re-render the group to show the new child
                const groupNode = document.getElementById(contextMenuPos.groupId);
                if (groupNode) {
                    const groupContent = groupNode.querySelector('.node-content');
                    groupContent.innerHTML = createGroupContent(workflow.items[contextMenuPos.groupId]);
                    setupInputListeners(groupNode, workflow.items[contextMenuPos.groupId]);
                }
            } else {
                // Only create the node element if it's not in a group
                createNode(item);
            }
            
            updateLinks();
            autoSave();
        }

        // Delete node
        function deleteNode(nodeId) {
            const node = document.getElementById(nodeId);
            if (node) node.remove();
            
            const item = workflow.items[nodeId];
            
            // If it's a group, also delete its children
            if (item && item.type === 'group') {
                const children = groups[nodeId] || item.data.children || [];
                children.forEach(childId => {
                    deleteNode(childId);
                });
            }
            
            // Remove from expanded inline nodes
            delete expandedInlineNodes[nodeId];
            
            delete workflow.items[nodeId];
            
            // Remove from groups and update parent's children array
            Object.keys(groups).forEach(groupId => {
                groups[groupId] = groups[groupId].filter(id => id !== nodeId);
                if (workflow.items[groupId]) {
                    workflow.items[groupId].data.children = groups[groupId];
                }
            });
            
            // Remove related links
            workflow.links = workflow.links.filter(link => 
                link.sourceId !== nodeId && link.targetId !== nodeId
            );
            
            updateLinks();
            autoSave();
        }

        // Fixed Links update function
        function updateLinks() {
            // Clear existing paths but keep the defs
            const existingPaths = linksSvg.querySelectorAll('path');
            existingPaths.forEach(path => path.remove());
            
            // Ensure defs exist
            if (!linksSvg.querySelector('defs')) {
                linksSvg.innerHTML = '<defs><marker id="arrowhead" markerWidth="12" markerHeight="12" refX="11" refY="4" orient="auto"><polygon points="0 0, 12 4, 0 8" class="link-arrow"/></marker></defs>';
            }
            
            // Set SVG size to match viewport
            linksSvg.setAttribute('width', '8000');
            linksSvg.setAttribute('height', '8000');
            
            // Get all visible nodes as obstacles (in unscaled coordinates)
            const obstacles = [];
            Object.values(workflow.items).forEach(item => {
                if (!item.parentId) { // Only consider top-level nodes
                    const node = document.getElementById(item.id);
                    if (node && node.style.display !== 'none') {
                        obstacles.push({
                            left: item.x,
                            top: item.y,
                            right: item.x + item.width,
                            bottom: item.y + item.height,
                            id: item.id
                        });
                    }
                }
            });
            
            // Draw links
            workflow.links.forEach(link => {
                const source = document.getElementById(link.sourceId);
                const target = document.getElementById(link.targetId);
                
                if (!source || !target) return;
                
                // Skip hidden nodes
                if (source.style.display === 'none' || target.style.display === 'none') return;
                
                const sourceItem = workflow.items[link.sourceId];
                const targetItem = workflow.items[link.targetId];
                
                if (!sourceItem || !targetItem) return;
                
                // Calculate connection points (in unscaled coordinates)
                const startPoint = {
                    x: sourceItem.x + sourceItem.width / 2,
                    y: sourceItem.y + sourceItem.height
                };
                const endPoint = {
                    x: targetItem.x + targetItem.width / 2,
                    y: targetItem.y
                };
                
                // Find path avoiding obstacles (but not the source and target)
                const relevantObstacles = obstacles.filter(obs => 
                    obs.id !== link.sourceId && obs.id !== link.targetId
                );
                
                const pathPoints = findPath(startPoint, endPoint, relevantObstacles);
                
                // Create SVG path
                let pathString = `M ${pathPoints[0].x} ${pathPoints[0].y}`;
                for (let i = 1; i < pathPoints.length; i++) {
                    pathString += ` L ${pathPoints[i].x} ${pathPoints[i].y}`;
                }
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('link');
                path.setAttribute('d', pathString);
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.dataset.linkId = link.id;
                
                // Create invisible wider path for easier clicking
                const clickPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickPath.setAttribute('d', pathString);
                clickPath.classList.add('link-clickable');
                
                // Add click handler to delete link
                const deleteLink = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete this connection?')) {
                        workflow.links = workflow.links.filter(l => l.id !== link.id);
                        updateLinks();
                        autoSave();
                    }
                };
                
                path.addEventListener('click', deleteLink);
                clickPath.addEventListener('click', deleteLink);
                
                linksSvg.appendChild(clickPath);
                linksSvg.appendChild(path);
            });
        }

        // Input listeners
        function setupInputListeners(node, item) {
            const inputs = node.querySelectorAll('input, select, textarea');
            
            inputs.forEach(input => {
                input.addEventListener('change', () => {
                    updateItemData(item);
                    
                    // If it's an estimator, recalculate
                    if (item.type === 'estimator') {
                        calculateEstimates();
                    }
                    
                    autoSave();
                });
                
                // Prevent drag when interacting with inputs
                input.addEventListener('mousedown', e => e.stopPropagation());
            });
            
            // Setup listeners for group child icons
            if (item.type === 'group') {
                const childIcons = node.querySelectorAll('.group-child-icon');
                childIcons.forEach(icon => {
                    icon.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        const childId = icon.dataset.childId;
                        toggleInlineNode(childId, item.id);
                    });
                });
            }
        }

        function updateItemData(item) {
            const node = document.getElementById(item.id) || document.getElementById(`inline-${item.id}`);
            if (!node) return;
            
            switch (item.type) {
                case 'scribble':
                    item.data.content = node.querySelector('.scribble-content')?.value;
                    break;
                    
                case 'task':
                    item.data.complexity = node.querySelector('.complexity')?.value;
                    item.data.risk = node.querySelector('.risk')?.value;
                    item.data.priority = node.querySelector('.priority')?.value;
                    item.data.duration = node.querySelector('.duration')?.value;
                    break;
                    
                case 'estimator':
                    item.data.teamMembers = node.querySelector('.team-members')?.value;
                    item.data.workingHours = node.querySelector('.working-hours')?.value;
                    item.data.overhead = node.querySelector('.overhead')?.value;
                    item.data.productivity = node.querySelector('.productivity')?.value;
                    item.data.learningCurve = node.querySelector('.learning-curve')?.value;
                    item.data.hoursPerStoryPoint = node.querySelector('.hours-per-sp')?.value;
                    break;
                    
                case 'data':
                    const textarea = node.querySelector('.data-text');
                    if (textarea) {
                        item.data.content = textarea.value;
                    }
                    break;
                    
                case 'knowledge-section':
                case 'knowledge-subsection':
                case 'knowledge-item':
                    item.data.content = node.querySelector('.knowledge-content')?.value;
                    break;
                    
                case 'adr':
                    item.data.code = node.querySelector('.adr-code')?.value;
                    item.data.category = node.querySelector('.adr-category')?.value;
                    item.data.topic = node.querySelector('.adr-topic')?.value;
                    break;
            }
        }

        // Estimator calculations
        function calculateEstimates() {
            const estimator = Object.values(workflow.items).find(item => item.type === 'estimator');
            if (!estimator) return;
            
            const estimatorNode = document.getElementById(estimator.id);
            if (!estimatorNode) return;
            
            let totalBaseSP = 0;
            let totalAdjustedSP = 0;
            
            // Calculate from all visible tasks
            Object.values(workflow.items).filter(item => {
                if (item.type !== 'task') return false;
                const node = document.getElementById(item.id);
                return node && node.style.display !== 'none';
            }).forEach(task => {
                const complexity = parseFloat(task.data.complexity) || 0;
                const risk = parseFloat(task.data.risk) || 0;
                const duration = parseFloat(task.data.duration) || 0;
                
                totalBaseSP += complexity;
                
                const riskAdjustment = risk;
                const durationUncertainty = 0.1 * Math.log(1 + Math.max(0, duration));
                const Fi = (1 + riskAdjustment) * (1 + durationUncertainty);
                const adjustedSP = complexity * Fi;
                
                const baseTestFactor = 0.15;
                const riskTestFactor = 0.20;
                const testingEffort = adjustedSP * (baseTestFactor + riskTestFactor * risk);
                
                totalAdjustedSP += adjustedSP + testingEffort;
            });
            
            // Calculate velocity
            const R = parseInt(estimator.data.teamMembers) || 0;
            const D = parseFloat(estimator.data.workingHours) || 0;
            const O = parseFloat(estimator.data.overhead) || 0;
            const P = parseFloat(estimator.data.productivity) || 0;
            const L = parseFloat(estimator.data.learningCurve) || 0;
            const H = parseFloat(estimator.data.hoursPerStoryPoint) || 0;
            
            const efficiencyFactor = (O >= 0 && O < 1) ? 1 - O : 0;
            const effectiveHoursPerDay = R * D * efficiencyFactor * P * L;
            
            let teamVelocity = 0;
            let duration = 'N/A';
            
            if (H > 0 && effectiveHoursPerDay > 0) {
                teamVelocity = effectiveHoursPerDay / H;
                
                if (totalAdjustedSP > 0 && teamVelocity > 0) {
                    duration = (totalAdjustedSP / teamVelocity).toFixed(1);
                }
            }
            
            // Update display
            estimatorNode.querySelector('.base-sp').textContent = totalBaseSP.toFixed(2);
            estimatorNode.querySelector('.adj-sp').textContent = totalAdjustedSP.toFixed(2);
            estimatorNode.querySelector('.velocity').textContent = teamVelocity.toFixed(2);
            estimatorNode.querySelector('.duration').textContent = duration;
        }

        // Paste handling
        function handlePaste(e) {
            const activeElement = document.activeElement;
            if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') return;
            
            const items = e.clipboardData.items;
            
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const id = `item-${workflow.nextItemId++}`;
                        
                        // Use last click position or center of visible area
                        const canvasRect = canvas.getBoundingClientRect();
                        const defaultX = (canvasRect.width / 2 + canvas.scrollLeft - translateX) / scale;
                        const defaultY = (canvasRect.height / 2 + canvas.scrollTop - translateY) / scale;
                        
                        const pasteItem = {
                            id: id,
                            type: 'data',
                            x: contextMenuPos.x || defaultX,
                            y: contextMenuPos.y || defaultY,
                            width: 300,
                            height: 200,
                            data: {
                                title: 'Pasted Image',
                                dataType: 'image',
                                content: event.target.result
                            },
                            parentId: contextMenuPos.groupId || null
                        };
                        
                        workflow.items[id] = pasteItem;
                        
                        // Handle group paste
                        if (contextMenuPos.groupId) {
                            if (!groups[contextMenuPos.groupId]) {
                                groups[contextMenuPos.groupId] = [];
                            }
                            groups[contextMenuPos.groupId].push(id);
                            
                            // Update the group's data
                            if (workflow.items[contextMenuPos.groupId]) {
                                workflow.items[contextMenuPos.groupId].data.children = groups[contextMenuPos.groupId];
                            }
                            
                            // Re-render the group
                            const groupNode = document.getElementById(contextMenuPos.groupId);
                            if (groupNode) {
                                const groupContent = groupNode.querySelector('.node-content');
                                groupContent.innerHTML = createGroupContent(workflow.items[contextMenuPos.groupId]);
                                setupInputListeners(groupNode, workflow.items[contextMenuPos.groupId]);
                            }
                        } else {
                            createNode(pasteItem);
                        }
                        
                        autoSave();
                    };
                    
                    reader.readAsDataURL(blob);
                    return;
                }
                
                if (item.type === 'text/plain') {
                    e.preventDefault();
                    item.getAsString((text) => {
                        const id = `item-${workflow.nextItemId++}`;
                        
                        // Use last click position or center of visible area
                        const canvasRect = canvas.getBoundingClientRect();
                        const defaultX = (canvasRect.width / 2 + canvas.scrollLeft - translateX) / scale;
                        const defaultY = (canvasRect.height / 2 + canvas.scrollTop - translateY) / scale;
                        
                        const pasteItem = {
                            id: id,
                            type: 'data',
                            x: contextMenuPos.x || defaultX,
                            y: contextMenuPos.y || defaultY,
                            width: 300,
                            height: 200,
                            data: {
                                title: 'Pasted Text',
                                dataType: 'text',
                                content: text
                            },
                            parentId: contextMenuPos.groupId || null
                        };
                        
                        workflow.items[id] = pasteItem;
                        
                        // Handle group paste
                        if (contextMenuPos.groupId) {
                            if (!groups[contextMenuPos.groupId]) {
                                groups[contextMenuPos.groupId] = [];
                            }
                            groups[contextMenuPos.groupId].push(id);
                            
                            // Update the group's data
                            if (workflow.items[contextMenuPos.groupId]) {
                                workflow.items[contextMenuPos.groupId].data.children = groups[contextMenuPos.groupId];
                            }
                            
                            // Re-render the group
                            const groupNode = document.getElementById(contextMenuPos.groupId);
                            if (groupNode) {
                                const groupContent = groupNode.querySelector('.node-content');
                                groupContent.innerHTML = createGroupContent(workflow.items[contextMenuPos.groupId]);
                                setupInputListeners(groupNode, workflow.items[contextMenuPos.groupId]);
                            }
                        } else {
                            createNode(pasteItem);
                        }
                        
                        autoSave();
                    });
                }
            }
        }

        // View controls
        function fitToScreen() {
            if (Object.keys(workflow.items).length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            let hasVisibleNodes = false;
            
            Object.values(workflow.items).forEach(item => {
                if (!item.parentId) { // Only consider top-level nodes
                    hasVisibleNodes = true;
                    minX = Math.min(minX, item.x);
                    minY = Math.min(minY, item.y);
                    maxX = Math.max(maxX, item.x + item.width);
                    maxY = Math.max(maxY, item.y + item.height);
                }
            });
            
            if (hasVisibleNodes) {
                const padding = 50;
                canvas.scrollLeft = Math.max(0, minX - padding);
                canvas.scrollTop = Math.max(0, minY - padding);
            }
        }

        function resetView() {
            canvas.scrollLeft = 0;
            canvas.scrollTop = 0;
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateViewportTransform();
        }

        // Keyboard shortcuts
        function handleKeyboard(e) {
            const activeElement = document.activeElement;
            if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true') return;
            
            // Zoom shortcuts with Ctrl/Cmd
            if (e.ctrlKey || e.metaKey) {
                if (e.key === '+' || e.key === '=') {
                    e.preventDefault();
                    scale = Math.min(3, scale * 1.1);
                    updateViewportTransform();
                } else if (e.key === '-') {
                    e.preventDefault();
                    scale = Math.max(0.2, scale * 0.9);
                    updateViewportTransform();
                } else if (e.key === '0') {
                    e.preventDefault();
                    scale = 1;
                    translateX = 0;
                    translateY = 0;
                    updateViewportTransform();
                }
            }
            
            // Delete key for selected node
            if (e.key === 'Delete' && selectedNode) {
                const item = workflow.items[selectedNode.id];
                if (item && confirm('Delete this node?')) {
                    deleteNode(selectedNode.id);
                }
            }
        }

        // Utility functions
        function hasExpandableContent(item) {
            return item.type === 'scribble' ||
                   item.type === 'group' || 
                   item.type === 'task' ||
                   item.type === 'estimator' ||
                   item.type === 'adr' ||
                   item.type.startsWith('knowledge-') ||
                   item.type === 'data';
        }

        // Initialize with saved workflow or empty
        if (!loadFromLocalStorage()) {
            renderWorkflow();
            updateViewportTransform();
        }
    </script>
</body>
</html>
