<!DOCTYPE html>
<html>
<head>
    <title>Agile Project Estimator - Canvas</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
            background-color: #f0f0f0;
        }

        #canvas {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #e8e8e8;
            background-image: linear-gradient(rgba(0, 0, 0, 0.04) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 0, 0, 0.04) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden; /* Hide overflow content */
            cursor: default; /* Default cursor for canvas */
        }

        /* --- Tiles --- */
        .tile {
            position: absolute;
            background-color: #ffffe0; /* Light yellow sticky note */
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            border-radius: 3px;
            cursor: grab;
            min-width: 250px;
            max-width: 350px;
            z-index: 10;
            transition: box-shadow 0.2s ease-in-out;
        }

        .tile.selected {
            box-shadow: 0 0 10px 4px #007bff; /* Glowing blue border */
            z-index: 11; /* Bring selected tile to front */
        }

        .tile:active {
             cursor: grabbing;
        }

        .tile h3, .tile h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .tile h3 .tile-title {
             cursor: text;
             flex-grow: 1;
             margin-right: 10px;
        }
        .tile h3 .delete-btn {
            font-size: 1.2em;
            cursor: pointer;
            color: #aaa;
            padding: 0 5px;
        }
        .tile h3 .delete-btn:hover {
            color: #dc3545;
        }


        .tile label {
            display: flex;
            align-items: center;
            margin-top: 8px;
            font-size: 0.9em;
        }

        .tile label span {
            width: 110px; /* Smaller labels inside tiles */
            margin-right: 5px;
            color: #555;
            white-space: nowrap;
        }

        .tile input[type="number"], .tile select, .tile input[type="text"] {
            flex: 1;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9em;
        }

        /* Estimator Tile Specifics */
        #estimator-tile h4 {
            font-size: 1em;
            margin-bottom: 8px;
            border-bottom: none;
        }
        #estimator-tile p {
            margin: 4px 0;
            font-size: 0.95em;
        }
         #estimator-tile strong {
             font-weight: bold;
             color: #0056b3;
         }
         #estimator-tile .result {
             margin-top: 15px;
             padding-top: 10px;
             border-top: 1px solid #eee;
             font-size: 1.1em;
             font-weight: bold;
             color: #004085;
         }

        /* --- Context Menu --- */
        #context-menu {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
            padding: 5px 0;
            min-width: 150px;
            z-index: 100;
            display: none; /* Hidden by default */
            border-radius: 4px;
        }

        #context-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #context-menu ul li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.95em;
            position: relative; /* For submenu positioning */
        }

        #context-menu ul li:hover {
            background-color: #f0f0f0;
        }
        #context-menu ul li.has-submenu::after {
            content: '▶';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: #888;
        }

        /* Submenu */
        #context-menu ul ul {
            position: absolute;
            left: 100%;
            top: -5px; /* Align top edge with parent li's padding */
            display: none; /* Hidden by default */
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 3px 3px 8px rgba(0,0,0,0.15);
            padding: 5px 0;
            min-width: 200px; /* Wider submenu */
            border-radius: 4px;
        }

        #context-menu ul li:hover > ul {
            display: block; /* Show on hover */
        }

        /* --- SVG Arrows --- */
        #arrow-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 5; /* Behind tiles */
        }

        .arrow {
            stroke: #666;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

    </style>
</head>
<body>

<div id="canvas">
    <!-- Tiles will be added here dynamically -->
    <svg id="arrow-layer">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7"
            refX="0" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
            </marker>
        </defs>
        <!-- Arrow paths will be added here -->
    </svg>
</div>

<div id="context-menu">
    <ul>
        <li id="add-general-task">General Task</li>
        <li id="add-preset-task" class="has-submenu">
            Presets
            <ul id="preset-submenu">
                <!-- Preset tasks will be populated here -->
            </ul>
        </li>
        <li id="add-estimator">Estimator</li>
    </ul>
</div>

<!-- Templates (Hidden) -->
<template id="task-template">
    <div class="tile task" id="">
        <h3>
            <span class="tile-title" contenteditable="true">New Task</span>
            <span class="delete-btn" title="Delete Task">×</span>
        </h3>
        <label><span>Complexity (SP):</span>
            <select class="complexity">
                <!-- Options added dynamically -->
            </select>
        </label>
        <label><span>Risk Factor (0-1):</span>
            <input type="number" step="0.05" min="0" max="1" class="risk" value="0.1">
        </label>
        <label><span>Priority (1-5):</span>
            <input type="number" class="priority" value="3" min="1" max="5" step="1">
        </label>
        <label><span>Base Duration (days):</span>
            <input type="number" step="0.5" min="0.5" class="duration" value="1">
        </label>
    </div>
</template>

<template id="estimator-template">
     <div class="tile estimator" id="estimator-tile">
        <h3>
            <span>Project Estimator</span>
            <span class="delete-btn" title="Delete Estimator">×</span>
        </h3>
        <h4>Team & Project Factors</h4>
        <label><span>Team Members (R):</span>
            <input type="number" id="team-members" value="5" min="1">
        </label>
        <label><span>Hours/Day/Member (D):</span>
            <input type="number" id="working-hours" value="8" min="1" step="0.5">
        </label>
        <label><span>Overhead Factor (O):</span>
            <input type="number" step="0.01" id="overhead" value="0.15" min="0" max="0.99">
        </label>
        <label><span>Productivity (P):</span>
            <input type="number" step="0.01" id="productivity" value="0.85" min="0.1" max="1.5">
        </label>
         <label><span>Maturity/Learn (L):</span>
            <input type="number" step="0.05" id="learning-curve" value="1.0" min="0.5">
        </label>
        <label><span>Hours per SP (H):</span>
            <input type="number" step="0.1" id="hours-per-story-point" value="4" min="0.5">
        </label>
        <div class="result">
            <p>Total Base SP: <strong id="result-base-sp">0</strong></p>
            <p>Total Adjusted SP: <strong id="result-adj-sp">0</strong></p>
            <p>Team Velocity (SP/day): <strong id="result-velocity">0</strong></p>
            <p>Est. Duration (days): <strong id="result-duration">N/A</strong></p>
        </div>
    </div>
</template>


<script>
    const canvas = document.getElementById('canvas');
    const contextMenu = document.getElementById('context-menu');
    const taskTemplate = document.getElementById('task-template');
    const estimatorTemplate = document.getElementById('estimator-template');
    const svgLayer = document.getElementById('arrow-layer');
    const presetSubmenu = document.getElementById('preset-submenu');

    let items = {}; // Store data for all items { id: {type, x, y, data, element} }
    let links = []; // Store link data { id, sourceId, targetId }
    let selectedItemId = null;
    let nextItemId = 1;
    let nextLinkId = 1;
    let isShiftDown = false;

    const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
    const commonTasks = [ // Keep these for presets
        { title: "API Endpoint", complexity: 5, risk: 0.2, priority: 5, duration: 3 },
        { title: "Swagger Docs", complexity: 2, risk: 0.1, priority: 3, duration: 1 },
        { title: "Auth (OAuth2)", complexity: 8, risk: 0.3, priority: 5, duration: 5 },
        { title: "Authorization", complexity: 5, risk: 0.25, priority: 5, duration: 3 },
        { title: "DB Schema", complexity: 3, risk: 0.15, priority: 5, duration: 2 },
        { title: "CRUD Ops", complexity: 5, risk: 0.15, priority: 5, duration: 3 },
        { title: "Unit Tests", complexity: 5, risk: 0.1, priority: 4, duration: 3 },
        { title: "Integration Tests", complexity: 8, risk: 0.2, priority: 4, duration: 4 },
        // Add more presets if needed
    ];

    // --- Initialization ---

    function initialize() {
        populatePresets();
        setupCanvasListeners();
        setupGlobalListeners();
    }

    function populatePresets() {
        presetSubmenu.innerHTML = '';
        commonTasks.forEach((task, index) => {
            const li = document.createElement('li');
            li.textContent = task.title;
            li.dataset.presetIndex = index;
            li.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent canvas click
                const preset = commonTasks[index];
                const coords = { x: contextMenu.offsetLeft, y: contextMenu.offsetTop };
                addItem('task', coords, preset);
                hideContextMenu();
            });
            presetSubmenu.appendChild(li);
        });
    }

    function setupCanvasListeners() {
        canvas.addEventListener('click', (e) => {
            // Only show context menu if clicking directly on canvas, not a tile
            if (e.target === canvas) {
                showContextMenu(e.clientX, e.clientY);
                deselectAllItems(); // Deselect any selected item when clicking canvas
            } else {
                hideContextMenu(); // Hide if clicking elsewhere (like inside a tile input)
            }
        });
         // Prevent default browser context menu on the canvas
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
             if (e.target === canvas) {
                showContextMenu(e.clientX, e.clientY);
                deselectAllItems();
            } else {
                 hideContextMenu();
             }
        });
    }

     function setupGlobalListeners() {
        document.addEventListener('keydown', (e) => {
            isShiftDown = e.shiftKey;

            if (e.code === 'Space' && selectedItemId && items[selectedItemId]?.type === 'task') {
                e.preventDefault(); // Prevent page scroll
                createAssociatedTask(selectedItemId);
            } else if (e.code === 'Delete' && selectedItemId) {
                 e.preventDefault();
                 deleteItem(selectedItemId);
            }

            // Update cursor style based on shift key for draggable items
             Object.values(items).forEach(item => {
                 if (item.element) {
                     item.element.style.cursor = isShiftDown ? 'move' : 'grab';
                 }
             });
        });

        document.addEventListener('keyup', (e) => {
             if (!e.shiftKey) { // Check if shift was released
                isShiftDown = false;
                 Object.values(items).forEach(item => {
                    if (item.element) {
                        item.element.style.cursor = 'grab';
                    }
                });
            }
        });

        // Hide context menu if clicking anywhere else
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target) && e.target !== canvas) {
                hideContextMenu();
            }
        });
    }

    // --- Context Menu ---

    function showContextMenu(x, y) {
        // Adjust position if menu goes off-screen
        const menuWidth = contextMenu.offsetWidth;
        const menuHeight = contextMenu.offsetHeight;
        const bodyWidth = document.documentElement.clientWidth;
        const bodyHeight = document.documentElement.clientHeight;

        contextMenu.style.left = (x + menuWidth > bodyWidth ? bodyWidth - menuWidth - 5 : x) + 'px';
        contextMenu.style.top = (y + menuHeight > bodyHeight ? bodyHeight - menuHeight - 5 : y) + 'px';
        contextMenu.style.display = 'block';
    }

    function hideContextMenu() {
        contextMenu.style.display = 'none';
         // Hide submenus too
        const submenus = contextMenu.querySelectorAll('ul ul');
        submenus.forEach(submenu => submenu.style.display = 'none');
    }

    // --- Item Management ---

    function addItem(type, coords, presetData = null) {
        const newItemId = `item-${nextItemId++}`;
        let element;
        let itemData = {};

        if (type === 'task') {
            const taskNode = taskTemplate.content.cloneNode(true);
            element = taskNode.querySelector('.tile');
            element.id = newItemId;

            // Populate complexity dropdown
            const complexitySelect = element.querySelector('.complexity');
            fibonacciNumbers.forEach(num => {
                const option = document.createElement('option');
                option.value = num;
                option.text = num;
                complexitySelect.appendChild(option);
            });

            // Apply preset data if available
            if (presetData) {
                element.querySelector('.tile-title').textContent = presetData.title || 'Preset Task';
                complexitySelect.value = presetData.complexity || 3;
                element.querySelector('.risk').value = presetData.risk !== null ? presetData.risk : 0.1;
                element.querySelector('.priority').value = presetData.priority !== null ? presetData.priority : 3;
                element.querySelector('.duration').value = presetData.duration !== null ? presetData.duration : 1;
            } else {
                 element.querySelector('.tile-title').textContent = 'General Task';
                 complexitySelect.value = 3; // Default complexity
            }
            itemData = { title: element.querySelector('.tile-title').textContent, complexity: complexitySelect.value, risk: element.querySelector('.risk').value, priority: element.querySelector('.priority').value, duration: element.querySelector('.duration').value };

        } else if (type === 'estimator') {
            // Only allow one estimator tile
            if (document.getElementById('estimator-tile')) {
                 alert("Only one Estimator tile is allowed.");
                 return;
             }
            const estimatorNode = estimatorTemplate.content.cloneNode(true);
            element = estimatorNode.querySelector('.tile');
            element.id = 'estimator-tile'; // Fixed ID for easy access
            itemData = { // Store initial factor values
                 teamMembers: element.querySelector('#team-members').value,
                 workingHours: element.querySelector('#working-hours').value,
                 overhead: element.querySelector('#overhead').value,
                 productivity: element.querySelector('#productivity').value,
                 learningCurve: element.querySelector('#learning-curve').value,
                 hoursPerStoryPoint: element.querySelector('#hours-per-story-point').value
             };

        } else {
            return; // Unknown type
        }

        // Position the element
        element.style.left = `${coords.x}px`;
        element.style.top = `${coords.y}px`;

        canvas.appendChild(element);

        // Store item data
        items[newItemId] = {
            id: newItemId,
            type: type,
            x: coords.x,
            y: coords.y,
            data: itemData,
            element: element
        };

        setupTileInteraction(element);
        calculate(); // Recalculate estimations whenever an item is added
        return newItemId;
    }

     function deleteItem(itemId) {
        if (!items[itemId]) return;

        const itemElement = items[itemId].element;

        // Remove associated links
        links = links.filter(link => {
            if (link.sourceId === itemId || link.targetId === itemId) {
                const arrowElement = document.getElementById(`link-${link.id}`);
                if (arrowElement) arrowElement.remove();
                return false; // Remove this link
            }
            return true; // Keep other links
        });

        // Remove the item element and data
        if (itemElement) itemElement.remove();
        delete items[itemId];

        if (selectedItemId === itemId) {
            selectedItemId = null; // Clear selection if deleted item was selected
        }

        updateArrows(); // Redraw remaining arrows
        calculate(); // Recalculate estimations
    }

    function createAssociatedTask(sourceId) {
        if (!items[sourceId] || items[sourceId].type !== 'task') return;

        const sourceItem = items[sourceId];
        const sourceRect = sourceItem.element.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();

        // Calculate position for the new task (e.g., below the source)
        const newX = sourceItem.x;
        const newY = sourceItem.y + sourceRect.height + 40; // Add some vertical space

        // Create the new task (using default 'General Task' settings)
        const targetId = addItem('task', { x: newX, y: newY });

        if (targetId) {
            // Create the link
            const linkId = `link-${nextLinkId++}`;
            links.push({ id: linkId, sourceId: sourceId, targetId: targetId });
            updateArrows();
            selectItem(targetId); // Select the newly created task
        }
    }

    // --- Tile Interaction (Drag, Select, Edit) ---

    function setupTileInteraction(tileElement) {
        interact(tileElement)
            .draggable({
                allowFrom: '.tile h3', // Only allow dragging from title bar initially
                inertia: false,
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent', // Keep within canvas bounds
                        endOnly: true
                    })
                ],
                autoScroll: true,
                listeners: {
                    start(event) {
                         // Only drag if shift is held down
                        if (!isShiftDown) {
                            event.interaction.stop(); // Prevent dragging if shift is not pressed
                            return;
                        }
                        event.target.style.cursor = 'grabbing';
                        selectItem(event.target.id); // Select on drag start
                         event.target.classList.add('dragging'); // Optional: style during drag
                         bringToFront(event.target.id);
                    },
                    move(event) {
                         if (!isShiftDown) return; // Stop moving if shift released mid-drag

                        const target = event.target;
                        const itemId = target.id;
                        const item = items[itemId];

                        // Keep the dragged position in the data object
                        item.x += event.dx;
                        item.y += event.dy;

                        // Translate the element
                        target.style.transform = `translate(${item.x - parseFloat(target.style.left || 0)}px, ${item.y - parseFloat(target.style.top || 0)}px)`;
                        target.style.left = `${item.x}px`; // Update final position too
                        target.style.top = `${item.y}px`;

                        updateArrows(); // Update arrows during drag
                    },
                    end(event) {
                        event.target.style.cursor = isShiftDown ? 'move' : 'grab';
                         event.target.classList.remove('dragging');
                         // Reset transform after drag, position is set via left/top
                         event.target.style.transform = 'none';
                    }
                }
            });

        // Selection Click Listener
        tileElement.addEventListener('click', (e) => {
             e.stopPropagation(); // Prevent canvas click
             selectItem(tileElement.id);
             hideContextMenu();
        });

        // Delete Button Listener
         const deleteBtn = tileElement.querySelector('.delete-btn');
         if (deleteBtn) {
             deleteBtn.addEventListener('click', (e) => {
                 e.stopPropagation(); // Prevent tile selection click
                 if (confirm('Are you sure you want to delete this item?')) {
                      deleteItem(tileElement.id);
                 }
             });
         }

        // Title Edit Listener
         const titleSpan = tileElement.querySelector('.tile-title');
         if (titleSpan) {
             titleSpan.addEventListener('blur', () => {
                 if (items[tileElement.id] && items[tileElement.id].type === 'task') {
                     items[tileElement.id].data.title = titleSpan.textContent.trim();
                     // No recalculation needed for title change
                 }
             });
             // Prevent Enter key from creating new line in title
             titleSpan.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') {
                     e.preventDefault();
                     titleSpan.blur(); // Save on Enter
                 }
             });
         }


        // Listen for changes in inputs within the tile
        const inputs = tileElement.querySelectorAll('input, select');
        inputs.forEach(input => {
            input.addEventListener('change', () => {
                 updateItemData(tileElement.id);
                 calculate(); // Recalculate on any data change
            });
             input.addEventListener('click', e => e.stopPropagation()); // Prevent tile selection when clicking input
        });
    }

     function bringToFront(itemId) {
         if (!items[itemId]) return;
         const element = items[itemId].element;
         // Find highest z-index and increment
         let maxZ = 10;
         Object.values(items).forEach(item => {
            const z = parseInt(item.element.style.zIndex || '10');
            if (z > maxZ) maxZ = z;
         });
         element.style.zIndex = maxZ + 1;
     }


    function updateItemData(itemId) {
        if (!items[itemId]) return;
        const item = items[itemId];
        const element = item.element;

        if (item.type === 'task') {
            item.data.title = element.querySelector('.tile-title').textContent.trim();
            item.data.complexity = element.querySelector('.complexity').value;
            item.data.risk = element.querySelector('.risk').value;
            item.data.priority = element.querySelector('.priority').value;
            item.data.duration = element.querySelector('.duration').value;
        } else if (item.type === 'estimator') {
             item.data.teamMembers = element.querySelector('#team-members').value;
             item.data.workingHours = element.querySelector('#working-hours').value;
             item.data.overhead = element.querySelector('#overhead').value;
             item.data.productivity = element.querySelector('#productivity').value;
             item.data.learningCurve = element.querySelector('#learning-curve').value;
             item.data.hoursPerStoryPoint = element.querySelector('#hours-per-story-point').value;
        }
    }

    function selectItem(itemId) {
        if (selectedItemId === itemId) return; // Already selected

        deselectAllItems();

        if (items[itemId]) {
            items[itemId].element.classList.add('selected');
            selectedItemId = itemId;
             bringToFront(itemId); // Bring selected item visually to front
        }
    }

    function deselectAllItems() {
        if (selectedItemId && items[selectedItemId]) {
            items[selectedItemId].element.classList.remove('selected');
        }
        selectedItemId = null;
    }

    // --- Arrow Drawing ---

    function updateArrows() {
        // Clear existing arrows first
        svgLayer.querySelectorAll('.arrow').forEach(arrow => arrow.remove());

        links.forEach(link => {
            const sourceItem = items[link.sourceId];
            const targetItem = items[link.targetId];

            if (!sourceItem || !targetItem) return; // Skip if item is missing

            const sourceRect = sourceItem.element.getBoundingClientRect();
            const targetRect = targetItem.element.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect(); // Use canvas for offset calculation

            // Calculate connection points (simplified: center of sides)
            // Adjust points relative to the SVG layer's top-left corner
             const startX = sourceItem.x + sourceRect.width / 2 - canvasRect.left;
             const startY = sourceItem.y + sourceRect.height / 2 - canvasRect.top;
             const endX = targetItem.x + targetRect.width / 2 - canvasRect.left;
             const endY = targetItem.y + targetRect.height / 2 - canvasRect.top;

             // Simple Right-Angle Path (Horizontal then Vertical)
             // Calculate the 'elbow' point
             const midX = endX;
             const midY = startY;

             // Create the path string: M(start) L(elbow) L(end)
             // Offset end point slightly for arrowhead visibility
             const dx = endX - midX;
             const dy = endY - startY;
             const len = Math.sqrt(dx*dx + dy*dy);
             const arrowOffset = 5; // Offset to prevent arrowhead overlapping the center
             const finalEndX = endX - (dx / len) * arrowOffset;
             const finalEndY = endY - (dy / len) * arrowOffset;


             const pathData = `M ${startX},${startY} L ${midX},${midY} L ${finalEndX},${finalEndY}`;

             // Alternative Path (Vertical then Horizontal) - could switch based on relative positions
             // const altMidX = startX;
             // const altMidY = endY;
             // const altPathData = `M ${startX},${startY} L ${altMidX},${altMidY} L ${endX},${endY}`;


            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'arrow');
            path.setAttribute('id', `link-${link.id}`);
            svgLayer.appendChild(path);
        });
    }


    // --- Calculation Logic (Adapted from previous version) ---

    function calculate() {
        const estimatorTile = document.getElementById('estimator-tile');
        if (!estimatorTile) return; // No estimator, nothing to calculate

        let totalAdjustedStoryPoints = 0;
        let totalBaseStoryPoints = 0;

        // Iterate through items data, filter for tasks
        Object.values(items).filter(item => item.type === 'task').forEach(taskItem => {
             const data = taskItem.data;
             const complexity = parseFloat(data.complexity);
             const risk = parseFloat(data.risk);
             const priority = parseInt(data.priority);
             const duration = parseFloat(data.duration);

            // Validation (similar to before)
            if (isNaN(complexity) || isNaN(risk) || isNaN(priority) || isNaN(duration) ||
                complexity <= 0 || risk < 0 || risk > 1 || priority < 1 || priority > 5 || duration <= 0) {
                console.warn(`Skipping invalid task data: ${taskItem.id}`);
                return; // Skip this task's calculation
            }

            // Calculate Adjustment Factor (Fi)
            const riskAdjustment = risk;
            const durationUncertainty = 0.1 * Math.log(1 + duration);
            const Fi = (1 + riskAdjustment) * (1 + durationUncertainty);

            // Calculate Adjusted Story Points (ASP) for development
            const adjustedStoryPoints = complexity * Fi;
            totalBaseStoryPoints += complexity;

            // Calculate Testing Effort
            const baseTestFactor = 0.15;
            const riskTestFactor = 0.20;
            const testingEffort = adjustedStoryPoints * (baseTestFactor + riskTestFactor * risk);

            // Total effort for this task
            const taskTotalPoints = adjustedStoryPoints + testingEffort;
            totalAdjustedStoryPoints += taskTotalPoints;
        });

        // Get Team Factors from Estimator Tile Inputs
        const R = parseInt(estimatorTile.querySelector('#team-members').value) || 0;
        const D = parseFloat(estimatorTile.querySelector('#working-hours').value) || 0;
        const O = parseFloat(estimatorTile.querySelector('#overhead').value) || 0;
        const P = parseFloat(estimatorTile.querySelector('#productivity').value) || 0;
        const L = parseFloat(estimatorTile.querySelector('#learning-curve').value) || 0;
        const H = parseFloat(estimatorTile.querySelector('#hours-per-story-point').value) || 0;

        // Calculate Velocity and Duration
        const efficiencyFactor = 1 - O;
        const effectiveHoursPerDay = R * D * efficiencyFactor * P * L;
        let teamVelocity = 0;
        let totalDuration = NaN; // Use NaN for invalid states
        let durationText = "N/A";

        if (H > 0 && effectiveHoursPerDay > 0) {
            teamVelocity = effectiveHoursPerDay / H;
        }

        if (totalAdjustedStoryPoints > 0 && teamVelocity > 0) {
            totalDuration = totalAdjustedStoryPoints / teamVelocity;
            durationText = totalDuration.toFixed(1);
        } else if (totalAdjustedStoryPoints <= 0 && Object.values(items).some(item => item.type === 'task')) {
            durationText = "Check Task Inputs";
        } else if (totalAdjustedStoryPoints > 0 && teamVelocity <= 0) {
             durationText = "Check Team Factors";
        }


        // Update Estimator Tile Display
        estimatorTile.querySelector('#result-base-sp').textContent = totalBaseStoryPoints.toFixed(2);
        estimatorTile.querySelector('#result-adj-sp').textContent = totalAdjustedStoryPoints.toFixed(2);
        estimatorTile.querySelector('#result-velocity').textContent = teamVelocity > 0 ? teamVelocity.toFixed(2) : "N/A";
        estimatorTile.querySelector('#result-duration').textContent = durationText;
    }


    // --- Context Menu Actions ---
    document.getElementById('add-general-task').addEventListener('click', (e) => {
        e.stopPropagation();
        const coords = { x: contextMenu.offsetLeft, y: contextMenu.offsetTop };
        addItem('task', coords);
        hideContextMenu();
    });

     document.getElementById('add-estimator').addEventListener('click', (e) => {
        e.stopPropagation();
        const coords = { x: contextMenu.offsetLeft, y: contextMenu.offsetTop };
        addItem('estimator', coords);
        hideContextMenu();
    });

    // Prevent preset menu itself from closing main menu immediately
    document.getElementById('add-preset-task').addEventListener('click', (e) => {
        e.stopPropagation();
    });


    // --- Start the application ---
    initialize();

</script>

</body>
</html>
