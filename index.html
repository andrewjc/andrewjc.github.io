<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Knowledge Tree Workflow System</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            overflow: hidden;
            user-select: none;
        }

        /* Top Bar */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: linear-gradient(to right, #1e3c72, #2a5298);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        #topbar h1 {
            font-size: 18px;
            font-weight: 500;
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #topbar button {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-left: 8px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        #topbar button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }
        
        #topbar #clear-btn {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }
        
        #topbar #clear-btn:hover {
            background: rgba(220, 53, 69, 0.5);
        }

        input[type="file"] {
            display: none;
        }

        /* Canvas */
        #canvas {
            position: absolute;
            top: 48px;
            left: 0;
            right: 0;
            bottom: 24px;
            overflow: auto;
            background-color: #e8eaed;
            background-image: radial-gradient(circle, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: grab;
        }
        
        #canvas.panning {
            cursor: grabbing !important;
        }
        
        #canvas.linking {
            cursor: crosshair !important;
        }

        #viewport {
            position: relative;
            min-width: 100%;
            min-height: 100%;
            width: 8000px;
            height: 8000px;
            transform-origin: 0 0;
            transition: none;
        }
        
        #links-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0; /* Changed from 1 to 0 to ensure it renders behind nodes */
        }

        /* Base Node Styles */
        .node {
            position: absolute;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: default;
            transition: box-shadow 0.2s, transform 0.2s, border-color 0.2s, width 0.3s ease, height 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 200px;
            min-height: 100px;
            z-index: 2; /* Added to ensure nodes render above links */
        }

        .node:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            z-index: 3; /* Slightly higher on hover */
        }

        .node.selected {
            border-color: #1a73e8;
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2);
            z-index: 10;
        }
        
        .node.multi-selected {
            outline: 3px dashed #1a73e8;
            outline-offset: 2px;
            z-index: 9;
        }
        
        .node.link-source {
            border-color: #1a73e8 !important;
            border-width: 3px !important;
        }
        
        .node.link-target {
            border-color: #4caf50 !important;
            border-width: 3px !important;
        }
        
        .node.group.drop-target {
            border-color: #4caf50 !important;
            border-width: 3px !important;
            background: rgba(76, 175, 80, 0.05);
        }

        .node.dragging {
            opacity: 0.9;
            cursor: grabbing;
            z-index: 100;
            transition: none;
        }

        .node.resizing {
            opacity: 0.95;
            transition: none !important;
        }
        
        .node.resizing * {
            pointer-events: none;
        }

        /* Node Header */
        .node-header {
            padding: 10px 14px;
            background: linear-gradient(to bottom, #fafafa, #f5f5f5);
            border-bottom: 1px solid #e0e0e0;
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            flex-shrink: 0;
        }
        
        .node.group:not(.expanded) .node-header { display: none; }


        .node.dragging .node-header {
            cursor: grabbing;
        }

        .node-type-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .node-title {
            font-weight: 600;
            font-size: 14px;
            color: #202124;
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .node-title[contenteditable="true"] {
            background: rgba(26, 115, 232, 0.1);
            outline: 1px solid rgba(26, 115, 232, 0.5);
            cursor: text;
            user-select: text;
        }

        /* Node Controls */
        .node-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .node-control {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.2s;
            color: #5f6368;
        }

        .node-control:hover {
            background: rgba(0,0,0,0.08);
        }

        .view-control {
            font-size: 12px;
            padding: 0 4px;
            width: auto;
            min-width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.2s;
            color: #5f6368;
        }

        .view-control:hover {
            background: rgba(0,0,0,0.08);
        }

        .view-control.active {
            background: rgba(26, 115, 232, 0.1);
            color: #1a73e8;
        }

        .expand-icon {
            transition: transform 0.2s;
        }

        .node.expanded .expand-icon {
            transform: rotate(90deg);
        }

        /* Node Content */
        .node-content {
            padding: 12px;
            flex-grow: 1;
            overflow: auto;
            user-select: text;
            display: none;
            flex-direction: column;
        }

        .node.expanded .node-content {
            display: flex;
        }
        
        .node.group:not(.expanded) .node-content { display: none !important; }


        /* Node Type Specific Styles */
        .node.scribble { background: #fffef0; border-color: #f9cc30; }
        .node.scribble .node-header { background: linear-gradient(to bottom, #fff9c4, #fff59d); }
        .node.group { background: #e3f2fd; border-color: #2196f3; }
        .node.group .node-header { background: linear-gradient(to bottom, #bbdefb, #90caf9); }
        .node.group.expanded { min-width: 400px; min-height: 300px; }
        .node.task { background: #f3e5f5; border-color: #9c27b0; }
        .node.task .node-header { background: linear-gradient(to bottom, #e1bee7, #ce93d8); }
        .node.estimator { background: #e8f5e9; border-color: #4caf50; }
        .node.estimator .node-header { background: linear-gradient(to bottom, #c8e6c9, #a5d6a7); }
        .node.data { background: #fff3e0; border-color: #ff9800; }
        .node.data .node-header { background: linear-gradient(to bottom, #ffe0b2, #ffcc80); }
        .node.knowledge-section { background: #e0f2f1; border-color: #009688; }
        .node.knowledge-subsection { background: #e8eaf6; border-color: #3f51b5; }
        .node.knowledge-item { background: #fce4ec; border-color: #e91e63; }
        .node.adr { background: #efebe9; border-color: #795548; }

        /* Group Content Styles */
        .group-content {
            position: relative;
            min-height: 200px;
            padding: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-content: flex-start;
            overflow: visible;
        }
        
        .group-content.graph-view {
            position: relative;
            min-height: 300px;
            overflow: auto;
            background: #fafafa;
            border: 1px solid rgba(0,0,0,0.05);
            border-radius: 4px;
            padding: 0;
        }
        
        .node.inline-node .group-content.graph-view {
            min-height: 200px;
        }
        
        .group-content.list-view {
            flex-direction: column;
            gap: 8px;
            padding: 12px;
        }
        
        .group-graph-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 300px;
            overflow: auto;
            background: #fafafa;
            border-radius: 4px;
        }
        
        .node.inline-node .group-graph-viewport {
            min-height: 150px;
        }
        
        .group-graph-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: visible;
        }

        .group-icon-representation {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 8px;
            cursor: move;
        }

        .node.group:not(.expanded) {
            padding: 0;
            min-width: 90px !important;
            min-height: 100px !important;
            justify-content: center;
        }

        .node.group:not(.expanded) .group-icon-representation {
            display: flex;
        }

        .group-icon-representation-symbol {
            font-size: 32px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .group-icon-representation-title {
            font-size: 11px;
            text-align: center;
            color: #5f6368;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
            max-width: 80px;
            word-break: break-word;
        }


        .group-child-icon {
            width: 80px;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .group-child-icon:hover {
            background: rgba(255,255,255,1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        .group-child-icon-symbol {
            font-size: 32px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .group-child-icon-title {
            font-size: 11px;
            text-align: center;
            color: #5f6368;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
        }
        
        /* List View Styles */
        .group-list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .group-list-item:hover {
            background: rgba(255,255,255,1);
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            transform: translateX(2px);
        }
        
        .group-list-item-icon {
            font-size: 20px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .group-list-item-title {
            font-size: 13px;
            color: #202124;
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Inline Node Styles for Graph View */
        .node.inline-node {
            position: absolute !important;
            min-width: 120px !important;
            min-height: 60px !important;
            max-width: 200px !important;
            max-height: 150px !important;
            z-index: 1;
        }
        
        .node.inline-node.group {
            min-width: 200px !important;
            min-height: 150px !important;
            max-width: 400px !important;
            max-height: 350px !important;
        }
        
        .node.inline-node.group:not(.expanded) {
            min-width: 90px !important;
            min-height: 100px !important;
            max-width: 90px !important;
            max-height: 100px !important;
        }
        
        .node.inline-node .node-header {
            padding: 6px 10px;
            font-size: 12px;
        }
        
        .node.inline-node .node-type-icon {
            width: 16px;
            height: 16px;
            font-size: 14px;
        }
        
        .node.inline-node .node-title {
            font-size: 12px;
        }
        
        .node.inline-node .node-controls {
            gap: 2px;
        }
        
        .node.inline-node .node-control,
        .node.inline-node .view-control {
            width: 16px;
            height: 16px;
            font-size: 10px;
        }
        
        .node.inline-node .node-content {
            padding: 8px;
            font-size: 11px;
            max-height: 200px;
            overflow: auto;
        }
        
        .node.inline-node .resize-handle {
            display: none;
        }
        
        .node.inline-node.group .resize-handle {
            display: block;
            width: 12px;
            height: 12px;
        }
        
        .node.inline-node.expanded {
            max-width: 400px !important;
            max-height: 300px !important;
        }
        
        .node.inline-node.group.expanded {
            max-width: 500px !important;
            max-height: 400px !important;
        }
        
        /* Content Styles */
        .scribble-content, .data-text, .knowledge-content, .adr-content textarea {
            height: 100%;
            flex-grow: 1; /* Allow it to fill space */
            resize: none;
            width: 100%;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
            font-size: 13px;
            line-height: 1.5;
        }
        .scribble-content { background: transparent; border: none; outline: none; padding: 4px; }
        .data-text, .knowledge-content, .adr-content textarea { margin-top: 8px; }

        .task-content label { display: flex; align-items: center; margin-bottom: 8px; font-size: 13px; }
        .task-content label span { width: 120px; color: #5f6368; font-weight: 500; }
        .task-content input, .task-content select { flex: 1; padding: 4px 8px; border: 1px solid #dadce0; border-radius: 4px; font-size: 13px; }
        .task-description { font-size: 12px; color: #5f6368; margin-bottom: 12px; padding: 8px; background: rgba(0,0,0,0.03); border-radius: 4px; line-height: 1.5; }
        .estimator-content h4 { font-size: 14px; margin-bottom: 12px; color: #202124; }
        .estimator-result { margin-top: 16px; padding-top: 16px; border-top: 1px solid #e0e0e0; }
        .estimator-result p { margin: 4px 0; font-size: 13px; }
        .estimator-result strong { color: #1976d2; font-weight: 600; }
        .data-image { max-width: 100%; height: auto; display: block; border-radius: 4px; }
        .adr-content label { display: flex; align-items: flex-start; margin-bottom: 8px; font-size: 13px; }
        .adr-content label span { width: 80px; color: #5f6368; font-weight: 500; padding-top: 4px; }
        .adr-content input, .adr-content textarea { flex: 1; padding: 4px 8px; border: 1px solid #dadce0; border-radius: 4px; font-size: 13px; }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #bdbdbd 50%);
            border-radius: 0 0 6px 0;
            z-index: 1;
        }

        .node.group:not(.expanded) .resize-handle { display: none; }

        /* Links */
        .link {
            fill: none;
            stroke: currentColor;
            color: #9e9e9e;
            stroke-width: 2.5;
            opacity: 0.8;
            transition: all 0.2s;
            stroke-linejoin: round;
            stroke-linecap: round;
        }
        
        .link:hover {
            color: #1a73e8;
            stroke-width: 4;
            opacity: 1;
        }
        
        .link-clickable {
            fill: none;
            stroke: transparent;
            stroke-width: 16;
            cursor: pointer;
            pointer-events: stroke;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .link-arrow {
            fill: currentColor;
            color: #9e9e9e;
        }
        
        .group-graph-svg .link {
            stroke: #9e9e9e;
            stroke-width: 2;
            opacity: 0.8;
        }
        
        .group-graph-svg .link-arrow {
            fill: #9e9e9e;
        }

        /* Context Menu */
        #context-menu, #selection-context-menu, #item-context-menu {
            position: fixed;
            background: white;
            border: 1px solid #dadce0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 4px 0;
            min-width: 180px;
            z-index: 1001;
            display: none;
        }

        .menu-item { padding: 8px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .menu-item:hover { background: #f5f5f5; }
        .menu-separator { height: 1px; background: #e0e0e0; margin: 4px 0; }

        /* Loading */
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 24px 32px; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); display: none; z-index: 2000; }

        /* Info Panel */
        #info-panel { position: fixed; bottom: 36px; left: 16px; background: white; padding: 12px 16px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 12px; color: #5f6368; z-index: 500; display: flex; gap: 16px; }
        
        /* Zoom Indicator */
        #zoom-indicator { position: fixed; bottom: 36px; right: 16px; background: white; padding: 8px 12px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); font-size: 12px; color: #5f6368; z-index: 500; font-weight: 500; }
        
        /* Bottom Bar */
        #bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: #f5f5f5;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #757575;
            z-index: 499;
        }

        /* Selection Rectangle */
        #selection-rect {
            position: fixed;
            border: 2px dashed #1a73e8;
            background: rgba(26, 115, 232, 0.1);
            pointer-events: none;
            z-index: 999;
            display: none;
        }

        /* Modal Styles */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 40px;
            pointer-events: all;
        }

        #modal-content {
            display: flex;
            max-width: 90vw;
            max-height: 90vh;
            pointer-events: all;
        }

        #modal-content > .node {
            position: relative;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            max-width: 90vw;
            max-height: 90vh;
            min-width: 400px;
            min-height: 300px;
            width: 60vw;
            height: 70vh;
            z-index: 2001;
        }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        
        /* Dialog Styles */
        .dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2100;
        }
        
        .dialog-content {
            background: white;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        
        .dialog h2 {
            margin: 0 0 20px 0;
            color: #202124;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dialog h3 {
            margin: 0 0 16px 0;
            color: #5f6368;
            font-size: 16px;
        }
        
        .dialog label {
            display: block;
            margin-bottom: 16px;
        }
        
        .dialog label span {
            display: block;
            margin-bottom: 4px;
            color: #5f6368;
            font-size: 13px;
            font-weight: 500;
        }
        
        .dialog input[type="text"],
        .dialog input[type="password"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }
        
        .dialog input:focus {
            outline: none;
            border-color: #1a73e8;
        }
        
        .dialog small {
            display: block;
            margin-top: 4px;
            color: #5f6368;
            font-size: 12px;
        }
        
        .dialog small a {
            color: #1a73e8;
            text-decoration: none;
        }
        
        .dialog small a:hover {
            text-decoration: underline;
        }
        
        .dialog-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .dialog button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .dialog button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dialog button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        #github-connect-btn, #github-load-btn {
            background: #1a73e8;
            color: white;
        }
        
        #github-connect-btn:hover, #github-load-btn:hover:not(:disabled) {
            background: #1557b0;
        }
        
        #github-cancel-btn, #github-back-btn {
            background: #f1f3f4;
            color: #5f6368;
        }
        
        #github-cancel-btn:hover, #github-back-btn:hover {
            background: #e8eaed;
        }
        
        #github-disconnect-btn {
            background: #dc3545;
            color: white;
        }
        
        #github-disconnect-btn:hover {
            background: #c82333;
        }
        
        #github-new-file-btn {
            background: #34a853;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            width: 100%;
        }
        
        #github-new-file-btn:hover {
            background: #2d8e47;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #github-files-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dadce0;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        
        .github-file-item {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f3f4;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }
        
        .github-file-item:hover {
            background: #f8f9fa;
        }
        
        .github-file-item.selected {
            background: #e8f0fe;
            color: #1967d2;
        }
        
        .github-file-item:last-child {
            border-bottom: none;
        }
        
        .github-file-icon {
            font-size: 16px;
        }
        
        .github-file-name {
            flex: 1;
            font-size: 14px;
        }
        
        .github-file-size {
            font-size: 12px;
            color: #5f6368;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            margin: 20px auto;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #1a73e8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #github-status {
            position: fixed;
            top: 58px;
            right: 16px;
            background: #e8f0fe;
            color: #1967d2;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 900;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #github-status:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        #github-status.error {
            background: #fce8e6;
            color: #d93025;
        }
        
        #github-status.saving {
            background: #fef7e0;
            color: #f9ab00;
        }
    </style>
</head>
<body>
    <div id="topbar">
        <h1>📊 Advanced Knowledge Tree Workflow System</h1>
        <button id="save-btn">💾 Save Workflow</button>
        <button id="load-btn">📁 Load Workflow</button>
        <button id="github-btn">🐙 Load GitHub</button>
        <button id="fit-btn">🔍 Fit to Screen</button>
        <button id="zoom-in-btn">➕ Zoom In</button>
        <button id="zoom-out-btn">➖ Zoom Out</button>
        <button id="auto-layout-btn">🔀 Auto Layout</button>
        <button id="reset-btn">🏠 Reset View</button>
        <button id="clear-btn">🗑️ Clear All</button>
        <input type="file" id="file-input" accept=".json">
    </div>

    <div id="canvas">
        <div id="viewport">
            <svg id="links-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9.5" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" class="link-arrow"/>
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <div id="context-menu">
        <div class="menu-item" data-action="add-scribble">📝 Add Scribble Pad</div>
        <div class="menu-item" data-action="add-task">✓ Add Task</div>
        <div class="menu-item" data-action="add-group">📁 Add Group</div>
        <div class="menu-item" data-action="add-estimator">📊 Add Estimator</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="add-knowledge-section">📚 Knowledge Section</div>
        <div class="menu-item" data-action="add-knowledge-subsection">📖 Knowledge Subsection</div>
        <div class="menu-item" data-action="add-knowledge-item">📄 Knowledge Item</div>
        <div class="menu-item" data-action="add-adr">🏛️ Add ADR</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="paste">📋 Paste Data</div>
    </div>
    
    <div id="selection-context-menu">
        <div class="menu-item" data-action="group-elements">📁 Group Elements</div>
        <div class="menu-item" data-action="delete-all">🗑️ Delete All</div>
        <div class="menu-separator"></div>
        <div class="menu-item" data-action="export-workflow">💾 Export (Workflow)</div>
        <div class="menu-item" data-action="export-html">📄 Export (HTML)</div>
    </div>
    
    <div id="item-context-menu">
        <div class="menu-item" data-action="open-item">📂 Open</div>
        <div class="menu-item item-ungroup" data-action="ungroup-item">🔓 Ungroup</div>
        <div class="menu-item" data-action="delete-item">🗑️ Delete</div>
    </div>

    <div id="info-panel">
        <span>Right-click for menu</span>
        <span>•</span>
        <span>Alt+drag to link/extract</span>
        <span>•</span>
        <span>Ctrl+drag to select</span>
        <span>•</span>
        <span>Scroll to zoom</span>
    </div>

    <div id="zoom-indicator">100%</div>
    <div id="github-status">🐙 Connected to GitHub</div>
    <div id="loading">Loading workflow...</div>
    <div id="selection-rect"></div>
    <div id="modal-overlay">
        <div id="modal-content"></div>
    </div>
    
    <div id="github-dialog" class="dialog">
        <div class="dialog-content">
            <h2>🐙 GitHub Integration</h2>
            <div id="github-auth-section">
                <label>
                    <span>GitHub Repository URL:</span>
                    <input type="text" id="github-repo-url" placeholder="https://github.com/username/repo.git" value="">
                </label>
                <label>
                    <span>Personal Access Token:</span>
                    <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
                    <small>Create a token at <a href="https://github.com/settings/tokens" target="_blank">GitHub Settings</a> with 'repo' scope</small>
                    <small style="color: #666;">Note: SSH key authentication is not available in browser applications</small>
                </label>
                <div class="dialog-buttons">
                    <button id="github-connect-btn">Connect</button>
                    <button id="github-cancel-btn">Cancel</button>
                </div>
            </div>
            <div id="github-files-section" style="display: none;">
                <h3>Select Workflow File:</h3>
                <div id="github-files-list"></div>
                <div style="padding: 12px; border-top: 1px solid #e0e0e0; margin-top: 8px;">
                    <button id="github-new-file-btn">📄 Create New Workflow File</button>
                </div>
                <div class="dialog-buttons">
                    <button id="github-disconnect-btn" style="margin-right: auto;">Disconnect</button>
                    <button id="github-back-btn">Back</button>
                    <button id="github-load-btn" disabled>Load Selected</button>
                </div>
            </div>
            <div id="github-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading...</p>
            </div>
        </div>
    </div>

    <script>
        // Advanced Knowledge Tree Workflow System v1.3.1
        // State management
        let workflow = { items: {}, links: [], nextItemId: 1, nextLinkId: 1 };
        let selectedNode = null;
        let selectedNodes = [];
        let isDragging = false;
        let isResizing = false;
        let isLinking = false;
        let isSelecting = false;
        let isPanning = false;
        let linkSource = null;
        let tempLinkLine = null;
        let dragOffset = { x: 0, y: 0 };
        let selectStart = { x: 0, y: 0 };
        let panStart = { x: 0, y: 0 };
        let panStartTime = 0;
        let contextMenuPos = { x: 0, y: 0, groupId: null };
        let groups = {};
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        // GitHub integration state
        let githubConfig = {
            owner: '',
            repo: '',
            token: '',
            filePath: '',
            sha: '',
            connected: false
        };
        
        const panThreshold = 5;
        const STORAGE_KEY = 'workflow-visualizer-state';
        const GITHUB_CONFIG_KEY = 'workflow-github-config';
        const GROUP_COLLAPSED_WIDTH = 90;
        const GROUP_COLLAPSED_HEIGHT = 100;
        const ROUTING_MARGIN = 20;
        const MAX_ZOOM = 3;
        const MIN_ZOOM = 0.2;

        // DOM elements
        const canvas = document.getElementById('canvas');
        const viewport = document.getElementById('viewport');
        const linksSvg = document.getElementById('links-svg');
        const contextMenu = document.getElementById('context-menu');
        const selectionContextMenu = document.getElementById('selection-context-menu');
        const itemContextMenu = document.getElementById('item-context-menu');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const githubBtn = document.getElementById('github-btn');
        const fileInput = document.getElementById('file-input');
        const fitBtn = document.getElementById('fit-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const autoLayoutBtn = document.getElementById('auto-layout-btn');
        const resetBtn = document.getElementById('reset-btn');
        const clearBtn = document.getElementById('clear-btn');
        const loading = document.getElementById('loading');
        const zoomIndicator = document.getElementById('zoom-indicator');
        const selectionRect = document.getElementById('selection-rect');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const githubDialog = document.getElementById('github-dialog');
        const githubStatus = document.getElementById('github-status');

        const nodeIcons = { 'scribble': '📝', 'task': '✓', 'group': '📁', 'estimator': '📊', 'data': '📋', 'knowledge-section': '📚', 'knowledge-subsection': '📖', 'knowledge-item': '📄', 'adr': '🏛️' };

        // --- Initialization and Event Handlers ---
        function initialize() {
            saveBtn.addEventListener('click', saveWorkflow);
            loadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileLoad);
            fitBtn.addEventListener('click', fitToScreen);
            zoomInBtn.addEventListener('click', () => zoom(1.2));
            zoomOutBtn.addEventListener('click', () => zoom(0.8));
            autoLayoutBtn.addEventListener('click', autoLayout);
            resetBtn.addEventListener('click', resetView);
            clearBtn.addEventListener('click', clearAll);
            canvas.addEventListener('contextmenu', handleContextMenu);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('scroll', autoSave);
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleDrop);
            document.addEventListener('paste', handlePaste);
            document.addEventListener('keydown', handleKeyboard);
            contextMenu.addEventListener('click', handleMenuClick);
            selectionContextMenu.addEventListener('click', handleSelectionMenuClick);
            itemContextMenu.addEventListener('click', handleItemMenuClick);
            
            // GitHub file selection with keyboard
            document.getElementById('github-files-list').addEventListener('keydown', (e) => {
                const items = Array.from(document.querySelectorAll('.github-file-item'));
                const selected = document.querySelector('.github-file-item.selected');
                const currentIndex = selected ? items.indexOf(selected) : -1;
                
                if (e.key === 'ArrowDown' && currentIndex < items.length - 1) {
                    e.preventDefault();
                    selectGithubFile(items[currentIndex + 1]);
                } else if (e.key === 'ArrowUp' && currentIndex > 0) {
                    e.preventDefault();
                    selectGithubFile(items[currentIndex - 1]);
                } else if (e.key === 'Enter' && selected) {
                    e.preventDefault();
                    loadSelectedFile();
                }
            });
            
            modalOverlay.addEventListener('click', (e) => { 
                if (window.ignoreNextClick) {
                    window.ignoreNextClick = false;
                    return;
                }
                if (e.target === modalOverlay) closeModal(); 
            });
            modalOverlay.addEventListener('mousedown', (e) => { e.stopPropagation(); });
            modalOverlay.addEventListener('mousemove', (e) => { if (isResizing) e.stopPropagation(); });
            modalOverlay.addEventListener('mouseup', (e) => { if (isResizing) e.stopPropagation(); });
            if (!loadFromLocalStorage()) {
                renderWorkflow();
                updateViewportTransform();
            }
        }
        
        function handleMouseDown(e) { 
            const clickedNode = e.target.closest('.node'); 
            const clickedLink = e.target.closest('.link-clickable'); 
            
            // Start selection if ctrl/cmd is held and not clicking on a node or link
            if (!clickedNode && !clickedLink && (e.ctrlKey || e.metaKey)) { 
                startSelection(e); 
                return; 
            } 
            
            // Start panning if clicking on empty canvas or middle mouse button
            if ((e.button === 0 && !clickedNode && !clickedLink) || e.button === 1) { 
                panStart = { x: e.clientX, y: e.clientY }; 
                panStartTime = Date.now(); 
                e.preventDefault(); 
            } 
        }
        function handleMouseMove(e) { 
            if (isSelecting) { 
                handleSelection(e); 
                return; 
            } 
            if ((panStart.x !== 0 || panStart.y !== 0) && !isSelecting) { 
                const dx = e.clientX - panStart.x; 
                const dy = e.clientY - panStart.y; 
                if (!isPanning && Math.sqrt(dx * dx + dy * dy) > panThreshold) { 
                    isPanning = true; 
                    canvas.classList.add('panning'); 
                } 
                if (isPanning) { 
                    canvas.scrollLeft -= dx; 
                    canvas.scrollTop -= dy; 
                    panStart = { x: e.clientX, y: e.clientY }; 
                } 
            } 
        }
        function handleMouseUp(e) { 
            if (isSelecting) { 
                endSelection(); 
                return;
            }
            if (isPanning) { 
                isPanning = false; 
                canvas.classList.remove('panning'); 
                autoSave(); 
            } 
            if ((panStart.x !== 0 || panStart.y !== 0) && !isPanning && Date.now() - panStartTime < 200) { 
                handleCanvasClick(e); 
            } 
            panStart = { x: 0, y: 0 }; 
        }
        function handleCanvasClick(e) { 
            if (contextMenu.style.display === 'block' || selectionContextMenu.style.display === 'block' || itemContextMenu.style.display === 'block') { 
                contextMenu.style.display = 'none'; 
                selectionContextMenu.style.display = 'none';
                itemContextMenu.style.display = 'none';
            } 
            if (!e.target.closest('.node') && !e.target.closest('.link-clickable')) { 
                clearSelection(); 
            } 
        }
        function handleContextMenu(e) { 
            e.preventDefault(); 
            if (isPanning) return; 
            
            // Hide all menus first
            contextMenu.style.display = 'none';
            selectionContextMenu.style.display = 'none';
            itemContextMenu.style.display = 'none';
            
            // Check if we have selected nodes
            if (selectedNodes.length > 0) {
                // Show selection context menu
                selectionContextMenu.style.left = e.clientX + 'px'; 
                selectionContextMenu.style.top = e.clientY + 'px'; 
                selectionContextMenu.style.display = 'block';
                return;
            }
            
            const targetElement = e.target; 
            const groupNode = targetElement.closest('.node.group'); 
            const anyNode = targetElement.closest('.node'); 
            if (!anyNode || groupNode) { 
                const canvasRect = canvas.getBoundingClientRect(); 
                contextMenuPos = { 
                    x: (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale, 
                    y: (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale, 
                    groupId: groupNode ? (groupNode.id.startsWith('inline-') ? groupNode.id.substring(7) : groupNode.id) : null 
                }; 
                contextMenu.style.left = e.clientX + 'px'; 
                contextMenu.style.top = e.clientY + 'px'; 
                contextMenu.style.display = 'block'; 
            } 
        }
        function handleWheel(e) { e.preventDefault(); const delta = e.deltaY > 0 ? 0.9 : 1.1; zoom(delta, e.clientX, e.clientY); }
        function handleKeyboard(e) { const activeElement = document.activeElement; if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true') return; if (e.ctrlKey || e.metaKey) { if (e.key === '+' || e.key === '=') { e.preventDefault(); zoom(1.1); } else if (e.key === '-') { e.preventDefault(); zoom(0.9); } else if (e.key === '0') { e.preventDefault(); resetView(); } else if (e.key === 'Enter') { e.preventDefault(); groupSelectedNodes(); } }             if (e.key === 'Delete' && (selectedNode || selectedNodes.length > 0)) { 
                const nodesToDelete = selectedNodes.length > 0 ? selectedNodes : (selectedNode ? [selectedNode] : []);
                if (nodesToDelete.length > 0 && confirm(`Delete ${nodesToDelete.length} selected node(s)?`)) { 
                    nodesToDelete.forEach(node => deleteNode(node.id)); 
                    clearSelection(); 
                } 
            } }

        // --- Core Node Management ---
        function createNode(item, isModal = false, isInline = false) {
            const node = document.createElement('div');
            node.className = `node ${item.type}`;
            if (isInline) node.classList.add('inline-node');
            
            if (isModal) {
                node.id = `modal-${item.id}`;
            } else if (isInline) {
                node.id = `inline-${item.id}`;
                const parentItem = workflow.items[item.parentId];
                if (parentItem && item.groupX !== undefined && item.groupY !== undefined) {
                    node.style.left = item.groupX + 'px';
                    node.style.top = item.groupY + 'px';
                } else if (parentItem) {
                    // Initialize position if not set
                    const siblings = groups[item.parentId] || parentItem.data.children || [];
                    const index = siblings.indexOf(item.id);
                    item.groupX = 20 + (index % 3) * 150;
                    item.groupY = 20 + Math.floor(index / 3) * 100;
                    node.style.left = item.groupX + 'px';
                    node.style.top = item.groupY + 'px';
                } else {
                    node.style.left = '20px';
                    node.style.top = '20px';
                }
            } else {
                node.id = item.id;
                node.style.left = item.x + 'px';
                node.style.top = item.y + 'px';
            }
            
            if (item.type === 'group' && !item.data.isExpanded) {
                node.style.width = GROUP_COLLAPSED_WIDTH + 'px';
                node.style.height = GROUP_COLLAPSED_HEIGHT + 'px';
            } else if (isInline) {
                // Inline nodes have smaller default sizes
                if (item.type === 'group') {
                    node.style.width = Math.min(item.width || 300, 300) + 'px';
                    node.style.height = Math.min(item.height || 200, 200) + 'px';
                } else {
                    node.style.width = Math.min(item.width || 200, 200) + 'px';
                    node.style.height = Math.min(item.height || 100, 150) + 'px';
                }
            } else {
                node.style.width = item.width + 'px';
                node.style.height = item.height + 'px';
            }
            
            const header = document.createElement('div');
            header.className = 'node-header';
            header.innerHTML = `<div class="node-type-icon">${nodeIcons[item.type] || '📄'}</div><div class="node-title">${item.data.title || 'Untitled'}</div>`;
            
            const controls = document.createElement('div');
            controls.className = 'node-controls';
            
            if (item.type === 'group' && !isModal) {
                // Add view mode controls for all groups (including inline/subgroups)
                const viewMode = item.data.viewMode || 'icon';
                
                const iconViewBtn = document.createElement('div');
                iconViewBtn.className = `view-control ${viewMode === 'icon' ? 'active' : ''}`;
                iconViewBtn.innerHTML = '⊞';
                iconViewBtn.title = 'Icon View';
                iconViewBtn.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    setGroupViewMode(item.id, 'icon');
                });
                controls.appendChild(iconViewBtn);
                
                const listViewBtn = document.createElement('div');
                listViewBtn.className = `view-control ${viewMode === 'list' ? 'active' : ''}`;
                listViewBtn.innerHTML = '☰';
                listViewBtn.title = 'List View';
                listViewBtn.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    setGroupViewMode(item.id, 'list');
                });
                controls.appendChild(listViewBtn);
                
                const graphViewBtn = document.createElement('div');
                graphViewBtn.className = `view-control ${viewMode === 'graph' ? 'active' : ''}`;
                graphViewBtn.innerHTML = '⊙';
                graphViewBtn.title = 'Graph View';
                graphViewBtn.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    setGroupViewMode(item.id, 'graph');
                });
                controls.appendChild(graphViewBtn);
                
                const expandBtn = document.createElement('div');
                expandBtn.className = 'node-control expand-icon';
                expandBtn.innerHTML = '▶';
                expandBtn.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    toggleNode(node); 
                });
                controls.appendChild(expandBtn);
            }
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'node-control';
            deleteBtn.innerHTML = '✕';
            if (isModal) {
                deleteBtn.title = 'Close';
                deleteBtn.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    closeModal(); 
                });
            } else {
                deleteBtn.title = 'Delete Node';
                deleteBtn.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    if (confirm('Delete this node?')) deleteNode(item.id); 
                });
            }
            controls.appendChild(deleteBtn);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'node-content';
            
            switch (item.type) {
                case 'scribble': 
                    content.innerHTML = `<textarea class="scribble-content" placeholder="Scribble away...">${item.data.content || ''}</textarea>`; 
                    break;
                case 'task': 
                    content.innerHTML = createTaskContent(item.data); 
                    break;
                case 'estimator': 
                    content.innerHTML = createEstimatorContent(item.data); 
                    break;
                case 'data': 
                    content.innerHTML = createDataContent(item.data); 
                    break;
                case 'group': {
                    const groupContent = document.createElement('div');
                    groupContent.className = 'group-content';
                    const viewMode = item.data.viewMode || 'icon';
                    groupContent.classList.add(`${viewMode}-view`);
                    populateGroupContent(groupContent, item, viewMode);
                    content.appendChild(groupContent);
                    
                    const iconRepresentation = document.createElement('div');
                    iconRepresentation.className = 'group-icon-representation';
                    const truncatedTitle = item.data.title && item.data.title.length > 64 ? 
                        item.data.title.substring(0, 61) + '...' : 
                        (item.data.title || 'Untitled');
                    iconRepresentation.innerHTML = `<div class="group-icon-representation-symbol">${nodeIcons.group}</div><div class="group-icon-representation-title">${truncatedTitle}</div>`;
                    iconRepresentation.addEventListener('dblclick', (e) => { 
                        e.stopPropagation(); 
                        toggleNode(node); 
                    });
                    
                    if (!isInline) {
                        iconRepresentation.addEventListener('mousedown', (e) => {
                            if (!e.target.closest('.node-control')) {
                                startDrag(node, e);
                            }
                        });
                    } else {
                        iconRepresentation.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            startInlineDrag(node, item, e);
                        });
                    }
                    node.appendChild(iconRepresentation);
                    break;
                }
                case 'adr': 
                    content.innerHTML = createADRContent(item.data); 
                    break;
                default: 
                    content.innerHTML = `<textarea class="knowledge-content">${item.data.content || ''}</textarea>`; 
                    break;
            }
            
            node.appendChild(header);
            node.appendChild(content);

            if (!isInline || item.type === 'group') {
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                node.appendChild(resizeHandle);
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    startResize(node, e);
                });
            }
            
            if (!isModal) {
                node.addEventListener('click', (e) => selectNode(node, e));
                
                if (isInline) {
                    // Special drag handling for inline nodes
                    header.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        startInlineDrag(node, item, e);
                    });
                    node.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showItemContextMenu(e, item);
                    });
                } else if (isInline) {
                    // Special drag handling for inline nodes
                    header.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        if (item.type === 'group' && !node.classList.contains('expanded')) {
                            // For collapsed inline groups, handle like regular drag
                            startInlineDrag(node, item, e);
                        } else {
                            startInlineDrag(node, item, e);
                        }
                    });
                    node.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showItemContextMenu(e, item);
                    });
                } else {
                    header.addEventListener('mousedown', (e) => startDrag(node, e));
                }
            }
            
            header.querySelector('.node-title').addEventListener('dblclick', (e) => editTitle(e.currentTarget, item, e));
            
            if (item.data.isExpanded || isModal) {
                node.classList.add('expanded');
            }
            
            setupInputListeners(node, item);

            if (isModal) {
                modalContent.appendChild(node);
            } else if (isInline) {
                return node;
            } else {
                viewport.appendChild(node);
            }
            
            return node;
        }

        function addNode(type, x, y) {
            const id = `item-${workflow.nextItemId++}`;
            const isGroup = type === 'group';
            const defaultData = { title: type.charAt(0).toUpperCase() + type.slice(1).replace('-', ' '), content: '', isExpanded: true };
            if (isGroup) { 
                Object.assign(defaultData, { children: [], isExpanded: true, viewMode: 'icon' }); 
                groups[id] = []; 
            }
            const item = { id, type, x, y, width: 400, height: 300, data: defaultData, parentId: contextMenuPos.groupId || null };
            workflow.items[id] = item;
            if (contextMenuPos.groupId) { 
                addNodeToGroup(item, contextMenuPos.groupId); 
            }
            else { 
                createNode(item); 
            }
            updateLinks(); 
            autoSave();
        }

        function deleteNode(nodeId) {
            const node = document.getElementById(nodeId);
            const inlineNode = document.getElementById(`inline-${nodeId}`);
            if (node) node.remove();
            if (inlineNode) inlineNode.remove();
            
            const item = workflow.items[nodeId];
            if (item && item.type === 'group') { 
                (groups[nodeId] || item.data.children || []).forEach(childId => deleteNode(childId)); 
            }
            if (item && item.parentId) {
                const parentItem = workflow.items[item.parentId];
                if (parentItem && parentItem.data.children) { 
                    parentItem.data.children = parentItem.data.children.filter(id => id !== nodeId); 
                }
                if (groups[item.parentId]) { 
                    groups[item.parentId] = groups[item.parentId].filter(id => id !== nodeId); 
                }
                // Refresh parent group display
                const parentNode = document.getElementById(item.parentId);
                if (parentNode) {
                    const groupContent = parentNode.querySelector('.group-content');
                    if (groupContent && parentItem) {
                        populateGroupContent(groupContent, parentItem, parentItem.data.viewMode || 'icon');
                    }
                }
            }
            delete workflow.items[nodeId];
            workflow.links = workflow.links.filter(link => link.sourceId !== nodeId && link.targetId !== nodeId);
            updateLinks(); 
            autoSave();
        }

        // --- Link Routing Engine ---
        function getItemBoundingBox(item, withMargin = false) {
            const node = document.getElementById(item.id);
            const isCollapsedGroup = item.type === 'group' && node && !node.classList.contains('expanded');
            const width = isCollapsedGroup ? GROUP_COLLAPSED_WIDTH : item.width;
            const height = isCollapsedGroup ? GROUP_COLLAPSED_HEIGHT : item.height;
            const margin = withMargin ? ROUTING_MARGIN : 0;
            return {
                x: item.x - margin,
                y: item.y - margin,
                width: width + 2 * margin,
                height: height + 2 * margin,
                right: item.x + width + margin,
                bottom: item.y + height + margin,
                centerX: item.x + width / 2,
                centerY: item.y + height / 2
            };
        }
        
        function getEdgePoint(box, targetPoint) {
            const dx = targetPoint.x - box.centerX;
            const dy = targetPoint.y - box.centerY;
            
            // Handle case where source and target are at same position
            if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) {
                return { x: box.right, y: box.centerY };
            }
            
            // Calculate intersection with box edges
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            const halfWidth = box.width / 2;
            const halfHeight = box.height / 2;
            
            let edgeX, edgeY;
            
            if (absDx * halfHeight > absDy * halfWidth) {
                // Intersects left or right edge
                edgeX = dx > 0 ? box.right : box.x;
                edgeY = box.centerY + (dy * halfWidth / absDx) * (dx > 0 ? 1 : -1);
            } else {
                // Intersects top or bottom edge
                edgeX = box.centerX + (dx * halfHeight / absDy) * (dy > 0 ? 1 : -1);
                edgeY = dy > 0 ? box.bottom : box.y;
            }
            
            return { x: edgeX, y: edgeY };
        }
        
        function snapPathToEdges(sourceBox, targetBox, points) {
            if (points.length < 2) return points;
            const newPoints = [...points];
            
            // Get edge points for start and end
            const startEdgePoint = getEdgePoint(sourceBox, newPoints[1] || newPoints[newPoints.length - 1]);
            const endEdgePoint = getEdgePoint(targetBox, newPoints[newPoints.length - 2] || newPoints[0]);
            
            newPoints[0] = startEdgePoint;
            newPoints[newPoints.length - 1] = endEdgePoint;
            
            return newPoints;
        }
        
        function lineIntersectsRect(p1, p2, rect) {
            const cx = (p1.x + p2.x) / 2, cy = (p1.y + p2.y) / 2;
            const w = Math.abs(p1.x - p2.x), h = Math.abs(p1.y - p2.y);
            const rcx = rect.x + rect.width/2, rcy = rect.y + rect.height/2;
            return Math.abs(cx - rcx) <= (w + rect.width)/2 && Math.abs(cy - rcy) <= (h + rect.height)/2;
        }
        
        function routePath(sourceBox, targetBox, obstacles) {
            const startPoint = { x: sourceBox.centerX, y: sourceBox.centerY };
            const endPoint = { x: targetBox.centerX, y: targetBox.centerY };
            
            // Try horizontal-first path
            const midPointH = { x: endPoint.x, y: startPoint.y };
            const pathH = [startPoint, midPointH, endPoint];
            
            // Try vertical-first path
            const midPointV = { x: startPoint.x, y: endPoint.y };
            const pathV = [startPoint, midPointV, endPoint];
            
            // Check which path has fewer collisions
            let pathHCollides = false;
            for (const obs of obstacles) {
                if (lineIntersectsRect(pathH[0], pathH[1], obs) || lineIntersectsRect(pathH[1], pathH[2], obs)) {
                    pathHCollides = true;
                    break;
                }
            }
            
            let pathVCollides = false;
            for (const obs of obstacles) {
                if (lineIntersectsRect(pathV[0], pathV[1], obs) || lineIntersectsRect(pathV[1], pathV[2], obs)) {
                    pathVCollides = true;
                    break;
                }
            }
            
            // If both paths collide, try a more complex route
            if (pathHCollides && pathVCollides) {
                // Try going around obstacles
                const midX = (startPoint.x + endPoint.x) / 2;
                const midY = (startPoint.y + endPoint.y) / 2;
                return [startPoint, { x: midX, y: startPoint.y }, { x: midX, y: endPoint.y }, endPoint];
            }
            
            return !pathHCollides ? pathH : pathV;
        }
        
        function pointsToPath(points) {
            if (points.length < 2) return "";
            let d = `M ${points[0].x} ${points[0].y}`;
            const cornerRadius = 10;
            for (let i = 1; i < points.length - 1; i++) {
                const p0 = points[i - 1];
                const p1 = points[i];
                const p2 = points[i + 1];
                const v1 = { x: p0.x - p1.x, y: p0.y - p1.y };
                const v2 = { x: p2.x - p1.x, y: p2.y - p1.y };
                const v1Len = Math.hypot(v1.x, v1.y);
                const v2Len = Math.hypot(v2.x, v2.y);
                const radius = Math.min(cornerRadius, v1Len / 2, v2Len / 2);
                if (radius > 0) {
                    const pA = { x: p1.x + (v1.x / v1Len) * radius, y: p1.y + (v1.y / v1Len) * radius };
                    const pB = { x: p1.x + (v2.x / v2Len) * radius, y: p1.y + (v2.y / v2Len) * radius };
                    d += ` L ${pA.x} ${pA.y} Q ${p1.x} ${p1.y}, ${pB.x} ${pB.y}`;
                } else {
                    d += ` L ${p1.x} ${p1.y}`;
                }
            }
            d += ` L ${points[points.length - 1].x} ${points[points.length - 1].y}`;
            return d;
        }
        
        function updateLinks() {
            while (linksSvg.lastChild && linksSvg.lastChild.tagName !== 'defs') {
                linksSvg.removeChild(linksSvg.lastChild);
            }
            const allItems = Object.values(workflow.items);
            workflow.links.forEach(link => {
                const sourceItem = workflow.items[link.sourceId];
                const targetItem = workflow.items[link.targetId];
                if (!sourceItem || !targetItem) return;
                
                // Skip links between items in the same group (they'll be rendered inside the group)
                if (sourceItem.parentId && targetItem.parentId && sourceItem.parentId === targetItem.parentId) {
                    return;
                }
                
                // Skip links where both items are inside groups
                if (sourceItem.parentId || targetItem.parentId) {
                    return;
                }
                
                const sourceBoxInflated = getItemBoundingBox(sourceItem, true);
                const targetBoxInflated = getItemBoundingBox(targetItem, true);
                const sourceBoxActual = getItemBoundingBox(sourceItem, false);
                const targetBoxActual = getItemBoundingBox(targetItem, false);
                
                const obstacles = allItems
                    .filter(item => item.id !== sourceItem.id && item.id !== targetItem.id && !item.parentId)
                    .map(item => getItemBoundingBox(item, true));
                
                let pathPoints = routePath(sourceBoxInflated, targetBoxInflated, obstacles);
                pathPoints = snapPathToEdges(sourceBoxActual, targetBoxActual, pathPoints);
                
                const pathString = pointsToPath(pathPoints);
                const linkGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathString);
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.classList.add('link');
                const clickPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickPath.setAttribute('d', pathString);
                clickPath.classList.add('link-clickable');
                linkGroup.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (confirm('Delete this connection?')) {
                        workflow.links = workflow.links.filter(l => l.id !== link.id);
                        updateLinks();
                        autoSave();
                    }
                });
                linkGroup.appendChild(clickPath);
                linkGroup.appendChild(path);
                linksSvg.appendChild(linkGroup);
            });
            
            // Update links in all groups recursively
            updateAllGroupLinks();
        }
        
        function updateAllGroupLinks() {
            Object.values(workflow.items).forEach(item => {
                if (item.type === 'group' && item.data.isExpanded && item.data.viewMode === 'graph') {
                    updateGroupLinks(item.id);
                }
            });
        }
        
        // --- Drag, Resize, Linking ---
        function startDrag(node, e) { 
            if (e.target.classList.contains('node-control') || e.target.classList.contains('view-control') || e.target.classList.contains('resize-handle')) return; 
            
            // For collapsed groups, allow dragging from the icon representation
            const isCollapsedGroup = node.classList.contains('group') && !node.classList.contains('expanded');
            if (isCollapsedGroup && !e.target.closest('.group-icon-representation')) {
                return;
            }
            
            if (e.altKey) { 
                startLinking(node, e); 
                return; 
            } 
            
            isDragging = true; 
            const nodeRect = node.getBoundingClientRect(); 
            dragOffset = { x: e.clientX - nodeRect.left, y: e.clientY - nodeRect.top }; 
            node.classList.add('dragging'); 
            selectNode(node, e); 
            document.addEventListener('mousemove', handleDrag); 
            document.addEventListener('mouseup', stopDrag); 
            e.preventDefault(); 
        }
        let updateLinksTimeout;
        function updateLinksDebounced() {
            clearTimeout(updateLinksTimeout);
            updateLinksTimeout = setTimeout(updateLinks, 16); // ~60fps
        }
        
        function handleDrag(e) { 
            e.stopPropagation(); 
            if (!isDragging || !selectedNode) return; 
            
            const canvasRect = canvas.getBoundingClientRect(); 
            const x = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale - dragOffset.x; 
            const y = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale - dragOffset.y; 
            
            selectedNode.style.left = Math.max(0, x) + 'px'; 
            selectedNode.style.top = Math.max(0, y) + 'px'; 
            
            const item = workflow.items[selectedNode.id]; 
            if (item) { 
                item.x = Math.max(0, x); 
                item.y = Math.max(0, y); 
                
                // Clear previous drop target
                document.querySelectorAll('.node.group.drop-target').forEach(n => n.classList.remove('drop-target'));
                
                // Check if dragging out of a group
                if (item.parentId) {
                    const parentGroup = document.getElementById(item.parentId);
                    if (parentGroup) {
                        const parentRect = parentGroup.getBoundingClientRect();
                        const nodeRect = selectedNode.getBoundingClientRect();
                        
                        // Check if node is outside parent group
                        if (nodeRect.left < parentRect.left || nodeRect.right > parentRect.right ||
                            nodeRect.top < parentRect.top || nodeRect.bottom > parentRect.bottom) {
                            
                            // Mark as being dragged out but don't remove yet
                            window.draggedOutOfGroup = true;
                            window.draggedFromGroup = item.parentId;
                            
                            // Check if over another group
                            const targetGroup = getGroupUnderPoint(e.clientX, e.clientY, item.parentId);
                            if (targetGroup && targetGroup.classList.contains('expanded')) {
                                targetGroup.classList.add('drop-target');
                            }
                        } else {
                            window.draggedOutOfGroup = false;
                        }
                    }
                } else {
                    // Check if dragging into a group
                    const targetGroup = getGroupUnderPoint(e.clientX, e.clientY);
                    if (targetGroup && targetGroup.classList.contains('expanded')) {
                        targetGroup.classList.add('drop-target');
                    }
                }
            } 
            updateLinksDebounced(); 
        }
        
        function getGroupUnderPoint(x, y, excludeId) {
            const elements = document.elementsFromPoint(x, y);
            return elements.find(el => 
                el.classList.contains('node') && 
                el.classList.contains('group') && 
                el.id !== excludeId &&
                !el.id.startsWith('inline-')
            );
        }
        
        function removeFromGroup(itemId, groupId) {
            const item = workflow.items[itemId];
            const groupItem = workflow.items[groupId];
            
            if (!item || !groupItem) return;
            
            // Calculate world position if item was in graph view
            if (item.groupX !== undefined && item.groupY !== undefined) {
                const groupNode = document.getElementById(groupId);
                if (groupNode) {
                    const groupRect = groupNode.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    // Convert group-relative position to world position
                    item.x = ((groupRect.left - canvasRect.left) / scale) + item.groupX + canvas.scrollLeft - translateX;
                    item.y = ((groupRect.top - canvasRect.top) / scale) + item.groupY + canvas.scrollTop - translateY;
                }
            }
            
            item.parentId = null;
            item.groupX = undefined;
            item.groupY = undefined;
            groups[groupId] = groups[groupId].filter(id => id !== itemId);
            groupItem.data.children = groups[groupId];
            
            // Create node on canvas
            createNode(item);
            
            // Update group display
            const groupNode = document.getElementById(groupId);
            if (groupNode) {
                const groupContent = groupNode.querySelector('.group-content');
                if (groupContent) {
                    populateGroupContent(groupContent, groupItem, groupItem.data.viewMode || 'icon');
                }
            }
        }
        function startInlineDrag(node, item, e) {
            isDragging = true;
            selectedNode = node;
            const nodeRect = node.getBoundingClientRect();
            dragOffset = { x: e.clientX - nodeRect.left, y: e.clientY - nodeRect.top };
            node.classList.add('dragging');
            
            // Store initial position
            window.inlineDragItem = item;
            window.inlineDragStart = { 
                x: parseInt(node.style.left), 
                y: parseInt(node.style.top) 
            };
            
            document.addEventListener('mousemove', handleInlineDrag);
            document.addEventListener('mouseup', stopInlineDrag);
            e.preventDefault();
        }
        
        function handleInlineDrag(e) {
            if (!isDragging || !selectedNode || !window.inlineDragItem) return;
            
            const parentViewport = selectedNode.closest('.group-graph-viewport');
            if (!parentViewport) return;
            
            const viewportRect = parentViewport.getBoundingClientRect();
            const scrollLeft = parentViewport.scrollLeft;
            const scrollTop = parentViewport.scrollTop;
            
            const x = Math.max(0, e.clientX - viewportRect.left - dragOffset.x + scrollLeft);
            const y = Math.max(0, e.clientY - viewportRect.top - dragOffset.y + scrollTop);
            
            selectedNode.style.left = x + 'px';
            selectedNode.style.top = y + 'px';
            
            // Update item's group position
            window.inlineDragItem.groupX = x;
            window.inlineDragItem.groupY = y;
            
            // Update group links in real-time
            const groupId = window.inlineDragItem.parentId;
            if (groupId) updateGroupLinks(groupId);
        }
        
        function stopInlineDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            if (selectedNode) selectedNode.classList.remove('dragging');
            window.inlineDragItem = null;
            window.inlineDragStart = null;
            autoSave();
            document.removeEventListener('mousemove', handleInlineDrag);
            document.removeEventListener('mouseup', stopInlineDrag);
        }
        
        function stopDrag() { 
            if (!isDragging) return; 
            isDragging = false; 
            if (selectedNode) {
                selectedNode.classList.remove('dragging');
                
                const item = workflow.items[selectedNode.id];
                if (item && window.draggedOutOfGroup) {
                    // Handle final placement
                    const targetGroup = document.querySelector('.node.group.drop-target');
                    
                    if (targetGroup) {
                        // Remove from old group
                        if (window.draggedFromGroup) {
                            removeFromGroup(item.id, window.draggedFromGroup);
                        }
                        
                        // Add to new group
                        const targetRect = targetGroup.getBoundingClientRect();
                        const nodeRect = selectedNode.getBoundingClientRect();
                        item.groupX = (nodeRect.left - targetRect.left) / scale;
                        item.groupY = (nodeRect.top - targetRect.top) / scale;
                        addNodeToGroup(item, targetGroup.id);
                    } else if (window.draggedFromGroup) {
                        // Just remove from group and place on main canvas
                        removeFromGroup(item.id, window.draggedFromGroup);
                    }
                } else if (item && !item.parentId) {
                    // Check if dropped into a group
                    const targetGroup = document.querySelector('.node.group.drop-target');
                    if (targetGroup) {
                        const targetRect = targetGroup.getBoundingClientRect();
                        const nodeRect = selectedNode.getBoundingClientRect();
                        item.groupX = (nodeRect.left - targetRect.left) / scale;
                        item.groupY = (nodeRect.top - targetRect.top) / scale;
                        addNodeToGroup(item, targetGroup.id);
                    }
                }
            }
            
            // Clear drop targets and flags
            document.querySelectorAll('.node.group.drop-target').forEach(n => n.classList.remove('drop-target'));
            window.draggedOutOfGroup = false;
            window.draggedFromGroup = null;
            
            clearTimeout(updateLinksTimeout); 
            updateLinks(); 
            autoSave(); 
            document.removeEventListener('mousemove', handleDrag); 
            document.removeEventListener('mouseup', stopDrag); 
        }
        function startResize(node, e) { 
            isResizing = true; 
            const isModalNode = node.id.startsWith('modal-');
            window.resizingIsModal = isModalNode;
            if (!isModalNode) {
                selectNode(node, e); 
            }
            // Add resizing class
            node.classList.add('resizing');
            
            // Store resize state
            window.resizingNode = node;
            window.resizeStartX = e.clientX;
            window.resizeStartY = e.clientY;
            window.resizeStartWidth = parseInt(node.style.width);
            window.resizeStartHeight = parseInt(node.style.height);
            
            document.addEventListener('mousemove', handleResize, true); 
            document.addEventListener('mouseup', stopResize, true); 
            e.preventDefault(); 
            e.stopPropagation(); 
            e.stopImmediatePropagation();
        }
        
        function handleResize(e) { 
            e.preventDefault();
            e.stopPropagation(); 
            e.stopImmediatePropagation();
            if (!isResizing || !window.resizingNode) return; 
            
            const node = window.resizingNode;
            const isModalNode = node.id.startsWith('modal-'); 
            
            const deltaX = e.clientX - window.resizeStartX;
            const deltaY = e.clientY - window.resizeStartY;
            
            const width = Math.max(200, window.resizeStartWidth + deltaX);
            const height = Math.max(100, window.resizeStartHeight + deltaY);
            
            node.style.width = width + 'px'; 
            node.style.height = height + 'px'; 
            
            const itemId = isModalNode ? node.id.substring(6) : node.id; 
            const item = workflow.items[itemId]; 
            if (item) { 
                item.width = width; 
                item.height = height; 
                if (item.type === 'group') { 
                    item.data.expandedWidth = width; 
                    item.data.expandedHeight = height; 
                } 
            } 
            // Don't update links during resize - wait until resize is complete
        }
        
        function stopResize(e) { 
            if (!isResizing) return; 
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            const wasModalResize = window.resizingIsModal;
            const resizedNode = window.resizingNode;
            
            // Remove resizing class
            if (resizedNode) {
                resizedNode.classList.remove('resizing');
            }
            
            isResizing = false; 
            window.resizingNode = null;
            window.resizeStartX = null;
            window.resizeStartY = null;
            window.resizeStartWidth = null;
            window.resizeStartHeight = null;
            window.resizingIsModal = null;
            
            // Only update links after resize is complete and only for non-modal nodes
            if (!wasModalResize) {
                updateLinks();
            }
            
            autoSave(); 
            document.removeEventListener('mousemove', handleResize, true); 
            document.removeEventListener('mouseup', stopResize, true); 
            
            // Prevent any click events from propagating after resize
            setTimeout(() => {
                window.ignoreNextClick = false;
            }, 10);
            window.ignoreNextClick = true;
        }
        function startLinking(node, e) { isLinking = true; linkSource = node; canvas.classList.add('linking'); tempLinkLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); tempLinkLine.classList.add('link'); tempLinkLine.style.strokeDasharray = '5,5'; tempLinkLine.style.color = '#1a73e8'; linksSvg.appendChild(tempLinkLine); node.classList.add('link-source'); document.addEventListener('mousemove', handleLinking); document.addEventListener('mouseup', stopLinking); e.preventDefault(); }
        function handleLinking(e) { if (!isLinking || !linkSource || !tempLinkLine) return; const sourceItem = workflow.items[linkSource.id]; if (!sourceItem) return; const canvasRect = canvas.getBoundingClientRect(); const mouseX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale; const mouseY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale; const sourceBox = getItemBoundingBox(sourceItem); const startPoint = { x: sourceBox.centerX, y: sourceBox.centerY}; tempLinkLine.setAttribute('d', `M ${startPoint.x} ${startPoint.y} L ${mouseX} ${mouseY}`); const targetNode = e.target.closest('.node'); document.querySelectorAll('.node.link-target').forEach(n => n.classList.remove('link-target')); if (targetNode && targetNode !== linkSource && !targetNode.classList.contains('inline-node')) { targetNode.classList.add('link-target'); } }
        function stopLinking(e) { if (!isLinking) return; isLinking = false; canvas.classList.remove('linking'); if (tempLinkLine) tempLinkLine.remove(); const targetNode = e.target.closest('.node'); if (targetNode && targetNode !== linkSource && !targetNode.classList.contains('inline-node')) { const sourceId = linkSource.id; const targetId = targetNode.id; if (!workflow.links.find(l => l.sourceId === sourceId && l.targetId === targetId)) { workflow.links.push({ id: `link-${workflow.nextLinkId++}`, sourceId, targetId }); updateLinks(); autoSave(); } } document.querySelectorAll('.link-source, .link-target').forEach(n => n.classList.remove('link-source', 'link-target')); linkSource = null; document.removeEventListener('mousemove', handleLinking); document.removeEventListener('mouseup', stopLinking); }
        
        // --- Selection and UI State Management ---
        function startSelection(e) { 
            isSelecting = true; 
            const canvasRect = canvas.getBoundingClientRect();
            
            // Store world coordinates
            selectStart = { 
                x: (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale, 
                y: (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale 
            }; 
            
            // Set initial position using client coordinates
            selectionRect.style.left = e.clientX + 'px'; 
            selectionRect.style.top = e.clientY + 'px'; 
            selectionRect.style.width = '0px'; 
            selectionRect.style.height = '0px'; 
            selectionRect.style.display = 'block'; 
            e.preventDefault(); 
        }
        
        function handleSelection(e) { 
            if (!isSelecting) return; 
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate current world coordinates
            const currentX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale; 
            const currentY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale; 
            
            // Get selection bounds in world space
            const x = Math.min(selectStart.x, currentX); 
            const y = Math.min(selectStart.y, currentY); 
            const width = Math.abs(currentX - selectStart.x); 
            const height = Math.abs(currentY - selectStart.y); 
            
            // Convert back to screen coordinates for display
            const startScreenX = selectStart.x * scale + translateX - canvas.scrollLeft + canvasRect.left;
            const startScreenY = selectStart.y * scale + translateY - canvas.scrollTop + canvasRect.top;
            const currentScreenX = currentX * scale + translateX - canvas.scrollLeft + canvasRect.left;
            const currentScreenY = currentY * scale + translateY - canvas.scrollTop + canvasRect.top;
            
            const screenX = Math.min(startScreenX, currentScreenX);
            const screenY = Math.min(startScreenY, currentScreenY);
            const screenWidth = Math.abs(currentScreenX - startScreenX);
            const screenHeight = Math.abs(currentScreenY - startScreenY);
            
            selectionRect.style.left = screenX + 'px'; 
            selectionRect.style.top = screenY + 'px'; 
            selectionRect.style.width = screenWidth + 'px'; 
            selectionRect.style.height = screenHeight + 'px'; 
            
            clearSelection(); 
            Object.values(workflow.items).forEach(item => { 
                if (!item.parentId) { 
                    const node = document.getElementById(item.id); 
                    if (node) { 
                        const itemRight = item.x + item.width; 
                        const itemBottom = item.y + item.height; 
                        if (item.x < x + width && itemRight > x && item.y < y + height && itemBottom > y) { 
                            node.classList.add('multi-selected'); 
                            selectedNodes.push(node); 
                        } 
                    } 
                } 
            }); 
        }
        function endSelection() { 
            isSelecting = false; 
            selectionRect.style.display = 'none'; 
            selectStart = { x: 0, y: 0 };
        }
        function groupSelectedNodes() { 
            if (selectedNodes.length < 1) return; 
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0; 
            selectedNodes.forEach(node => { 
                const item = workflow.items[node.id]; 
                minX = Math.min(minX, item.x); 
                minY = Math.min(minY, item.y); 
                maxX = Math.max(maxX, item.x + item.width); 
                maxY = Math.max(maxY, item.y + item.height); 
            }); 
            const groupId = `item-${workflow.nextItemId++}`; 
            const groupWidth = (maxX - minX) + 80; 
            const groupHeight = (maxY - minY) + 120; 
            const groupItem = { 
                id: groupId, 
                type: 'group', 
                x: minX - 40, 
                y: minY - 60, 
                width: groupWidth, 
                height: groupHeight, 
                data: { 
                    title: 'New Group', 
                    isExpanded: true, 
                    children: [], 
                    expandedWidth: groupWidth, 
                    expandedHeight: groupHeight,
                    viewMode: 'icon'
                }, 
                parentId: null 
            }; 
            workflow.items[groupId] = groupItem; 
            groups[groupId] = []; 
            selectedNodes.forEach(node => { 
                const item = workflow.items[node.id]; 
                item.parentId = groupId; 
                groups[groupId].push(item.id); 
                node.remove(); 
            }); 
            groupItem.data.children = groups[groupId]; 
            createNode(groupItem); 
            clearSelection(); 
            updateLinks();
            autoSave(); 
        }
        function openNodeInModal(itemId) { const item = workflow.items[itemId]; if (!item) return; modalContent.innerHTML = ''; createNode(item, true); modalOverlay.style.display = 'flex'; }
        function closeModal() { modalOverlay.style.display = 'none'; modalContent.innerHTML = ''; }
        function clearAll() { if (confirm('Clear all nodes and data? This cannot be undone.')) { localStorage.removeItem(STORAGE_KEY); workflow = { items: {}, links: [], nextItemId: 1, nextLinkId: 1 }; groups = {}; renderWorkflow(); resetView(); } }
        function zoom(factor, clientX, clientY) { 
            const newScale = Math.min(Math.max(MIN_ZOOM, scale * factor), MAX_ZOOM); 
            if (newScale === scale) return; 
            
            const canvasRect = canvas.getBoundingClientRect(); 
            
            // Use mouse position or center of canvas
            const mouseX = clientX !== undefined ? clientX - canvasRect.left : canvasRect.width / 2;
            const mouseY = clientY !== undefined ? clientY - canvasRect.top : canvasRect.height / 2;
            
            // Convert mouse position to world coordinates before zoom
            const worldX = (mouseX + canvas.scrollLeft - translateX) / scale;
            const worldY = (mouseY + canvas.scrollTop - translateY) / scale;
            
            // Update scale
            const oldScale = scale;
            scale = newScale;
            
            // Calculate new translation to keep the world point under the mouse
            translateX = mouseX + canvas.scrollLeft - worldX * scale;
            translateY = mouseY + canvas.scrollTop - worldY * scale;
            
            updateViewportTransform(); 
        }
        function updateViewportTransform() { viewport.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`; zoomIndicator.textContent = Math.round(scale * 100) + '%'; updateLinks(); autoSave(); }
        function clearSelection() { 
            // Clear all selection classes from all nodes
            document.querySelectorAll('.node.selected, .node.multi-selected').forEach(node => {
                node.classList.remove('selected', 'multi-selected');
            });
            selectedNode = null; 
            selectedNodes = []; 
        }
        function selectNode(node, e) { 
            if (e) e.stopPropagation(); 
            if (node.id.startsWith('modal-')) return; 
            clearSelection(); 
            selectedNode = node; 
            node.classList.add('selected'); 
            selectedNodes = [node];
        }
        function toggleNode(node) { 
            const item = workflow.items[node.id]; 
            if (!item) return; 
            const isCurrentlyExpanded = node.classList.contains('expanded'); 
            item.data.isExpanded = !isCurrentlyExpanded; 
            node.classList.toggle('expanded'); 
            if (item.type === 'group') { 
                if (item.data.isExpanded) { 
                    const expandedWidth = item.data.expandedWidth || item.width; 
                    const expandedHeight = item.data.expandedHeight || item.height; 
                    node.style.width = expandedWidth + 'px'; 
                    node.style.height = expandedHeight + 'px'; 
                    item.width = expandedWidth; 
                    item.height = expandedHeight; 
                } else { 
                    if (!item.data.expandedWidth || !item.data.expandedHeight) { 
                        item.data.expandedWidth = item.width; 
                        item.data.expandedHeight = item.height; 
                    } 
                    node.style.width = GROUP_COLLAPSED_WIDTH + 'px'; 
                    node.style.height = GROUP_COLLAPSED_HEIGHT + 'px';
                    
                    // Update icon title with truncation
                    const iconTitle = node.querySelector('.group-icon-representation-title');
                    if (iconTitle) {
                        const truncatedTitle = item.data.title && item.data.title.length > 64 ? 
                            item.data.title.substring(0, 64) + '...' : 
                            (item.data.title || 'Untitled');
                        iconTitle.textContent = truncatedTitle;
                    }
                } 
            } 
            updateLinks(); 
            autoSave(); 
        }
        
        // --- Utility and Helper Functions ---
        function saveToLocalStorage() { try { const state = { workflow, groups, scale, translateX, translateY, scrollLeft: canvas.scrollLeft, scrollTop: canvas.scrollTop }; localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (error) { console.error('Error saving to localStorage:', error); } }
        function loadFromLocalStorage() { try { const savedState = localStorage.getItem(STORAGE_KEY); if (!savedState) return false; const state = JSON.parse(savedState); workflow = state.workflow || { items: {}, links: [], nextItemId: 1, nextLinkId: 1 }; groups = state.groups || {}; scale = state.scale || 1; translateX = state.translateX || 0; translateY = state.translateY || 0; renderWorkflow(); updateViewportTransform(); setTimeout(() => { if (state.scrollLeft) canvas.scrollLeft = state.scrollLeft; if (state.scrollTop) canvas.scrollTop = state.scrollTop; }, 50); return true; } catch (error) { console.error('Error loading from localStorage:', error); return false; } }
        let saveTimeout; 
        function autoSave() { 
            clearTimeout(saveTimeout); 
            saveTimeout = setTimeout(() => {
                saveToLocalStorage();
                if (githubConfig.connected && githubConfig.filePath) {
                    // Debounce GitHub saves
                    clearTimeout(window.githubSaveTimeout);
                    window.githubSaveTimeout = setTimeout(saveToGithub, 2000);
                }
            }, 100); 
        }
        function saveWorkflow() { const state = { items: workflow.items, links: workflow.links, nextItemId: workflow.nextItemId, nextLinkId: workflow.nextLinkId, groups: groups }; const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'workflow.json'; a.click(); URL.revokeObjectURL(url); }
        function handleFileLoad(e) { const file = e.target.files[0]; if (!file) return; loading.style.display = 'block'; const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); workflow = { items: data.items || {}, links: data.links || [], nextItemId: data.nextItemId || 1, nextLinkId: data.nextLinkId || 1 }; groups = data.groups || {}; renderWorkflow(); loading.style.display = 'none'; updateViewportTransform(); fitToScreen(); autoSave(); } catch (error) { alert('Error loading workflow: ' + error.message); loading.style.display = 'none'; } }; reader.readAsText(file); }
        function renderWorkflow() { 
            viewport.querySelectorAll('.node').forEach(node => node.remove()); 
            Object.values(workflow.items).forEach(item => { 
                if (!item.parentId) {
                    // Ensure groups have a view mode
                    if (item.type === 'group' && !item.data.viewMode) {
                        item.data.viewMode = 'icon';
                    }
                    createNode(item);
                }
            }); 
            updateLinks(); 
        }
        function createTaskContent(data) { return `${data.description ? `<div class="task-description">${data.description}</div>` : ''}<div class="task-content"><label><span>Complexity (SP):</span><select class="complexity">${[1,2,3,5,8,13,21,34,55,89].map(n => `<option value="${n}" ${data.complexity == n ? 'selected' : ''}>${n}</option>`).join('')}</select></label><label><span>Risk Factor:</span><input type="number" class="risk" value="${data.risk || 0.1}" min="0" max="1" step="0.05"></label><label><span>Priority:</span><input type="number" class="priority" value="${data.priority || 3}" min="1" max="5"></label><label><span>Duration (days):</span><input type="number" class="duration" value="${data.duration || 1}" min="0.5" step="0.5"></label></div>`; }
        function createEstimatorContent(data) { return `<div class="estimator-content"><h4>Team & Project Factors</h4><label><span>Team Members:</span><input type="number" class="team-members" value="${data.teamMembers || 5}" min="1"></label><label><span>Hours/Day/Member:</span><input type="number" class="working-hours" value="${data.workingHours || 8}" min="1" step="0.5"></label><label><span>Overhead Factor:</span><input type="number" class="overhead" value="${data.overhead || 0.15}" min="0" max="0.99" step="0.01"></label><label><span>Productivity:</span><input type="number" class="productivity" value="${data.productivity || 0.85}" min="0.1" max="1.5" step="0.01"></label><label><span>Maturity/Learn:</span><input type="number" class="learning-curve" value="${data.learningCurve || 1.0}" min="0.5" step="0.05"></label><label><span>Hours per SP:</span><input type="number" class="hours-per-sp" value="${data.hoursPerStoryPoint || 4}" min="0.5" step="0.1"></label><div class="estimator-result"><p>Total Base SP: <strong class="base-sp">0</strong></p><p>Total Adjusted SP: <strong class="adj-sp">0</strong></p><p>Team Velocity: <strong class="velocity">0</strong></p><p>Est. Duration: <strong class="duration">N/A</strong></p></div></div>`; }
        function createDataContent(data) { return data.dataType === 'image' ? `<img class="data-image" src="${data.content}" alt="Pasted image">` : `<textarea class="data-text">${data.content || ''}</textarea>`; }
        function createADRContent(data) { return `<div class="adr-content"><label><span>Code:</span><input type="text" class="adr-code" value="${data.code || ''}"></label><label><span>Category:</span><input type="text" class="adr-category" value="${data.category || ''}"></label><label><span>Topic:</span><textarea class="adr-topic">${data.topic || ''}</textarea></label></div>`; }
        function populateGroupContent(groupContentElement, groupItem, viewMode = 'icon') {
            groupContentElement.innerHTML = '';
            const children = groups[groupItem.id] || groupItem.data.children || [];
            
            if (children.length === 0) {
                groupContentElement.innerHTML = '<div style="text-align: center; color: #999; padding: 40px; width: 100%;">No items in this group<br><small>Drag items here or right-click to add</small></div>';
                return;
            }
            
            if (viewMode === 'icon') {
                children.forEach(childId => {
                    const childItem = workflow.items[childId];
                    if (!childItem) return;
                    const childIcon = document.createElement('div');
                    childIcon.className = 'group-child-icon';
                    childIcon.dataset.childId = childId;
                    childIcon.innerHTML = `<div class="group-child-icon-symbol">${nodeIcons[childItem.type] || '📄'}</div><div class="group-child-icon-title">${childItem.data.title || 'Untitled'}</div>`;
                    childIcon.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        openNodeInModal(childId);
                    });
                    childIcon.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showItemContextMenu(e, childItem);
                    });
                    childIcon.addEventListener('mousedown', (e) => {
                        if (e.altKey) {
                            e.preventDefault();
                            e.stopPropagation();
                            startItemDragOut(childItem, e);
                        }
                    });
                    groupContentElement.appendChild(childIcon);
                });
            } else if (viewMode === 'list') {
                children.forEach(childId => {
                    const childItem = workflow.items[childId];
                    if (!childItem) return;
                    const listItem = document.createElement('div');
                    listItem.className = 'group-list-item';
                    listItem.dataset.childId = childId;
                    listItem.innerHTML = `
                        <div class="group-list-item-icon">${nodeIcons[childItem.type] || '📄'}</div>
                        <div class="group-list-item-title">${childItem.data.title || 'Untitled'}</div>
                    `;
                    listItem.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        openNodeInModal(childId);
                    });
                    listItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showItemContextMenu(e, childItem);
                    });
                    listItem.addEventListener('mousedown', (e) => {
                        if (e.altKey) {
                            e.preventDefault();
                            e.stopPropagation();
                            startItemDragOut(childItem, e);
                        }
                    });
                    groupContentElement.appendChild(listItem);
                });
                            } else if (viewMode === 'graph') {
                if (children.length === 0) {
                    groupContentElement.innerHTML = '<div style="text-align: center; color: #999; padding: 40px; width: 100%; min-height: 200px; display: flex; align-items: center; justify-content: center;">No items in this group<br><small>Drag items here or right-click to add</small></div>';
                    return;
                }
                
                const graphViewport = document.createElement('div');
                graphViewport.className = 'group-graph-viewport';
                
                // Calculate bounds for all children
                let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                children.forEach((childId, index) => {
                    const childItem = workflow.items[childId];
                    if (!childItem) return;
                    
                    // Set initial position if not set
                    if (childItem.groupX === undefined || childItem.groupY === undefined) {
                        childItem.groupX = 50 + (index % 3) * 200;
                        childItem.groupY = 50 + Math.floor(index / 3) * 150;
                    }
                    
                    minX = Math.min(minX, childItem.groupX);
                    minY = Math.min(minY, childItem.groupY);
                    maxX = Math.max(maxX, childItem.groupX + (childItem.width || 200));
                    maxY = Math.max(maxY, childItem.groupY + (childItem.height || 100));
                });
                
                // Set viewport size based on content
                const padding = 50;
                const viewportWidth = Math.max(400, maxX + padding);
                const viewportHeight = Math.max(300, maxY + padding);
                graphViewport.style.width = '100%';
                graphViewport.style.height = Math.min(600, viewportHeight) + 'px';
                graphViewport.style.position = 'relative';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.classList.add('group-graph-svg');
                svg.style.width = viewportWidth + 'px';
                svg.style.height = viewportHeight + 'px';
                svg.innerHTML = `
                    <defs>
                        <marker id="group-arrowhead-${groupItem.id}" markerWidth="10" markerHeight="7" 
                                refX="9.5" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" class="link-arrow"/>
                        </marker>
                    </defs>
                `;
                graphViewport.appendChild(svg);
                
                children.forEach((childId) => {
                    const childItem = workflow.items[childId];
                    if (!childItem) return;
                    
                    const inlineNode = createNode(childItem, false, true);
                    graphViewport.appendChild(inlineNode);
                    
                    // Update bounds if this is a group
                    if (childItem.type === 'group') {
                        const groupWidth = childItem.data.isExpanded ? 
                            Math.min(childItem.width || 300, 400) : 
                            GROUP_COLLAPSED_WIDTH;
                        const groupHeight = childItem.data.isExpanded ? 
                            Math.min(childItem.height || 200, 350) : 
                            GROUP_COLLAPSED_HEIGHT;
                        
                        maxX = Math.max(maxX, (childItem.groupX || 0) + groupWidth);
                        maxY = Math.max(maxY, (childItem.groupY || 0) + groupHeight);
                    }
                });
                
                // Update viewport height after creating all nodes
                const finalViewportHeight = Math.max(300, maxY + padding);
                graphViewport.style.height = Math.min(600, finalViewportHeight) + 'px';
                svg.style.height = finalViewportHeight + 'px';
                
                groupContentElement.appendChild(graphViewport);
                
                // Update links for items in this group
                setTimeout(() => {
                    updateGroupLinks(groupItem.id);
                    
                    // Update SVG size after links are drawn
                    const svg = graphViewport.querySelector('.group-graph-svg');
                    if (svg) {
                        const allNodes = graphViewport.querySelectorAll('.node.inline-node');
                        let actualMaxY = maxY;
                        allNodes.forEach(node => {
                            const nodeBottom = parseInt(node.style.top) + parseInt(node.style.height);
                            actualMaxY = Math.max(actualMaxY, nodeBottom);
                        });
                        const finalHeight = actualMaxY + padding;
                        svg.style.height = finalHeight + 'px';
                        graphViewport.style.height = Math.min(600, finalHeight) + 'px';
                    }
                }, 100);
            }
        }
        
        function setGroupViewMode(groupId, viewMode) {
            const item = workflow.items[groupId];
            if (!item || item.type !== 'group') return;
            
            // If switching to graph view, ensure all children have positions
            if (viewMode === 'graph') {
                const children = groups[groupId] || item.data.children || [];
                children.forEach((childId, index) => {
                    const childItem = workflow.items[childId];
                    if (childItem && (childItem.groupX === undefined || childItem.groupY === undefined)) {
                        childItem.groupX = 50 + (index % 3) * 200;
                        childItem.groupY = 50 + Math.floor(index / 3) * 150;
                    }
                });
            }
            
            item.data.viewMode = viewMode;
            
            // Find the node - could be regular or inline
            let node = document.getElementById(groupId);
            if (!node) {
                node = document.getElementById(`inline-${groupId}`);
            }
            if (!node) return;
            
            // Update view control buttons
            node.querySelectorAll('.view-control').forEach(btn => btn.classList.remove('active'));
            const activeBtn = Array.from(node.querySelectorAll('.view-control')).find(btn => {
                if (viewMode === 'icon' && btn.innerHTML === '⊞') return true;
                if (viewMode === 'list' && btn.innerHTML === '☰') return true;
                if (viewMode === 'graph' && btn.innerHTML === '⊙') return true;
                return false;
            });
            if (activeBtn) activeBtn.classList.add('active');
            
            // Repopulate content
            const groupContent = node.querySelector('.group-content');
            if (groupContent) {
                groupContent.className = 'group-content ' + viewMode + '-view';
                populateGroupContent(groupContent, item, viewMode);
            }
            
            autoSave();
        }
        
        function updateGroupLinks(groupId) {
            const groupItem = workflow.items[groupId];
            if (!groupItem || groupItem.data.viewMode !== 'graph') return;
            
            // Find the group node - could be regular or inline
            let groupNode = document.getElementById(groupId);
            if (!groupNode) {
                groupNode = document.getElementById(`inline-${groupId}`);
            }
            if (!groupNode) return;
            
            const svg = groupNode.querySelector('.group-graph-svg');
            if (!svg) return;
            
            // Clear existing paths (except defs)
            while (svg.lastChild && svg.lastChild.tagName !== 'defs') {
                svg.removeChild(svg.lastChild);
            }
            
            const children = groups[groupId] || groupItem.data.children || [];
            const childItems = children.map(id => workflow.items[id]).filter(item => item);
            
            workflow.links.forEach(link => {
                if (children.includes(link.sourceId) && children.includes(link.targetId)) {
                    const sourceItem = workflow.items[link.sourceId];
                    const targetItem = workflow.items[link.targetId];
                    
                    if (!sourceItem || !targetItem) return;
                    
                    // Create bounding boxes for routing
                    const sourceBox = {
                        x: sourceItem.groupX || 0,
                        y: sourceItem.groupY || 0,
                        width: Math.min(sourceItem.width || 200, 200),
                        height: Math.min(sourceItem.height || 100, 150),
                        centerX: (sourceItem.groupX || 0) + Math.min(sourceItem.width || 200, 200) / 2,
                        centerY: (sourceItem.groupY || 0) + Math.min(sourceItem.height || 100, 150) / 2
                    };
                    sourceBox.right = sourceBox.x + sourceBox.width;
                    sourceBox.bottom = sourceBox.y + sourceBox.height;
                    
                    const targetBox = {
                        x: targetItem.groupX || 0,
                        y: targetItem.groupY || 0,
                        width: Math.min(targetItem.width || 200, 200),
                        height: Math.min(targetItem.height || 100, 150),
                        centerX: (targetItem.groupX || 0) + Math.min(targetItem.width || 200, 200) / 2,
                        centerY: (targetItem.groupY || 0) + Math.min(targetItem.height || 100, 150) / 2
                    };
                    targetBox.right = targetBox.x + targetBox.width;
                    targetBox.bottom = targetBox.y + targetBox.height;
                    
                    // Get obstacles (other items in the group)
                    const obstacles = childItems
                        .filter(item => item.id !== sourceItem.id && item.id !== targetItem.id)
                        .map(item => ({
                            x: (item.groupX || 0) - ROUTING_MARGIN,
                            y: (item.groupY || 0) - ROUTING_MARGIN,
                            width: Math.min(item.width || 200, 200) + 2 * ROUTING_MARGIN,
                            height: Math.min(item.height || 100, 150) + 2 * ROUTING_MARGIN,
                            right: (item.groupX || 0) + Math.min(item.width || 200, 200) + ROUTING_MARGIN,
                            bottom: (item.groupY || 0) + Math.min(item.height || 100, 150) + ROUTING_MARGIN
                        }));
                    
                    // Route the path
                    let pathPoints = routePath(
                        addMargin(sourceBox, ROUTING_MARGIN),
                        addMargin(targetBox, ROUTING_MARGIN),
                        obstacles
                    );
                    
                    // Snap to edges
                    pathPoints = snapPathToEdges(sourceBox, targetBox, pathPoints);
                    
                    // Create SVG path
                    const pathString = pointsToPath(pathPoints);
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathString);
                    path.setAttribute('marker-end', `url(#group-arrowhead-${groupId})`);
                    path.classList.add('link');
                    svg.appendChild(path);
                }
            });
        }
        
        function addMargin(box, margin) {
            return {
                x: box.x - margin,
                y: box.y - margin,
                width: box.width + 2 * margin,
                height: box.height + 2 * margin,
                right: box.right + margin,
                bottom: box.bottom + margin,
                centerX: box.centerX,
                centerY: box.centerY
            };
        }
        
        function showItemContextMenu(e, item) {
            // Hide all menus first
            contextMenu.style.display = 'none';
            selectionContextMenu.style.display = 'none';
            itemContextMenu.style.display = 'none';
            
            // Store the item for menu actions
            window.contextMenuItem = item;
            
            // Show/hide ungroup option based on item type
            const ungroupOption = itemContextMenu.querySelector('.item-ungroup');
            if (item.type === 'group') {
                ungroupOption.style.display = 'block';
            } else {
                ungroupOption.style.display = 'none';
            }
            
            itemContextMenu.style.left = e.clientX + 'px';
            itemContextMenu.style.top = e.clientY + 'px';
            itemContextMenu.style.display = 'block';
        }
        
        function handleItemMenuClick(e) {
            const menuItem = e.target.closest('.menu-item');
            if (!menuItem) return;
            const action = menuItem.dataset.action;
            itemContextMenu.style.display = 'none';
            
            const item = window.contextMenuItem;
            if (!item) return;
            
            switch (action) {
                case 'open-item':
                    openNodeInModal(item.id);
                    break;
                case 'ungroup-item':
                    if (item.type === 'group') {
                        ungroupItems(item.id);
                    }
                    break;
                case 'delete-item':
                    if (confirm('Delete this item?')) {
                        deleteNode(item.id);
                    }
                    break;
            }
            
            window.contextMenuItem = null;
        }
        
        function startItemDragOut(item, e) {
            if (!item.parentId) return;
            
            // Remove from group
            removeFromGroup(item.id, item.parentId);
            
            // Get the newly created node
            const node = document.getElementById(item.id);
            if (!node) return;
            
            // Position it at cursor
            const canvasRect = canvas.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale - 50;
            const y = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale - 25;
            
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            item.x = x;
            item.y = y;
            
            // Start dragging immediately
            startDrag(node, e);
        }
        
        function ungroupItems(groupId) {
            const groupItem = workflow.items[groupId];
            if (!groupItem || groupItem.type !== 'group') return;
            
            const children = groups[groupId] || groupItem.data.children || [];
            const groupX = groupItem.x;
            const groupY = groupItem.y;
            
            // Move children to workspace
            children.forEach((childId, index) => {
                const childItem = workflow.items[childId];
                if (childItem) {
                    childItem.parentId = null;
                    childItem.x = groupX + 50 + (index % 3) * 150;
                    childItem.y = groupY + 50 + Math.floor(index / 3) * 150;
                    createNode(childItem);
                }
            });
            
            // Remove the group
            deleteNode(groupId);
            updateLinks();
        }
        function autoLayout() { const rootNodes = Object.values(workflow.items).filter(item => !item.parentId); if (rootNodes.length === 0) return; const hierarchy = buildHierarchy(rootNodes); const nodeSpacingX = 350, nodeSpacingY = 250, startX = 100, startY = 100; layoutHierarchy(hierarchy, startX, startY, nodeSpacingX, nodeSpacingY); Object.values(workflow.items).forEach(item => { const node = document.getElementById(item.id); if (node && !node.classList.contains('inline-node')) { node.style.left = item.x + 'px'; node.style.top = item.y + 'px'; } }); updateLinks(); autoSave(); }
        function buildHierarchy(nodes) { const hierarchy = []; nodes.forEach(node => { const hierNode = { item: node, children: [] }; const childLinks = workflow.links.filter(link => link.sourceId === node.id); childLinks.forEach(link => { const childItem = workflow.items[link.targetId]; if (childItem) hierNode.children.push(...buildHierarchy([childItem])); }); hierarchy.push(hierNode); }); return hierarchy; }
        function layoutHierarchy(hierarchy, startX, startY, spacingX, spacingY) { let currentX = startX; hierarchy.forEach((node, index) => { const subtreeWidth = calculateSubtreeWidth(node, spacingX); const centerX = currentX + subtreeWidth / 2; node.item.x = centerX - node.item.width / 2; node.item.y = startY; if (node.children.length > 0) layoutHierarchy(node.children, currentX, startY + spacingY, spacingX, spacingY); currentX += subtreeWidth + spacingX; }); }
        function calculateSubtreeWidth(node, spacing) { if (node.children.length === 0) return node.item.width; let totalWidth = 0; node.children.forEach((child, index) => { totalWidth += calculateSubtreeWidth(child, spacing); if (index < node.children.length - 1) totalWidth += spacing; }); return Math.max(node.item.width, totalWidth); }
        function editTitle(titleEl, item, e) { 
            e.stopPropagation(); 
            const oldTitle = titleEl.textContent; 
            titleEl.contentEditable = true; 
            titleEl.focus(); 
            const range = document.createRange(); 
            range.selectNodeContents(titleEl); 
            const sel = window.getSelection(); 
            sel.removeAllRanges(); 
            sel.addRange(range); 
            const save = () => { 
                titleEl.contentEditable = false; 
                const newTitle = titleEl.textContent.trim(); 
                if (newTitle) { 
                    item.data.title = newTitle; 
                    autoSave(); 
                    const node = document.getElementById(item.id); 
                    if (node && item.type === 'group') { 
                        const iconTitle = node.querySelector('.group-icon-representation-title'); 
                        if (iconTitle) {
                            const truncatedTitle = newTitle.length > 64 ? 
                                newTitle.substring(0, 61) + '...' : 
                                newTitle;
                            iconTitle.textContent = truncatedTitle;
                        }
                    } 
                } else { 
                    titleEl.textContent = oldTitle; 
                } 
            }; 
            titleEl.addEventListener('blur', save, { once: true }); 
            titleEl.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    save(); 
                } else if (e.key === 'Escape') { 
                    titleEl.textContent = oldTitle; 
                    save(); 
                } 
            }); 
        }
        function handleSelectionMenuClick(e) {
            const menuItem = e.target.closest('.menu-item');
            if (!menuItem) return;
            const action = menuItem.dataset.action;
            selectionContextMenu.style.display = 'none';
            
            switch (action) {
                case 'group-elements':
                    groupSelectedNodes();
                    break;
                case 'delete-all':
                    if (selectedNodes.length > 0 && confirm(`Delete ${selectedNodes.length} selected node(s)?`)) {
                        selectedNodes.forEach(node => deleteNode(node.id));
                        clearSelection();
                    }
                    break;
                case 'export-workflow':
                    exportSelectedWorkflow();
                    break;
                case 'export-html':
                    exportSelectedAsHTML();
                    break;
            }
        }
        
        function exportSelectedWorkflow() {
            const selectedIds = selectedNodes.map(node => node.id);
            const exportData = {
                items: {},
                links: [],
                nextItemId: workflow.nextItemId,
                nextLinkId: workflow.nextLinkId,
                groups: {}
            };
            
            // Export selected items and their children
            selectedIds.forEach(id => {
                const item = workflow.items[id];
                if (item) {
                    exportData.items[id] = item;
                    if (item.type === 'group' && groups[id]) {
                        groups[id].forEach(childId => {
                            if (workflow.items[childId]) {
                                exportData.items[childId] = workflow.items[childId];
                            }
                        });
                        exportData.groups[id] = groups[id];
                    }
                }
            });
            
            // Export links between selected items
            workflow.links.forEach(link => {
                const sourceInSelection = Object.keys(exportData.items).includes(link.sourceId);
                const targetInSelection = Object.keys(exportData.items).includes(link.targetId);
                if (sourceInSelection && targetInSelection) {
                    exportData.links.push(link);
                }
            });
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected-workflow.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportSelectedAsHTML() {
            const selectedIds = selectedNodes.map(node => node.id);
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exported Workflow</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .node { background: white; border: 1px solid #ddd; border-radius: 8px; padding: 16px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .node-title { font-size: 18px; font-weight: bold; margin-bottom: 12px; }
        .node-content { white-space: pre-wrap; }
        .node-type { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin-bottom: 8px; }
        .type-scribble { background: #fff9c4; }
        .type-task { background: #e1bee7; }
        .type-group { background: #bbdefb; }
        .type-estimator { background: #c8e6c9; }
        .type-data { background: #ffe0b2; }
        .group-children { margin-left: 20px; margin-top: 16px; }
        .task-field { margin: 4px 0; }
        .task-label { font-weight: bold; }
    </style>
</head>
<body>
    <h1>Exported Workflow Nodes</h1>`;
            
            selectedIds.forEach(id => {
                const item = workflow.items[id];
                if (item) {
                    html += generateNodeHTML(item);
                }
            });
            
            html += `
</body>
</html>`;
            
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workflow-export.html';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function generateNodeHTML(item) {
            let html = `
    <div class="node">
        <div class="node-type type-${item.type}">${item.type.toUpperCase()}</div>
        <div class="node-title">${item.data.title || 'Untitled'}</div>
        <div class="node-content">`;
            
            switch (item.type) {
                case 'scribble':
                case 'knowledge-section':
                case 'knowledge-subsection':
                case 'knowledge-item':
                    html += item.data.content || '';
                    break;
                case 'task':
                    html += `<div class="task-field"><span class="task-label">Description:</span> ${item.data.description || 'N/A'}</div>`;
                    html += `<div class="task-field"><span class="task-label">Complexity:</span> ${item.data.complexity || 'N/A'} SP</div>`;
                    html += `<div class="task-field"><span class="task-label">Risk Factor:</span> ${item.data.risk || 'N/A'}</div>`;
                    html += `<div class="task-field"><span class="task-label">Priority:</span> ${item.data.priority || 'N/A'}</div>`;
                    html += `<div class="task-field"><span class="task-label">Duration:</span> ${item.data.duration || 'N/A'} days</div>`;
                    break;
                case 'group':
                    html += '<div class="group-children">';
                    const children = groups[item.id] || item.data.children || [];
                    children.forEach(childId => {
                        const childItem = workflow.items[childId];
                        if (childItem) {
                            html += generateNodeHTML(childItem);
                        }
                    });
                    html += '</div>';
                    break;
                case 'data':
                    if (item.data.dataType === 'image') {
                        html += `<img src="${item.data.content}" style="max-width: 100%; height: auto;">`;
                    } else {
                        html += item.data.content || '';
                    }
                    break;
                case 'adr':
                    html += `<div class="task-field"><span class="task-label">Code:</span> ${item.data.code || 'N/A'}</div>`;
                    html += `<div class="task-field"><span class="task-label">Category:</span> ${item.data.category || 'N/A'}</div>`;
                    html += `<div class="task-field"><span class="task-label">Topic:</span> ${item.data.topic || 'N/A'}</div>`;
                    break;
            }
            
            html += `
        </div>
    </div>`;
            return html;
        }
        
        function handleMenuClick(e) { const menuItem = e.target.closest('.menu-item'); if (!menuItem) return; const action = menuItem.dataset.action; contextMenu.style.display = 'none'; if (action === 'paste') { navigator.clipboard.readText().then(text => { if (text) { const id = `item-${workflow.nextItemId++}`; const pasteItem = { id, type: 'data', x: contextMenuPos.x, y: contextMenuPos.y, width: 300, height: 200, data: { title: 'Pasted Text', dataType: 'text', content: text }, parentId: contextMenuPos.groupId || null }; workflow.items[id] = pasteItem; if(contextMenuPos.groupId) { addNodeToGroup(pasteItem, contextMenuPos.groupId); } else { createNode(pasteItem); } autoSave(); } }).catch(err => console.log('Paste from context menu requires clipboard permissions')); contextMenuPos.groupId = null; return; } let type = null; switch (action) { case 'add-scribble': type = 'scribble'; break; case 'add-task': type = 'task'; break; case 'add-group': type = 'group'; break; case 'add-estimator': type = 'estimator'; break; case 'add-knowledge-section': type = 'knowledge-section'; break; case 'add-knowledge-subsection': type = 'knowledge-subsection'; break; case 'add-knowledge-item': type = 'knowledge-item'; break; case 'add-adr': type = 'adr'; break; } if (type) addNode(type, contextMenuPos.x, contextMenuPos.y); contextMenuPos.groupId = null; }
        function setupInputListeners(node, item) { const inputs = node.querySelectorAll('input, select, textarea'); inputs.forEach(input => { input.addEventListener('change', () => { updateItemData(item); if (item.type === 'estimator') calculateEstimates(); autoSave(); }); input.addEventListener('mousedown', e => e.stopPropagation()); }); }
        function updateItemData(item) { const node = document.getElementById(item.id) || document.getElementById(`modal-${item.id}`); if (!node) return; switch (item.type) { case 'scribble': item.data.content = node.querySelector('.scribble-content')?.value; break; case 'task': item.data.complexity = node.querySelector('.complexity')?.value; item.data.risk = node.querySelector('.risk')?.value; item.data.priority = node.querySelector('.priority')?.value; item.data.duration = node.querySelector('.duration')?.value; break; case 'estimator': item.data.teamMembers = node.querySelector('.team-members')?.value; item.data.workingHours = node.querySelector('.working-hours')?.value; item.data.overhead = node.querySelector('.overhead')?.value; item.data.productivity = node.querySelector('.productivity')?.value; item.data.learningCurve = node.querySelector('.learning-curve')?.value; item.data.hoursPerStoryPoint = node.querySelector('.hours-per-sp')?.value; break; case 'data': if (node.querySelector('.data-text')) item.data.content = node.querySelector('.data-text').value; break; case 'adr': item.data.code = node.querySelector('.adr-code')?.value; item.data.category = node.querySelector('.adr-category')?.value; item.data.topic = node.querySelector('.adr-topic')?.value; break; default: item.data.content = node.querySelector('.knowledge-content')?.value; break; } }
        function calculateEstimates() { const estimator = Object.values(workflow.items).find(item => item.type === 'estimator'); if (!estimator) return; const estimatorNode = document.getElementById(estimator.id); if (!estimatorNode) return; let totalBaseSP = 0, totalAdjustedSP = 0; Object.values(workflow.items).filter(item => item.type === 'task' && (document.getElementById(item.id) || item.parentId)).forEach(task => { const complexity = parseFloat(task.data.complexity) || 0; const risk = parseFloat(task.data.risk) || 0; const duration = parseFloat(task.data.duration) || 0; totalBaseSP += complexity; const adjustedSP = complexity * (1 + risk) * (1 + 0.1 * Math.log(1 + Math.max(0, duration))); totalAdjustedSP += adjustedSP + (adjustedSP * (0.15 + 0.20 * risk)); }); const R = parseInt(estimator.data.teamMembers) || 0, D = parseFloat(estimator.data.workingHours) || 0, O = parseFloat(estimator.data.overhead) || 0, P = parseFloat(estimator.data.productivity) || 0, L = parseFloat(estimator.data.learningCurve) || 0, H = parseFloat(estimator.data.hoursPerStoryPoint) || 0; const effectiveHoursPerDay = R * D * (1 - O) * P * L; let teamVelocity = 0, estDuration = 'N/A'; if (H > 0 && effectiveHoursPerDay > 0) { teamVelocity = effectiveHoursPerDay / H; if (totalAdjustedSP > 0 && teamVelocity > 0) estDuration = (totalAdjustedSP / teamVelocity).toFixed(1); } estimatorNode.querySelector('.base-sp').textContent = totalBaseSP.toFixed(2); estimatorNode.querySelector('.adj-sp').textContent = totalAdjustedSP.toFixed(2); estimatorNode.querySelector('.velocity').textContent = teamVelocity.toFixed(2); estimatorNode.querySelector('.duration').textContent = estDuration; }
        function addNodeToGroup(item, groupId) { 
            if (!groups[groupId]) groups[groupId] = []; 
            
            // Remove from previous parent if exists
            if (item.parentId && item.parentId !== groupId) {
                const oldParent = workflow.items[item.parentId];
                if (oldParent) {
                    groups[item.parentId] = groups[item.parentId].filter(id => id !== item.id);
                    oldParent.data.children = groups[item.parentId];
                }
            }
            
            // Add to new group
            if (!groups[groupId].includes(item.id)) {
                groups[groupId].push(item.id); 
            }
            item.parentId = groupId;
            
            const parentItem = workflow.items[groupId]; 
            if (parentItem) {
                parentItem.data.children = groups[groupId];
                
                const groupNode = document.getElementById(groupId); 
                if (groupNode) { 
                    const groupContent = groupNode.querySelector('.group-content'); 
                    if (groupContent) { 
                        populateGroupContent(groupContent, parentItem, parentItem.data.viewMode || 'icon'); 
                    } 
                    
                    // Remove the node from viewport only if it exists
                    const existingNode = document.getElementById(item.id);
                    if (existingNode && !existingNode.id.startsWith('inline-')) {
                        existingNode.remove();
                    }
                }
            }
        }
        function handlePaste(e) { const activeElement = document.activeElement; if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA') return; const items = e.clipboardData.items; for (let item of items) { if (item.type.indexOf('image') !== -1) { e.preventDefault(); const blob = item.getAsFile(); const reader = new FileReader(); reader.onload = (event) => { const id = `item-${workflow.nextItemId++}`; const canvasRect = canvas.getBoundingClientRect(); const defaultX = (canvasRect.width / 2 + canvas.scrollLeft - translateX) / scale; const defaultY = (canvasRect.height / 2 + canvas.scrollTop - translateY) / scale; const pasteItem = { id, type: 'data', x: contextMenuPos.x || defaultX, y: contextMenuPos.y || defaultY, width: 300, height: 200, data: { title: 'Pasted Image', dataType: 'image', content: event.target.result }, parentId: contextMenuPos.groupId || null }; workflow.items[id] = pasteItem; if (contextMenuPos.groupId) { addNodeToGroup(pasteItem, contextMenuPos.groupId); } else { createNode(pasteItem); } autoSave(); }; reader.readAsDataURL(blob); return; } } }
        function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; }
        function handleDrop(e) { e.preventDefault(); const files = e.dataTransfer.files; const canvasRect = canvas.getBoundingClientRect(); const dropX = (e.clientX - canvasRect.left + canvas.scrollLeft - translateX) / scale; const dropY = (e.clientY - canvasRect.top + canvas.scrollTop - translateY) / scale; Array.from(files).forEach((file, index) => { if (file.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (event) => { const id = `item-${workflow.nextItemId++}`; const item = { id, type: 'data', x: dropX + (index * 20), y: dropY + (index * 20), width: 300, height: 200, data: { title: file.name, dataType: 'image', content: event.target.result }, parentId: null }; workflow.items[id] = item; createNode(item); autoSave(); }; reader.readAsDataURL(file); } else if (file.type.startsWith('text/') || file.name.endsWith('.txt') || file.name.endsWith('.md')) { const reader = new FileReader(); reader.onload = (event) => { const id = `item-${workflow.nextItemId++}`; const item = { id, type: 'scribble', x: dropX + (index * 20), y: dropY + (index * 20), width: 400, height: 300, data: { title: file.name, content: event.target.result, isExpanded: true }, parentId: null }; workflow.items[id] = item; createNode(item); autoSave(); }; reader.readAsText(file); } }); }
        function fitToScreen() { 
            if (Object.keys(workflow.items).length === 0) return; 
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0; 
            let hasVisibleNodes = false; 
            
            Object.values(workflow.items).forEach(item => { 
                if (!item.parentId) { 
                    hasVisibleNodes = true; 
                    minX = Math.min(minX, item.x); 
                    minY = Math.min(minY, item.y); 
                    maxX = Math.max(maxX, item.x + item.width); 
                    maxY = Math.max(maxY, item.y + item.height); 
                } 
            }); 
            
            if (!hasVisibleNodes) { 
                resetView(); 
                return; 
            }
            
            const padding = 50; 
            const contentWidth = maxX - minX; 
            const contentHeight = maxY - minY; 
            const canvasWidth = canvas.clientWidth; 
            const canvasHeight = canvas.clientHeight; 
            const scaleX = canvasWidth / (contentWidth + padding * 2); 
            const scaleY = canvasHeight / (contentHeight + padding * 2); 
            scale = Math.min(scaleX, scaleY, 1); 
            
            // Center the content
            const contentCenterX = minX + contentWidth / 2;
            const contentCenterY = minY + contentHeight / 2;
            const canvasCenterX = canvasWidth / 2;
            const canvasCenterY = canvasHeight / 2;
            
            translateX = canvasCenterX - contentCenterX * scale + canvas.scrollLeft;
            translateY = canvasCenterY - contentCenterY * scale + canvas.scrollTop;
            
            updateViewportTransform(); 
            
            // Reset scroll to center
            canvas.scrollLeft = 0;
            canvas.scrollTop = 0;
        }
        function resetView() { scale = 1; translateX = 0; translateY = 0; updateViewportTransform(); fitToScreen(); }
        function hasExpandableContent(item) { return item.type !== 'group' && (item.type === 'scribble' || item.type === 'task' || item.type === 'estimator' || item.type === 'adr' || item.type.startsWith('knowledge-') || item.type === 'data'); }

        // --- GitHub Integration ---
        function showGithubDialog() {
            githubDialog.style.display = 'flex';
            if (githubConfig.connected) {
                showGithubFilesSection();
            } else {
                showGithubAuthSection();
                // Pre-fill saved values
                document.getElementById('github-repo-url').value = 
                    githubConfig.owner && githubConfig.repo ? 
                    `https://github.com/${githubConfig.owner}/${githubConfig.repo}.git` : '';
                document.getElementById('github-token').value = githubConfig.token || '';
            }
        }
        
        function hideGithubDialog() {
            githubDialog.style.display = 'none';
        }
        
        function showGithubAuthSection() {
            document.getElementById('github-auth-section').style.display = 'block';
            document.getElementById('github-files-section').style.display = 'none';
            document.getElementById('github-loading').style.display = 'none';
        }
        
        function showGithubFilesSection() {
            document.getElementById('github-auth-section').style.display = 'none';
            document.getElementById('github-files-section').style.display = 'block';
            document.getElementById('github-loading').style.display = 'none';
            listGithubFiles();
        }
        
        function showGithubLoading() {
            document.getElementById('github-auth-section').style.display = 'none';
            document.getElementById('github-files-section').style.display = 'none';
            document.getElementById('github-loading').style.display = 'block';
        }
        
        async function connectToGithub() {
            const repoUrl = document.getElementById('github-repo-url').value.trim();
            const token = document.getElementById('github-token').value.trim();
            
            if (!repoUrl || !token) {
                alert('Please enter both repository URL and personal access token');
                return;
            }
            
            // Parse GitHub URL
            const match = repoUrl.match(/github\.com[:/]([^/]+)\/([^/.]+)/);
            if (!match) {
                alert('Invalid GitHub repository URL');
                return;
            }
            
            githubConfig.owner = match[1];
            githubConfig.repo = match[2];
            githubConfig.token = token;
            
            showGithubLoading();
            
            try {
                // Test connection by listing files
                const response = await fetch(
                    `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents`,
                    {
                        headers: {
                            'Authorization': `token ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (!response.ok) {
                    const errorData = await response.json();
                    if (response.status === 409 && errorData.message && errorData.message.includes('sha')) {
                        // SHA conflict - file was updated elsewhere
                        console.warn('GitHub file conflict detected, fetching latest version...');
                        
                        // Fetch the latest file data
                        const latestResponse = await fetch(
                            `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`,
                            {
                                headers: {
                                    'Authorization': `token ${githubConfig.token}`,
                                    'Accept': 'application/vnd.github.v3+json'
                                }
                            }
                        );
                        
                        if (latestResponse.ok) {
                            const latestData = await latestResponse.json();
                            githubConfig.sha = latestData.sha;
                            
                            // Retry the save with the new SHA
                            const retryResponse = await fetch(
                                `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`,
                                {
                                    method: 'PUT',
                                    headers: {
                                        'Authorization': `token ${githubConfig.token}`,
                                        'Accept': 'application/vnd.github.v3+json',
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        message: `Update workflow: ${new Date().toISOString()}`,
                                        content: content,
                                        sha: githubConfig.sha
                                    })
                                }
                            );
                            
                            if (retryResponse.ok) {
                                const retryResult = await retryResponse.json();
                                githubConfig.sha = retryResult.content.sha;
                                saveGithubConfig();
                                
                                showGithubStatus('Saved to GitHub (resolved conflict)', 'success');
                                setTimeout(() => {
                                    showGithubStatus('Connected to GitHub: ' + githubConfig.filePath);
                                }, 2000);
                                return;
                            }
                        }
                    }
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                githubConfig.connected = true;
                saveGithubConfig();
                showGithubFilesSection();
                
            } catch (error) {
                console.error('GitHub connection error:', error);
                alert('Failed to connect to GitHub. Please check your repository URL and token.');
                showGithubAuthSection();
            }
        }
        
        async function listGithubFiles() {
            const filesList = document.getElementById('github-files-list');
            filesList.innerHTML = '';
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents`,
                    {
                        headers: {
                            'Authorization': `token ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const files = await response.json();
                const jsonFiles = files.filter(file => file.name.endsWith('.json'));
                
                if (jsonFiles.length === 0) {
                    filesList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">No workflow files found in repository root<br><small>Note: Subdirectory support coming soon</small></div>';
                    return;
                }
                
                jsonFiles.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'github-file-item';
                    fileItem.dataset.path = file.path;
                    fileItem.dataset.sha = file.sha;
                    fileItem.innerHTML = `
                        <span class="github-file-icon">📄</span>
                        <span class="github-file-name">${file.name}</span>
                        <span class="github-file-size">${formatFileSize(file.size)}</span>
                    `;
                    fileItem.addEventListener('click', () => selectGithubFile(fileItem));
                    filesList.appendChild(fileItem);
                });
                
            } catch (error) {
                console.error('Error listing GitHub files:', error);
                filesList.innerHTML = '<div style="padding: 20px; text-align: center; color: #d93025;">Error loading files</div>';
            }
        }
        
        function selectGithubFile(fileItem) {
            document.querySelectorAll('.github-file-item').forEach(item => 
                item.classList.remove('selected')
            );
            fileItem.classList.add('selected');
            document.getElementById('github-load-btn').disabled = false;
        }
        
        async function loadSelectedFile() {
            const selectedFile = document.querySelector('.github-file-item.selected');
            if (!selectedFile) return;
            
            const filePath = selectedFile.dataset.path;
            const sha = selectedFile.dataset.sha;
            
            showGithubLoading();
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${filePath}`,
                    {
                        headers: {
                            'Authorization': `token ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const fileData = await response.json();
                const content = atob(fileData.content);
                const workflowData = JSON.parse(content);
                
                // Load the workflow
                workflow = {
                    items: workflowData.items || {},
                    links: workflowData.links || [],
                    nextItemId: workflowData.nextItemId || 1,
                    nextLinkId: workflowData.nextLinkId || 1
                };
                groups = workflowData.groups || {};
                
                // Clear local storage to avoid conflicts
                localStorage.removeItem(STORAGE_KEY);
                
                // Store GitHub file info for saving
                githubConfig.filePath = filePath;
                githubConfig.sha = fileData.sha;
                saveGithubConfig();
                
                renderWorkflow();
                updateViewportTransform();
                fitToScreen();
                
                hideGithubDialog();
                showGithubStatus('Connected to GitHub: ' + filePath);
                
            } catch (error) {
                console.error('Error loading file from GitHub:', error);
                alert('Failed to load workflow file from GitHub');
                showGithubFilesSection();
            }
        }
        
        async function saveToGithub() {
            if (!githubConfig.connected || !githubConfig.filePath) return;
            
            showGithubStatus('Saving to GitHub...', 'saving');
            
            const state = {
                items: workflow.items,
                links: workflow.links,
                nextItemId: workflow.nextItemId,
                nextLinkId: workflow.nextLinkId,
                groups: groups
            };
            
            const content = btoa(JSON.stringify(state, null, 2));
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Update workflow: ${new Date().toISOString()}`,
                            content: content,
                            sha: githubConfig.sha
                        })
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const result = await response.json();
                githubConfig.sha = result.content.sha;
                saveGithubConfig();
                
                showGithubStatus('Saved to GitHub', 'success');
                setTimeout(() => {
                    showGithubStatus('Connected to GitHub: ' + githubConfig.filePath);
                }, 2000);
                
            } catch (error) {
                console.error('Error saving to GitHub:', error);
                showGithubStatus('Failed to save to GitHub', 'error');
                setTimeout(() => {
                    showGithubStatus('Connected to GitHub: ' + githubConfig.filePath);
                }, 3000);
            }
        }
        
        function showGithubStatus(message, type = 'info') {
            githubStatus.textContent = message;
            githubStatus.className = type === 'error' ? 'error' : (type === 'saving' ? 'saving' : '');
            githubStatus.style.display = 'flex';
            
            // Auto-hide after success
            if (type === 'success') {
                setTimeout(() => {
                    githubStatus.style.display = 'none';
                }, 3000);
            }
        }
        
        function saveGithubConfig() {
            // Save config but not the token for security
            const configToSave = {
                owner: githubConfig.owner,
                repo: githubConfig.repo,
                filePath: githubConfig.filePath,
                connected: githubConfig.connected
            };
            localStorage.setItem(GITHUB_CONFIG_KEY, JSON.stringify(configToSave));
        }
        
        function loadGithubConfig() {
            const saved = localStorage.getItem(GITHUB_CONFIG_KEY);
            if (saved) {
                const config = JSON.parse(saved);
                Object.assign(githubConfig, config);
                if (githubConfig.connected && githubConfig.filePath) {
                    showGithubStatus('GitHub: ' + githubConfig.filePath + ' (token required)');
                }
            }
        }
        
        async function createNewGithubFile() {
            const fileName = prompt('Enter a name for the new workflow file:', 'workflow.json');
            if (!fileName) return;
            
            const filePath = fileName.endsWith('.json') ? fileName : fileName + '.json';
            
            showGithubLoading();
            
            try {
                // Check if file already exists
                const checkResponse = await fetch(
                    `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${filePath}`,
                    {
                        headers: {
                            'Authorization': `token ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (checkResponse.ok) {
                    alert('A file with this name already exists. Please choose a different name.');
                    showGithubFilesSection();
                    return;
                }
                
                // Create new empty workflow
                const newWorkflow = {
                    items: {},
                    links: [],
                    nextItemId: 1,
                    nextLinkId: 1,
                    groups: {}
                };
                
                const content = btoa(JSON.stringify(newWorkflow, null, 2));
                
                const response = await fetch(
                    `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${filePath}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${githubConfig.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Create new workflow: ${filePath}`,
                            content: content
                        })
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Load the new empty workflow
                workflow = newWorkflow;
                groups = {};
                
                // Clear local storage
                localStorage.removeItem(STORAGE_KEY);
                
                // Store GitHub file info
                githubConfig.filePath = filePath;
                githubConfig.sha = result.content.sha;
                saveGithubConfig();
                
                renderWorkflow();
                updateViewportTransform();
                
                hideGithubDialog();
                showGithubStatus('Created and connected to: ' + filePath);
                
            } catch (error) {
                console.error('Error creating GitHub file:', error);
                alert('Failed to create new workflow file on GitHub');
                showGithubFilesSection();
            }
        }
        
        function disconnectFromGithub() {
            if (confirm('Disconnect from GitHub? You will need to re-enter your token to reconnect.')) {
                githubConfig = {
                    owner: '',
                    repo: '',
                    token: '',
                    filePath: '',
                    sha: '',
                    connected: false
                };
                localStorage.removeItem(GITHUB_CONFIG_KEY);
                githubStatus.style.display = 'none';
                hideGithubDialog();
            }
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Start the application
        initialize();
    </script>
    <div id="bottom-bar">
        <span>Advanced Knowledge Tree Workflow System v1.3.1</span>
    </div>
</body>
</html>
